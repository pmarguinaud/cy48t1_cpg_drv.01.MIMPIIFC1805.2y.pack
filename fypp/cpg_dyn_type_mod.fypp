#:set ISARG = 0
#:set ELARG = 1
#:set NDIMS = 2
#:set AS_void             = []
#:set AS_0_nflevg         = [ [ '0', 'NLEV' ] ]
#:set AS_1_nflevg         = [ [ '1', 'NLEV' ] ]
#:set AS_1_nflevg_yytrcp0 = [ [ '1', 'NLEV' ], [ '1', 'YYTRCP0%NDIM' ] ]
#:set AS_0_nflevg_yytcty0 = [ [ '0', 'NLEV' ], [ '1', 'YYTCTY0%NDIM' ] ]
#:set list = { &
& "PHI"            : [False, False, AS_0_nflevg],          "PRE"            : [False, False, AS_0_nflevg],         &
& "PHIF"           : [True,  True,  AS_1_nflevg],          "RCP"            : [True,  True,  AS_1_nflevg_yytrcp0], &
& "PREF"           : [True,  True,  AS_1_nflevg],          "CTY"            : [True,  False, AS_0_nflevg_yytcty0], &
& "WRL"            : [True,  False, AS_1_nflevg]                                                                   &
& }
MODULE CPG_DYN_TYPE_MOD

USE FIELD_MODULE
USE FIELD_REGISTRY_MOD
USE PARKIND1, ONLY : JPRB, JPIM

IMPLICIT NONE

TYPE CPG_DYN_TYPE

#:for var in list
  #:set ndim = 1 + len (list[var][NDIMS])
  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: ${var}$ (${", ".join ([":"] * ndim)}$) => NULL ()
  TYPE (FIELD_${ndim+1}$D), POINTER :: F_${var}$ => NULL ()
#:endfor

CONTAINS
  PROCEDURE :: INIT => CPG_DYN_TYPE_INIT
  PROCEDURE :: UPDATE_VIEW => CPG_DYN_TYPE_UPDATE_VIEW
  PROCEDURE :: FINAL => CPG_DYN_TYPE_FINAL
END TYPE

CONTAINS

#:def gdim (d)
  #:if d[0] == '0' 
    #:set s = "+1"
  #:elif d[0] == '1' 
    #:set s = ""
  #:else 
    #:set s = "-" + d[0] + "+1"
  #:endif
  #:set s = d[1] + s
$:s
#:enddef gdim

#:def temporary (var, dim, ind)
  #:set ndim = 1 + len (dim)
  #:if ndim == 1
${ind}$SELF%F_${var}$ => CREATE_TEMPORARY ("${var}$", GEOM=REGISTRY%GEOM, PERSISTENT=PERSISTENT)
  #:elif ndim == 2
    #:set s2 = gdim (dim[0])
${ind}$SELF%F_${var}$ => CREATE_TEMPORARY ("${var}$", GEOM=REGISTRY%GEOM, NLEV=${s2}$, PERSISTENT=PERSISTENT)
  #:elif ndim == 3
    #:set s2 = gdim (dim[0])
    #:set s3 = gdim (dim[1])
${ind}$SELF%F_${var}$ => CREATE_TEMPORARY ("${var}$", GEOM=REGISTRY%GEOM, NLEV=${s2}$, NDIM=${s3}$, PERSISTENT=PERSISTENT)
  #:endif
#:enddef temporary

#:def argn (a)
  #:if a[0:1] != "P"
    #:set a = "P" + a
  #:endif
$:a
#:enddef argn

SUBROUTINE CPG_DYN_TYPE_INIT (SELF, REGISTRY, NLEV, PERSISTENT &
#:for var in list
  #:if list[var][ISARG]
                           &, ${argn (var)}$ &
  #:endif
#:endfor
                           &)

USE INTDYN_MOD, ONLY : YYTCTY0, YYTRCP0

CLASS (CPG_DYN_TYPE)                  :: SELF
TYPE (FIELD_REGISTRY), INTENT (INOUT) :: REGISTRY
INTEGER (KIND=JPIM),   INTENT (IN)    :: NLEV
LOGICAL, OPTIONAL,     INTENT (IN)    :: PERSISTENT
#:for var in list
  #:if list[var][ISARG]
    #:set ndim = 1 + len (list[var][NDIMS]) + 1
REAL(KIND=JPRB),       INTENT (IN), OPTIONAL, TARGET  :: ${argn (var)}$(${", ".join ([":"] * ndim)}$)
  #:endif
#:endfor

#:for var in list
  #:if list[var][ISARG]
IF (PRESENT (${argn (var)}$)) THEN
  SELF%F_${var}$ => CREATE_FIELD_WRAP ('${var}$', ${argn (var)}$)
    #:if list[var][ELARG]
ELSE
$:temporary (var, list[var][NDIMS], "  ")
    #:endif
ENDIF
  #:else
$:temporary (var, list[var][NDIMS], "")
  #:endif

#:endfor

END SUBROUTINE

#:def pdim (d)
  #:if all (map (lambda x: x[0] == '1', d))
    #:set s = ""
  #:else
    #:set s = "(1:," + ", ".join (map (lambda x: x[0] + ":", d)) + ")"
  #:endif
$:s
#:enddef pdim

SUBROUTINE CPG_DYN_TYPE_UPDATE_VIEW (SELF, BLOCK_INDEX)

CLASS (CPG_DYN_TYPE)              :: SELF
INTEGER(KIND=JPIM), INTENT (IN)   :: BLOCK_INDEX

#:for var in list
  #:set ss = pdim (list[var][NDIMS])
IF (ASSOCIATED (SELF%F_${var}$)) SELF%${var}$ ${ss}$ => SELF%F_${var}$%GET_VIEW (BLOCK_INDEX)
#:endfor

END SUBROUTINE

SUBROUTINE CPG_DYN_TYPE_FINAL (SELF)
CLASS (CPG_DYN_TYPE)              :: SELF

#:for var in list
IF (ASSOCIATED (SELF%F_PHIF)) CALL DELETE_TEMPORARY (SELF%F_${var}$) 
#:endfor

END SUBROUTINE 

END MODULE CPG_DYN_TYPE_MOD

