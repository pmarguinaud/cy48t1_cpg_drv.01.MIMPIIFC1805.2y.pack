#:set surface_config_file = os.path.dirname(_THIS_FILE_) + '/surface_fields_config.yaml'
#:set surface_config = field_config.VariableConfiguration(surface_config_file)
#:set surface_prognostic = [field_config.VariableGroup(**group) for group in surface_config.schema['prognostic']]
#:set surface_diagnostic = [field_config.VariableGroup(**group) for group in surface_config.schema['diagnostic']]
#:set surface_variable_groups = surface_prognostic + surface_diagnostic

#:set config_file = os.path.dirname(_THIS_FILE_) + '/field_config.yaml'
#:set config = field_config.VariableConfiguration(config_file)
#:set gfl = config.groups['GFL']

MODULE FIELD_REGISTRY_MOD

USE PARKIND1, ONLY : JPIM, JPRB
USE FIELD_MODULE, ONLY: FIELD_2D, FIELD_INT2D, FIELD_LOG2D, FIELD_3D, FIELD_INT3D, FIELD_4D, FIELD_5D, &
 &                      FIELD_2D_EMPTY, FIELD_3D_EMPTY, FIELD_4D_EMPTY
USE GEOMETRY_MOD, ONLY: GEOMETRY
USE VARIABLE_MODULE, ONLY: VARIABLE_2D, VARIABLE_3D, VARIABLE_4D
USE FIELD_VARIABLES_MOD, ONLY: FIELD_VARIABLES
USE SURFACE_VARIABLES_MOD, ONLY: SURFACE_VARIABLES
USE YOMGMV, ONLY: TGMV
USE YOM_YGFL, ONLY: TYPE_GFL_COMP, TYPE_GFLD
USE YOMGFL, ONLY: TGFL
USE SURFACE_FIELDS_MIX, ONLY: TSURF, TYPE_SURF_MTL_2D, TYPE_SURF_MTL_3D, TYPE_SURF_GEN
USE EC_PHYS_FIELDS_MOD, ONLY: TEC_PHYS_FIELDS
USE MODEL_PHYSICS_RADIATION_MOD, ONLY : MODEL_PHYSICS_RADIATION_TYPE

IMPLICIT NONE

TYPE :: FIELD_REGISTRY
  TYPE(GEOMETRY), POINTER :: GEOM => NULL()
  INTEGER(KIND=JPIM) :: NPROMA, NBLOCKS

CONTAINS
  PROCEDURE :: INIT => FIELD_REGISTRY_INIT
  PROCEDURE :: FINAL => FIELD_REGISTRY_FINAL

  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_2D_GMV, FIELD_REGISTRY_CREATE_VARIABLE_3D_GMV
  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_GFL, FIELD_REGISTRY_CREATE_VARIABLE_ARRAY_GFL
  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_WRAP_2D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_2D
  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_WRAP_3D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_3D
  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_WRAP_4D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_4D
  GENERIC   :: CREATE_VARIABLE => &
   & FIELD_REGISTRY_CREATE_VARIABLE_2D_GMV, FIELD_REGISTRY_CREATE_VARIABLE_3D_GMV, &
   & FIELD_REGISTRY_CREATE_VARIABLE_GFL, FIELD_REGISTRY_CREATE_VARIABLE_ARRAY_GFL, &
   & FIELD_REGISTRY_CREATE_VARIABLE_WRAP_2D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_2D, &
   & FIELD_REGISTRY_CREATE_VARIABLE_WRAP_3D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_3D, &
   & FIELD_REGISTRY_CREATE_VARIABLE_WRAP_4D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_4D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_2D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_2D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_ARRAY_2D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_2D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_ARRAY2_2D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_2D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_3D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_3D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_ARRAY_3D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_3D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_ARRAY2_3D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_3D
  PROCEDURE :: REGISTER_GEOMETRY => FIELD_REGISTRY_REGISTER_GEOMETRY
  PROCEDURE :: REGISTER_GMV_FIELDS => FIELD_REGISTRY_REGISTER_GMV_FIELDS
  PROCEDURE :: REGISTER_GFL_FIELDS => FIELD_REGISTRY_REGISTER_GFL_FIELDS
  PROCEDURE :: REGISTER_SURFACE_FIELDS => FIELD_REGISTRY_REGISTER_SURFACE_FIELDS
  PROCEDURE :: REGISTER_EC_PHYS_FIELDS => FIELD_REGISTRY_REGISTER_EC_PHYS_FIELDS
  PROCEDURE :: REGISTER_PHYSICS_RADIATION_FIELDS => FIELD_REGISTRY_REGISTER_PHYSICS_RADIATION_FIELDS

END TYPE FIELD_REGISTRY

INTERFACE CREATE_FIELD_WRAP
  MODULE PROCEDURE CREATE_FIELD_WRAP_2D, CREATE_FIELD_WRAP_3D, CREATE_FIELD_WRAP_4D
  MODULE PROCEDURE CREATE_FIELD_WRAP_PACKED_2D, CREATE_FIELD_WRAP_PACKED_3D, CREATE_FIELD_WRAP_PACKED_4D
END INTERFACE CREATE_FIELD_WRAP

INTERFACE CREATE_TEMPORARY
  MODULE PROCEDURE CREATE_TEMPORARY_2D, CREATE_TEMPORARY_3D, CREATE_TEMPORARY_4D, CREATE_TEMPORARY_5D
END INTERFACE

INTERFACE CREATE_TEMPORARY_LU
#:for d in [2, 3, 4, 5]
  MODULE PROCEDURE CREATE_TEMPORARY_${d}$D_LU
#:endfor
#:for d in [2, 3]
  MODULE PROCEDURE CREATE_TEMPORARY_INT${d}$D_LU
#:endfor
#:for d in [2]
  MODULE PROCEDURE CREATE_TEMPORARY_LOG${d}$D_LU
#:endfor
END INTERFACE CREATE_TEMPORARY_LU

INTERFACE CREATE_TEMPORARY_INT
  MODULE PROCEDURE CREATE_TEMPORARY_INT2D, CREATE_TEMPORARY_INT3D
END INTERFACE

INTERFACE DELETE_TEMPORARY
  MODULE PROCEDURE DELETE_TEMPORARY_2D, DELETE_TEMPORARY_INT2D, DELETE_TEMPORARY_LOG2D
  MODULE PROCEDURE DELETE_TEMPORARY_3D, DELETE_TEMPORARY_INT3D, DELETE_TEMPORARY_4D, DELETE_TEMPORARY_5D
END INTERFACE DELETE_TEMPORARY

CONTAINS

  FUNCTION CREATE_FIELD_WRAP_2D(DATA, PERSISTENT, LBOUNDS) RESULT(FIELD_PTR)
    ! Create a single 2D field with implicit blocking dimension by wrapping existing data
    TYPE(FIELD_2D), POINTER :: FIELD_PTR
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:)
    LOGICAL, OPTIONAL, INTENT (IN) :: PERSISTENT
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (2)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_2D(DATA=DATA, PERSISTENT=PERSISTENT, LBOUNDS=LBOUNDS)
  END FUNCTION CREATE_FIELD_WRAP_2D

  FUNCTION CREATE_FIELD_WRAP_3D(DATA, PERSISTENT, LBOUNDS) RESULT(FIELD_PTR)
    ! Create a single 1D field with implicit blocking dimension by wrapping existing data
    TYPE(FIELD_3D), POINTER :: FIELD_PTR
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)
    LOGICAL, OPTIONAL, INTENT (IN) :: PERSISTENT
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (3)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_3D(DATA=DATA, PERSISTENT=PERSISTENT, LBOUNDS=LBOUNDS)
  END FUNCTION CREATE_FIELD_WRAP_3D

  FUNCTION CREATE_FIELD_WRAP_4D(DATA, PERSISTENT, LBOUNDS) RESULT(FIELD_PTR)
    ! Create a single 1D field with implicit blocking dimension by wrapping existing data
    TYPE(FIELD_4D), POINTER :: FIELD_PTR
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)
    LOGICAL, OPTIONAL, INTENT (IN) :: PERSISTENT
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (4)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_4D(DATA=DATA, PERSISTENT=PERSISTENT, LBOUNDS=LBOUNDS)
  END FUNCTION CREATE_FIELD_WRAP_4D

  FUNCTION CREATE_FIELD_WRAP_PACKED_2D(DATA, IDX, LBOUNDS) RESULT(FIELD_PTR)
    ! Create a single 2D field with implicit blocking dimension by wrapping existing data
    TYPE(FIELD_2D), POINTER :: FIELD_PTR
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (2)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_2D(DATA=DATA, IDX=IDX, LBOUNDS=LBOUNDS)
  END FUNCTION CREATE_FIELD_WRAP_PACKED_2D

  FUNCTION CREATE_FIELD_WRAP_PACKED_3D(DATA, IDX, LBOUNDS) RESULT(FIELD_PTR)
    ! Create a single 1D field with implicit blocking dimension by wrapping existing data
    TYPE(FIELD_3D), POINTER :: FIELD_PTR
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (3)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_3D(DATA=DATA, IDX=IDX, LBOUNDS=LBOUNDS)
  END FUNCTION CREATE_FIELD_WRAP_PACKED_3D

  FUNCTION CREATE_FIELD_WRAP_PACKED_4D(DATA, IDX, LBOUNDS) RESULT(FIELD_PTR)
    ! Create a single 1D field with implicit blocking dimension by wrapping existing data
    TYPE(FIELD_4D), POINTER :: FIELD_PTR
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (4)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_4D(DATA=DATA, IDX=IDX, LBOUNDS=LBOUNDS)
  END FUNCTION CREATE_FIELD_WRAP_PACKED_4D

  FUNCTION CREATE_FIELD_EMPTY_2D(SHAPE) RESULT(FIELD_PTR)
    ! Create an empty 2D field object with NULL data pointers
    TYPE(FIELD_2D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(1)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_2D_EMPTY(SHAPE=SHAPE)
  END FUNCTION CREATE_FIELD_EMPTY_2D

  FUNCTION CREATE_FIELD_EMPTY_3D(SHAPE) RESULT(FIELD_PTR)
    ! Create an empty 3D field object with NULL data pointers
    TYPE(FIELD_3D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(2)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_3D_EMPTY(SHAPE=SHAPE)
  END FUNCTION CREATE_FIELD_EMPTY_3D

  FUNCTION CREATE_FIELD_EMPTY_4D(SHAPE) RESULT(FIELD_PTR)
    ! Create an empty 4D field object with NULL data pointers
    TYPE(FIELD_4D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(3)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_4D_EMPTY(SHAPE=SHAPE)
  END FUNCTION CREATE_FIELD_EMPTY_4D

  FUNCTION CREATE_TEMPORARY_INT2D(GEOM, PERSISTENT) RESULT(FIELD_PTR)
    ! Create a single 2D field for temporary use with an implicit blocking dimension.
    TYPE(FIELD_INT2D), POINTER :: FIELD_PTR
    TYPE(GEOMETRY), INTENT(IN) :: GEOM
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: NPROMA, NBLOCKS

    ALLOCATE(FIELD_PTR)
    NBLOCKS = GEOM%YRDIM%NGPBLKS
    NPROMA = GEOM%YRDIM%NPROMA
    FIELD_PTR = FIELD_INT2D(SHAPE=[NPROMA], NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END FUNCTION CREATE_TEMPORARY_INT2D

  FUNCTION CREATE_TEMPORARY_INT3D(GEOM, NLEV, PERSISTENT, NLEV0) RESULT(FIELD_PTR)
    ! Create a single 3D field for temporary use with an implicit blocking dimension.
    TYPE(FIELD_INT3D), POINTER :: FIELD_PTR
    TYPE(GEOMETRY), INTENT(IN) :: GEOM
    INTEGER(KIND=JPIM), INTENT(IN) :: NLEV
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: NLEV0
    INTEGER(KIND=JPIM) :: NPROMA, NBLOCKS
    INTEGER(KIND=JPIM) :: IBOUNDS(3)

    IBOUNDS = 1
    IF (PRESENT (NLEV0)) IBOUNDS (2) = NLEV0

    ALLOCATE(FIELD_PTR)
    NBLOCKS = GEOM%YRDIM%NGPBLKS
    NPROMA = GEOM%YRDIM%NPROMA
    FIELD_PTR = FIELD_INT3D(SHAPE=[NPROMA, NLEV], NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT, LBOUNDS=IBOUNDS)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END FUNCTION CREATE_TEMPORARY_INT3D

  FUNCTION CREATE_TEMPORARY_LOG2D(GEOM, PERSISTENT) RESULT(FIELD_PTR)
    ! Create a single 2D field for temporary use with an implicit blocking dimension.
    TYPE(FIELD_LOG2D), POINTER :: FIELD_PTR
    TYPE(GEOMETRY), INTENT(IN) :: GEOM
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: NPROMA, NBLOCKS

    ALLOCATE(FIELD_PTR)
    NBLOCKS = GEOM%YRDIM%NGPBLKS
    NPROMA = GEOM%YRDIM%NPROMA
    FIELD_PTR = FIELD_LOG2D(SHAPE=[NPROMA], NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END FUNCTION CREATE_TEMPORARY_LOG2D

#:for d in [2, 3, 4, 5]
  SUBROUTINE CREATE_TEMPORARY_${d}$D_LU (FIELD_PTR, UBOUNDS, LBOUNDS, PERSISTENT) 
    ! Create a single ${d}$D field for temporary use with an implicit blocking dimension.
    TYPE(FIELD_${d}$D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS (${d}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${d}$)
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: NBLOCKS
    INTEGER(KIND=JPIM) :: ISIZE (${d}$)

    ISIZE = UBOUNDS
    IF (PRESENT (LBOUNDS)) ISIZE = ISIZE - LBOUNDS + 1

    ALLOCATE(FIELD_PTR)
    NBLOCKS = UBOUNDS (${d}$)
    FIELD_PTR = FIELD_${d}$D(SHAPE=ISIZE(1:${d}$-1), NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT, LBOUNDS=LBOUNDS)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END SUBROUTINE CREATE_TEMPORARY_${d}$D_LU
#:endfor

#:for d in [2, 3]
  SUBROUTINE CREATE_TEMPORARY_INT${d}$D_LU (FIELD_PTR, UBOUNDS, LBOUNDS, PERSISTENT) 
    ! Create a single ${d}$D field for temporary use with an implicit blocking dimension.
    TYPE(FIELD_INT${d}$D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS (${d}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${d}$)
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: NBLOCKS
    INTEGER(KIND=JPIM) :: ISIZE (${d}$)

    ISIZE = UBOUNDS
    IF (PRESENT (LBOUNDS)) ISIZE = ISIZE - LBOUNDS + 1

    ALLOCATE(FIELD_PTR)
    NBLOCKS = UBOUNDS (${d}$)
    FIELD_PTR = FIELD_INT${d}$D(SHAPE=ISIZE(1:${d}$-1), NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT, LBOUNDS=LBOUNDS)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END SUBROUTINE CREATE_TEMPORARY_INT${d}$D_LU
#:endfor

#:for d in [2]
  SUBROUTINE CREATE_TEMPORARY_LOG${d}$D_LU (FIELD_PTR, UBOUNDS, LBOUNDS, PERSISTENT) 
    ! Create a single ${d}$D field for temporary use with an implicit blocking dimension.
    TYPE(FIELD_LOG${d}$D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS (${d}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${d}$)
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: NBLOCKS
    INTEGER(KIND=JPIM) :: ISIZE (${d}$)

    ISIZE = UBOUNDS
    IF (PRESENT (LBOUNDS)) ISIZE = ISIZE - LBOUNDS + 1

    ALLOCATE(FIELD_PTR)
    NBLOCKS = UBOUNDS (${d}$)
    FIELD_PTR = FIELD_LOG${d}$D(SHAPE=ISIZE(1:${d}$-1), NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT, LBOUNDS=LBOUNDS)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END SUBROUTINE CREATE_TEMPORARY_LOG${d}$D_LU
#:endfor

  FUNCTION CREATE_TEMPORARY_2D(GEOM, PERSISTENT) RESULT(FIELD_PTR)
    ! Create a single 2D field for temporary use with an implicit blocking dimension.
    TYPE(FIELD_2D), POINTER :: FIELD_PTR
    TYPE(GEOMETRY), INTENT(IN) :: GEOM
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: NPROMA, NBLOCKS

    ALLOCATE(FIELD_PTR)
    NBLOCKS = GEOM%YRDIM%NGPBLKS
    NPROMA = GEOM%YRDIM%NPROMA
    FIELD_PTR = FIELD_2D(SHAPE=[NPROMA], NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END FUNCTION CREATE_TEMPORARY_2D

  FUNCTION CREATE_TEMPORARY_3D(GEOM, NLEV, PERSISTENT, NLEV0) RESULT(FIELD_PTR)
    ! Create a single 3D field for temporary use with an implicit blocking dimension.
    TYPE(FIELD_3D), POINTER :: FIELD_PTR
    TYPE(GEOMETRY), INTENT(IN) :: GEOM
    INTEGER(KIND=JPIM), INTENT(IN) :: NLEV
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: NLEV0
    INTEGER(KIND=JPIM) :: NPROMA, NBLOCKS
    INTEGER(KIND=JPIM) :: IBOUNDS(3)

    IBOUNDS = 1
    IF (PRESENT (NLEV0)) IBOUNDS (2) = NLEV0

    ALLOCATE(FIELD_PTR)
    NBLOCKS = GEOM%YRDIM%NGPBLKS
    NPROMA = GEOM%YRDIM%NPROMA
    FIELD_PTR = FIELD_3D(SHAPE=[NPROMA, NLEV], NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT, LBOUNDS=IBOUNDS)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END FUNCTION CREATE_TEMPORARY_3D

  FUNCTION CREATE_TEMPORARY_4D(GEOM, NLEV, NDIM, PERSISTENT, NLEV0, NDIM0) RESULT(FIELD_PTR)
    ! Create a single 4D field for temporary use with an implicit blocking dimension.
    TYPE(FIELD_4D), POINTER :: FIELD_PTR
    TYPE(GEOMETRY), INTENT(IN) :: GEOM
    INTEGER(KIND=JPIM), INTENT(IN) :: NLEV, NDIM
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: NLEV0, NDIM0
    INTEGER(KIND=JPIM) :: NPROMA, NBLOCKS
    INTEGER(KIND=JPIM) :: IBOUNDS(4)

    IBOUNDS = 1
    IF (PRESENT (NLEV0)) IBOUNDS (2) = NLEV0
    IF (PRESENT (NDIM0)) IBOUNDS (3) = NDIM0

    ALLOCATE(FIELD_PTR)
    NBLOCKS = GEOM%YRDIM%NGPBLKS
    NPROMA = GEOM%YRDIM%NPROMA
    FIELD_PTR = FIELD_4D(SHAPE=[NPROMA, NLEV, NDIM], NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT, LBOUNDS=IBOUNDS)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END FUNCTION CREATE_TEMPORARY_4D

  FUNCTION CREATE_TEMPORARY_5D(GEOM, NLEV, NDIM, NDIM2, PERSISTENT, NLEV0, NDIM0, NDIM20) RESULT(FIELD_PTR)
    ! Create a single 4D field for temporary use with an implicit blocking dimension.
    TYPE(FIELD_5D), POINTER :: FIELD_PTR
    TYPE(GEOMETRY), INTENT(IN) :: GEOM
    INTEGER(KIND=JPIM), INTENT(IN) :: NLEV, NDIM, NDIM2
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: NLEV0, NDIM0, NDIM20
    INTEGER(KIND=JPIM) :: NPROMA, NBLOCKS
    INTEGER(KIND=JPIM) :: IBOUNDS(5)

    IBOUNDS = 1
    IF (PRESENT (NLEV0 )) IBOUNDS (2) = NLEV0
    IF (PRESENT (NDIM0 )) IBOUNDS (3) = NDIM0
    IF (PRESENT (NDIM20)) IBOUNDS (4) = NDIM20

    ALLOCATE(FIELD_PTR)
    NBLOCKS = GEOM%YRDIM%NGPBLKS
    NPROMA = GEOM%YRDIM%NPROMA
    FIELD_PTR = FIELD_5D(SHAPE=[NPROMA, NLEV, NDIM, NDIM2], NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT, LBOUNDS=IBOUNDS)
    ! Due to Fortran's reallocation-on-assignment behaviour, the
    ! FIELD_PTR%PTR pointer needs updating here for owned objects.
    IF (FIELD_PTR%OWNED) FIELD_PTR%PTR => FIELD_PTR%DATA
  END FUNCTION CREATE_TEMPORARY_5D

  SUBROUTINE DELETE_TEMPORARY_2D(FIELD_PTR)
    ! Finalize a temporary field and deallocate the pointer
    TYPE(FIELD_2D), POINTER, INTENT(INOUT) :: FIELD_PTR

    CALL FIELD_PTR%FINAL()
    DEALLOCATE(FIELD_PTR)
  END SUBROUTINE DELETE_TEMPORARY_2D

  SUBROUTINE DELETE_TEMPORARY_INT2D(FIELD_PTR)
    ! Finalize a temporary field and deallocate the pointer
    TYPE(FIELD_INT2D), POINTER, INTENT(INOUT) :: FIELD_PTR

    CALL FIELD_PTR%FINAL()
    DEALLOCATE(FIELD_PTR)
  END SUBROUTINE DELETE_TEMPORARY_INT2D

  SUBROUTINE DELETE_TEMPORARY_INT3D(FIELD_PTR)
    ! Finalize a temporary field and deallocate the pointer
    TYPE(FIELD_INT3D), POINTER, INTENT(INOUT) :: FIELD_PTR

    CALL FIELD_PTR%FINAL()
    DEALLOCATE(FIELD_PTR)
  END SUBROUTINE DELETE_TEMPORARY_INT3D

  SUBROUTINE DELETE_TEMPORARY_LOG2D(FIELD_PTR)
    ! Finalize a temporary field and deallocate the pointer
    TYPE(FIELD_LOG2D), POINTER, INTENT(INOUT) :: FIELD_PTR

    CALL FIELD_PTR%FINAL()
    DEALLOCATE(FIELD_PTR)
  END SUBROUTINE DELETE_TEMPORARY_LOG2D

  SUBROUTINE DELETE_TEMPORARY_3D(FIELD_PTR)
    ! Finalize a temporary field and deallocate the pointer
    TYPE(FIELD_3D), POINTER, INTENT(INOUT) :: FIELD_PTR

    CALL FIELD_PTR%FINAL()
    DEALLOCATE(FIELD_PTR)
  END SUBROUTINE DELETE_TEMPORARY_3D

  SUBROUTINE DELETE_TEMPORARY_4D(FIELD_PTR)
    ! Finalize a temporary field and deallocate the pointer
    TYPE(FIELD_4D), POINTER, INTENT(INOUT) :: FIELD_PTR

    CALL FIELD_PTR%FINAL()
    DEALLOCATE(FIELD_PTR)
  END SUBROUTINE DELETE_TEMPORARY_4D

  SUBROUTINE DELETE_TEMPORARY_5D(FIELD_PTR)
    ! Finalize a temporary field and deallocate the pointer
    TYPE(FIELD_5D), POINTER, INTENT(INOUT) :: FIELD_PTR

    CALL FIELD_PTR%FINAL()
    DEALLOCATE(FIELD_PTR)
  END SUBROUTINE DELETE_TEMPORARY_5D


  SUBROUTINE FIELD_REGISTRY_INIT(SELF, GEOM)
    ! Constructor for global field registry
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(GEOMETRY), TARGET, INTENT(IN) :: GEOM

    SELF%GEOM => GEOM
    SELF%NBLOCKS = GEOM%YRDIM%NGPBLKS
    SELF%NPROMA = GEOM%YRDIM%NPROMA
  END SUBROUTINE FIELD_REGISTRY_INIT

  SUBROUTINE FIELD_REGISTRY_FINAL(SELF)
    ! Finalize and tear down the global field registry
    CLASS(FIELD_REGISTRY) :: SELF
    INTEGER(KIND=JPIM) :: I

  END SUBROUTINE FIELD_REGISTRY_FINAL


  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_2D(SELF, NAME, DATA) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_2D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:)

    VARIABLE = VARIABLE_2D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_2D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_3D(SELF, NAME, DATA) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_3D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)

    VARIABLE = VARIABLE_3D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_3D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_4D(SELF, NAME, DATA) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_4D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)

    VARIABLE = VARIABLE_4D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_4D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_2D(SELF, NAME, DATA, IDX) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_2D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX

    VARIABLE = VARIABLE_2D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA, IDX=IDX)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_2D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_3D(SELF, NAME, DATA, IDX) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_3D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX

    VARIABLE = VARIABLE_3D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA, IDX=IDX)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_3D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_4D(SELF, NAME, DATA, IDX) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_4D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX

    VARIABLE = VARIABLE_4D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA, IDX=IDX)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_4D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_2D_GMV(SELF, NAME, GMV, GMVT1, PT0, PT1, PT9, PPH9, PDL, PDM, &
   &                                             PDL9, PDM9, PERSISTENT) RESULT(VARIABLE)
    ! Create the VARIABLE metadata type and associate it with fields and data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_2D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: GMV(:,:,:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: GMVT1(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: PT0
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: PT1, PT9, PPH9, PDL, PDM, PDL9, PDM9
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    LOGICAL :: LT0, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9

    LT0 = PRESENT_AND_ACTIVE(PT0)
    LT1 = PRESENT_AND_ACTIVE(PT1)
    LT9 = PRESENT_AND_ACTIVE(PT9)
    LPH9 = PRESENT_AND_ACTIVE(PPH9)
    LDL = PRESENT_AND_ACTIVE(PDL)
    LDM = PRESENT_AND_ACTIVE(PDM)
    LDL9 = PRESENT_AND_ACTIVE(PDL9)
    LDM9 = PRESENT_AND_ACTIVE(PDM9)
    VARIABLE = VARIABLE_2D(NAME, LACTIVE=.TRUE., LADV=.TRUE., LT1=LT1, LT9=LT9, LPH9=LPH9, LDL=LDL, LDM=LDM, &
                         & LDL9=LDL9, LDM9=LDM9)

    ! Associate FIELD objects with VARIABLE according to provided pointers
    IF (LT0) THEN
      VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PT0)
    ELSE
      VARIABLE%FT0 => NULL ()
    ENDIF
    IF (LT1) THEN
      VARIABLE%FT1 => CREATE_FIELD_WRAP(DATA=GMVT1(:,:,:), IDX=PT1)
    ELSE
      VARIABLE%FT1 => NULL()
    END IF
    IF (LT9) THEN
      VARIABLE%FT9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PT9)
    ELSE
      VARIABLE%FT9 => NULL()
    END IF
    IF (LPH9) THEN
      VARIABLE%FPH9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PPH9)
    ELSE
      VARIABLE%FPH9 => NULL()
    END IF
    IF (LDL) THEN
      VARIABLE%FDL => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PDL)
    ELSE
      VARIABLE%FDL => NULL()
    END IF
    IF (LDM) THEN
      VARIABLE%FDM => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PDM)
    ELSE
      VARIABLE%FDM => NULL()
    END IF
    IF (LDL9) THEN
      VARIABLE%FDL9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PDL9)
    ELSE
      VARIABLE%FDL9 => NULL()
    END IF
    IF (LDM9) THEN
      VARIABLE%FDM9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PDM9)
    ELSE
      VARIABLE%FDM9 => NULL()
    END IF

  CONTAINS

    FUNCTION PRESENT_AND_ACTIVE(PTR)
      INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: PTR
      LOGICAL PRESENT_AND_ACTIVE
      IF (PRESENT(PTR)) THEN
        PRESENT_AND_ACTIVE = PTR >= 0
      ELSE
        PRESENT_AND_ACTIVE = .FALSE.
      END IF
    END FUNCTION PRESENT_AND_ACTIVE
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_2D_GMV

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_3D_GMV(SELF, NAME, GMV, GMVT1, PT0, PT1, PT9, PPH9, PDL, PDM, &
   &                                             PDL9, PDM9, PERSISTENT) RESULT(VARIABLE)
    ! Create the VARIABLE metadata type and associate it with fields and data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_3D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: GMV(:,:,:,:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: GMVT1(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: PT0
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: PT1, PT9, PPH9, PDL, PDM, PDL9, PDM9
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    LOGICAL :: LT0, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9

    LT0 = PRESENT_AND_ACTIVE(PT0)
    LT1 = PRESENT_AND_ACTIVE(PT1)
    LT9 = PRESENT_AND_ACTIVE(PT9)
    LPH9 = PRESENT_AND_ACTIVE(PPH9)
    LDL = PRESENT_AND_ACTIVE(PDL)
    LDM = PRESENT_AND_ACTIVE(PDM)
    LDL9 = PRESENT_AND_ACTIVE(PDL9)
    LDM9 = PRESENT_AND_ACTIVE(PDM9)
    VARIABLE = VARIABLE_3D(NAME, LACTIVE=.TRUE., LADV=.TRUE., LT1=LT1, LT9=LT9, LPH9=LPH9, &
                         & LDL=LDL, LDM=LDM, LDL9=LDL9, LDM9=LDM9)

    ! Associate FIELD objects with VARIABLE according to provided pointers
    IF (LT0) THEN
      VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PT0)
    ELSE
      VARIABLE%FT0 => NULL ()
    ENDIF

    IF (LT1) THEN
      VARIABLE%FT1 => CREATE_FIELD_WRAP(DATA=GMVT1(:,:,:,:), IDX=PT1)
    ELSE
      VARIABLE%FT1 => NULL()
    END IF
    IF (LT9) THEN
      VARIABLE%FT9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PT9)
    ELSE
      VARIABLE%FT9 => NULL()
    END IF
    IF (LPH9) THEN
      VARIABLE%FPH9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PPH9)
    ELSE
      VARIABLE%FPH9 => NULL()
    END IF
    IF (LDL) THEN
      VARIABLE%FDL => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PDL)
    ELSE
      VARIABLE%FDL => NULL()
    END IF
    IF (LDM) THEN
      VARIABLE%FDM => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PDM)
    ELSE
      VARIABLE%FDM => NULL()
    END IF
    IF (LDL9) THEN
      VARIABLE%FDL9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PDL9)
    ELSE
      VARIABLE%FDL9 => NULL()
    END IF
    IF (LDM9) THEN
      VARIABLE%FDM9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PDM9)
    ELSE
      VARIABLE%FDM9 => NULL()
    END IF

  CONTAINS

    FUNCTION PRESENT_AND_ACTIVE(PTR)
      INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: PTR
      LOGICAL PRESENT_AND_ACTIVE
      IF (PRESENT(PTR)) THEN
        PRESENT_AND_ACTIVE = PTR >= 0
      ELSE
        PRESENT_AND_ACTIVE = .FALSE.
      END IF
    END FUNCTION PRESENT_AND_ACTIVE
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_3D_GMV

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_GFL(SELF, NAME, YDCOMP, GFL, PERSISTENT) RESULT(VARIABLE)
    ! Create a single field from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_3D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(TYPE_GFL_COMP), INTENT(IN) :: YDCOMP
    TYPE(TGFL), TARGET, INTENT(INOUT) :: GFL
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT

    VARIABLE = VARIABLE_3D(NAME, CNAME=YDCOMP%CNAME, IGRBCODE=YDCOMP%IGRBCODE, LACTIVE=YDCOMP%LACTIVE, &
     &                     LADV=YDCOMP%LADV, LT1=YDCOMP%LT1, LT9=YDCOMP%LT9, LPH9=YDCOMP%LPHY, LWATER=YDCOMP%LWATER,&
     &                     RCP=YDCOMP%RCP)

    ! Associate FIELD objects with VARIABLE according to provided pointers
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MP > 0) THEN
      VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=GFL%GFL(:,:,:,:), IDX=YDCOMP%MP)
    ELSE
      VARIABLE%FT0 => NULL()
    END IF
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MP1 > 0) THEN
      VARIABLE%FT1 => CREATE_FIELD_WRAP(DATA=GFL%GFLT1(:,:,:,:), IDX=YDCOMP%MP1)
    ELSE
      VARIABLE%FT1 => NULL()
    END IF
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MP9 > 0) THEN
      VARIABLE%FT9 => CREATE_FIELD_WRAP(DATA=GFL%GFL(:,:,:,:), IDX=YDCOMP%MP9)
    ELSE
      VARIABLE%FT9 => NULL()
    END IF
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MP9_PH > 0) THEN
      VARIABLE%FPH9 => CREATE_FIELD_WRAP(DATA=GFL%GFL(:,:,:,:), IDX=YDCOMP%MP9_PH)
    ELSE
      VARIABLE%FPH9 => NULL()
    END IF
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MPL > 0) THEN
      VARIABLE%FDL => CREATE_FIELD_WRAP(DATA=GFL%GFL(:,:,:,:), IDX=YDCOMP%MPL)
    ELSE
      VARIABLE%FDL => NULL()
    END IF
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MPM > 0) THEN
      VARIABLE%FDM => CREATE_FIELD_WRAP(DATA=GFL%GFL(:,:,:,:), IDX=YDCOMP%MPM)
    ELSE
      VARIABLE%FDM => NULL()
    END IF

  CONTAINS

    FUNCTION ACTIVE_AND_TRUE(LFLAG)
      LOGICAL ACTIVE_AND_TRUE
      LOGICAL, INTENT(IN) :: LFLAG
      IF (YDCOMP%LACTIVE) THEN
        ACTIVE_AND_TRUE = LFLAG
      ELSE
        ACTIVE_AND_TRUE = .FALSE.
      END IF
    END FUNCTION ACTIVE_AND_TRUE
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_GFL

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_ARRAY_GFL(SELF, NAME, YDCOMP, GFL, PERSISTENT) RESULT(VARIABLES)
    ! Create a single field from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_3D), ALLOCATABLE :: VARIABLES(:)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(TYPE_GFL_COMP), POINTER, INTENT(IN) :: YDCOMP(:)
    TYPE(TGFL), TARGET, INTENT(INOUT) :: GFL
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: I
    CHARACTER(:), ALLOCATABLE :: VNAME

    IF (ASSOCIATED(YDCOMP)) THEN
      ALLOCATE(VARIABLES(SIZE(YDCOMP)))
      DO I=1, SIZE(YDCOMP)
        VNAME = NAME//"_"//CHAR(I)
        VARIABLES(I) = SELF%CREATE_VARIABLE(VNAME, YDCOMP(I), GFL, PERSISTENT=PERSISTENT)
      END DO
    ELSE
      ALLOCATE(VARIABLES(0))
    END IF
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_ARRAY_GFL

  SUBROUTINE FIELD_REGISTRY_REGISTER_GEOMETRY(SELF, VARIABLES, GEOM)
    ! Utility routine to register geometry fields in the current field container
    !
    ! Note that this is not meant to stay forever. It is required for gradual
    ! migration of existing arrays to an Atlas-based memory management system.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(FIELD_VARIABLES), POINTER, INTENT(INOUT) :: VARIABLES
    TYPE(GEOMETRY), INTENT(IN) :: GEOM

    IF (.NOT. ASSOCIATED(VARIABLES)) ALLOCATE(VARIABLES)

    VARIABLES%GEOMETRY%RCORI  = SELF%CREATE_VARIABLE(NAME='RCORI', DATA=GEOM%YRGSGEOM_B%RCORI)
    VARIABLES%GEOMETRY%RCORIC = SELF%CREATE_VARIABLE(NAME='RCORIC', DATA=GEOM%YRGSGEOM_B%RCORIC)
    VARIABLES%GEOMETRY%GEMU   = SELF%CREATE_VARIABLE(NAME='GEMU', DATA=GEOM%YRGSGEOM_B%GEMU)
    VARIABLES%GEOMETRY%GSQM2  = SELF%CREATE_VARIABLE(NAME='GSQM2', DATA=GEOM%YRGSGEOM_B%GSQM2)
    VARIABLES%GEOMETRY%GELAM  = SELF%CREATE_VARIABLE(NAME='GELAM', DATA=GEOM%YRGSGEOM_B%GELAM)
    VARIABLES%GEOMETRY%GELAT  = SELF%CREATE_VARIABLE(NAME='GELAT', DATA=GEOM%YRGSGEOM_B%GELAT)
    VARIABLES%GEOMETRY%GECLO  = SELF%CREATE_VARIABLE(NAME='GECLO', DATA=GEOM%YRGSGEOM_B%GECLO)
    VARIABLES%GEOMETRY%GESLO  = SELF%CREATE_VARIABLE(NAME='GESLO', DATA=GEOM%YRGSGEOM_B%GESLO)
    VARIABLES%GEOMETRY%GM     = SELF%CREATE_VARIABLE(NAME='GM', DATA=GEOM%YRGSGEOM_B%GM)
    VARIABLES%GEOMETRY%GMAPPA = SELF%CREATE_VARIABLE(NAME='GMAPPA', DATA=GEOM%YRGSGEOM_B%GMAPPA)
    VARIABLES%GEOMETRY%GOMVRL = SELF%CREATE_VARIABLE(NAME='GOMVRL', DATA=GEOM%YRGSGEOM_B%GOMVRL)
    VARIABLES%GEOMETRY%GOMVRM = SELF%CREATE_VARIABLE(NAME='GOMVRM', DATA=GEOM%YRGSGEOM_B%GOMVRM)
    VARIABLES%GEOMETRY%GNORDL = SELF%CREATE_VARIABLE(NAME='GNORDL', DATA=GEOM%YRGSGEOM_B%GNORDL)
    VARIABLES%GEOMETRY%GNORDM = SELF%CREATE_VARIABLE(NAME='GNORDM', DATA=GEOM%YRGSGEOM_B%GNORDM)
    VARIABLES%GEOMETRY%GNORDLCL = SELF%CREATE_VARIABLE(NAME='GNORDLCL', DATA=GEOM%YRGSGEOM_B%GNORDLCL)
    VARIABLES%GEOMETRY%GNORDMCL = SELF%CREATE_VARIABLE(NAME='GNORDMCL', DATA=GEOM%YRGSGEOM_B%GNORDMCL)
    VARIABLES%GEOMETRY%GNORDMCM = SELF%CREATE_VARIABLE(NAME='GNORDMCM', DATA=GEOM%YRGSGEOM_B%GNORDMCM)
    VARIABLES%GEOMETRY%GAW   = SELF%CREATE_VARIABLE(NAME='GAW', DATA=GEOM%YRGSGEOM_B%GAW)
    ! INTEGER(KIND=JPIM), POINTER,CONTIGUOUS :: NGPLAT(:,:)    => NULL()
    ! INTEGER(KIND=JPIM), POINTER,CONTIGUOUS :: NUNIQUEGP(:,:) => NULL()

    VARIABLES%GEOMETRY%OROG  = SELF%CREATE_VARIABLE(NAME='OROG', DATA=GEOM%YROROG_B%OROG)
    VARIABLES%GEOMETRY%OROGL = SELF%CREATE_VARIABLE(NAME='OROGL', DATA=GEOM%YROROG_B%OROGL)
    VARIABLES%GEOMETRY%OROGM = SELF%CREATE_VARIABLE(NAME='OROGM', DATA=GEOM%YROROG_B%OROGM)

    VARIABLES%GEOMETRY%RCOLON = SELF%CREATE_VARIABLE (NAME='RCOLON', DATA=GEOM%YRCSGEOM_B%RCOLON)
    VARIABLES%GEOMETRY%RSILON = SELF%CREATE_VARIABLE (NAME='RSILON', DATA=GEOM%YRCSGEOM_B%RSILON)
    VARIABLES%GEOMETRY%RINDX  = SELF%CREATE_VARIABLE (NAME='RINDX' , DATA=GEOM%YRCSGEOM_B%RINDX )
    VARIABLES%GEOMETRY%RINDY  = SELF%CREATE_VARIABLE (NAME='RINDY' , DATA=GEOM%YRCSGEOM_B%RINDY )
    VARIABLES%GEOMETRY%RATATH = SELF%CREATE_VARIABLE (NAME='RATATH', DATA=GEOM%YRCSGEOM_B%RATATH)
    VARIABLES%GEOMETRY%RATATX = SELF%CREATE_VARIABLE (NAME='RATATX', DATA=GEOM%YRCSGEOM_B%RATATX)

  END SUBROUTINE FIELD_REGISTRY_REGISTER_GEOMETRY

  SUBROUTINE FIELD_REGISTRY_REGISTER_GMV_FIELDS(SELF, VARIABLES, GMV)
    ! Utility routine to register GMV fields with the global field registry
    !
    ! Note that this is not meant to stay forever. It is required for gradual
    ! migration of existing arrays to the new object-based data management system.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(FIELD_VARIABLES), POINTER, INTENT(INOUT) :: VARIABLES
    TYPE(TGMV), INTENT(INOUT) :: GMV  ! Allocated arrays and pointers

    IF (.NOT. ASSOCIATED(VARIABLES)) ALLOCATE(VARIABLES)

    ASSOCIATE(GMVT1=>GMV%GMVT1, GMVS=>GMV%GMVS, GMVT1S=>GMV%GMVT1S, &
     &        YT0=>GMV%YT0, YT1=>GMV%YT1, YT9=>GMV%YT9, YPH9=>GMV%YPH9)
    VARIABLES%U = SELF%CREATE_VARIABLE('U', GMV%GMV, GMVT1, PT0=YT0%MU, PT1=YT1%MU, PT9=YT9%MU, PPH9=YPH9%MU, PDL=YT0%MUL, PDL9=YT9%MUL)
    VARIABLES%V = SELF%CREATE_VARIABLE('V', GMV%GMV, GMVT1, PT0=YT0%MV, PT1=YT1%MV, PT9=YT9%MV, PPH9=YPH9%MV, PDL=YT0%MVL, PDL9=YT9%MVL)
    VARIABLES%T = SELF%CREATE_VARIABLE('T', GMV%GMV, GMVT1, PT0=YT0%MT, PT1=YT1%MT, PT9=YT9%MT, PPH9=YPH9%MT, &
     &                                 PDL=YT0%MTL, PDM=YT0%MTM, PDL9=YT9%MTL, PDM9=YT9%MTM)
    VARIABLES%DIV = SELF%CREATE_VARIABLE('DIV', GMV%GMV, GMVT1, PT0=YT0%MDIV, PT1=YT1%MDIV, PT9=YT9%MDIV)
    VARIABLES%VOR = SELF%CREATE_VARIABLE('VOR', GMV%GMV, GMVT1, PT0=YT0%MVOR, PT1=YT1%MVOR, PT9=YT9%MVOR)
    ! Field   pointers in GMVS
    VARIABLES%SP  = SELF%CREATE_VARIABLE('SP', GMVS, GMVT1S, PT0=YT0%MSP, PT1=YT1%MSP, PT9=YT9%MSP, &
     &                                   PPH9=YPH9%MSP, PDL=YT0%MSPL, PDM=YT0%MSPM, PDL9=YT9%MSPL, PDM9=YT9%MSPM)
    VARIABLES%SPD = SELF%CREATE_VARIABLE('SPD', GMV%GMV, GMVT1, PT0=YT0%MSPD, PT1=YT1%MSPD, PT9=YT9%MSPD, &
     &                                   PDL=YT0%MSPDL, PDM=YT0%MSPDM, PDL9=YT9%MSPDL, PDM9=YT9%MSPDM)
    VARIABLES%SVD = SELF%CREATE_VARIABLE('SVD', GMV%GMV, GMVT1, PT0=YT0%MSVD, PT1=YT1%MSVD, PT9=YT9%MSVD, &
     &                                   PDL=YT0%MSVDL, PDM=YT0%MSVDM, PDL9=YT9%MSVDL, PDM9=YT9%MSVDM)
    VARIABLES%NHX = SELF%CREATE_VARIABLE('NHX', GMV%GMV, GMVT1, PT0=YT0%MNHX, PT1=YT1%MNHX, PT9=YT9%MNHX, &
     &                                   PDL=YT0%MNHXL, PDM=YT0%MNHXM)
    VARIABLES%EDOT = SELF%CREATE_VARIABLE('EDOT', GMV%GMV, GMVT1, PT0=YT0%MEDOT, PT9=YT9%MEDOT)
    VARIABLES%SGRTL = SELF%CREATE_VARIABLE('SGRTL', GMV%GMV, GMVT1, PT0=YT0%MSGRTL, PT9=YT9%MSGRTL)
    VARIABLES%SGRTM = SELF%CREATE_VARIABLE('SGRTM', GMV%GMV, GMVT1, PT0=YT0%MSGRTM, PT9=YT9%MSGRTM)
    END ASSOCIATE

  END SUBROUTINE FIELD_REGISTRY_REGISTER_GMV_FIELDS

  SUBROUTINE FIELD_REGISTRY_REGISTER_GFL_FIELDS(SELF, VARIABLES, GFL_ARRAY, GFL_META)
    ! Utility routine to register GFL fields with the global field registry
    !
    ! Note that this is not meant to stay forever. It is required for gradual
    ! migration of existing arrays to an Atlas-based memory management system.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(FIELD_VARIABLES), POINTER, INTENT(INOUT) :: VARIABLES
    TYPE(TGFL), INTENT(INOUT) :: GFL_ARRAY  ! Actual allcoated arrays
    TYPE(TYPE_GFLD), INTENT(INOUT) :: GFL_META   ! Array of component metadata

    IF (.NOT. ASSOCIATED(VARIABLES)) ALLOCATE(VARIABLES)
#:for v in gfl.variables
#:if v.array == 1
    VARIABLES%${v.name}$_G = SELF%CREATE_VARIABLE('${v.name}$', GFL_META%Y${v.name}$, GFL_ARRAY)
    VARIABLES%${v.name}$ => VARIABLES%${v.name}$_G
#:else
    VARIABLES%${v.name}$ = SELF%CREATE_VARIABLE('${v.name}$', GFL_META%Y${v.name}$, GFL_ARRAY)
#:endif
#:endfor
  END SUBROUTINE FIELD_REGISTRY_REGISTER_GFL_FIELDS

  SUBROUTINE FIELD_REGISTRY_REGISTER_EC_PHYS_FIELDS(SELF, VARIABLES, FIELDS)
    ! Utility routine to register EC physics fields in the current field container
    !
    ! Note that this is not meant to stay forever. It is required for gradual
    ! migration of existing arrays to an Atlas-based memory management system.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(FIELD_VARIABLES), INTENT(INOUT) :: VARIABLES
    TYPE(TEC_PHYS_FIELDS), INTENT(INOUT) :: FIELDS

    VARIABLES%ECPHYS%USTRTI = SELF%CREATE_VARIABLE(NAME='USTRTI', DATA=FIELDS%YRTILEPROP%RUSTRTI) ! E-W  SURFACE STRESS
    VARIABLES%ECPHYS%VSTRTI = SELF%CREATE_VARIABLE(NAME='VSTRTI', DATA=FIELDS%YRTILEPROP%RVSTRTI) ! N-S  SURFACE STRESS
    VARIABLES%ECPHYS%AHFSTI = SELF%CREATE_VARIABLE(NAME='AHFSTI', DATA=FIELDS%YRTILEPROP%RAHFSTI) ! SURFACE SENSIBLE HEAT FLUX
    VARIABLES%ECPHYS%EVAPTI = SELF%CREATE_VARIABLE(NAME='EVAPTI', DATA=FIELDS%YRTILEPROP%REVAPTI) ! EVAPORATION
    VARIABLES%ECPHYS%TSKTI  = SELF%CREATE_VARIABLE(NAME='TSKTI',  DATA=FIELDS%YRTILEPROP%RTSKTI)  ! SKIN TEMPERATURE
  END SUBROUTINE FIELD_REGISTRY_REGISTER_EC_PHYS_FIELDS

  SUBROUTINE FIELD_REGISTRY_REGISTER_PHYSICS_RADIATION_FIELDS(SELF, VARIABLES, PHYS_RADI)
    ! Utility routine to register EC physics fields in the current field container
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(FIELD_VARIABLES), INTENT(INOUT) :: VARIABLES
    TYPE(MODEL_PHYSICS_RADIATION_TYPE), TARGET, INTENT(IN) :: PHYS_RADI

    VARIABLES%RADIATION%EMTD     = SELF%CREATE_VARIABLE(NAME='EMTD', DATA=PHYS_RADI%YRRADF%EMTD)
    VARIABLES%RADIATION%TRSW     = SELF%CREATE_VARIABLE(NAME='TRSW', DATA=PHYS_RADI%YRRADF%TRSW)
    VARIABLES%RADIATION%EMTC     = SELF%CREATE_VARIABLE(NAME='EMTC', DATA=PHYS_RADI%YRRADF%EMTC)
    VARIABLES%RADIATION%TRSC     = SELF%CREATE_VARIABLE(NAME='TRSC', DATA=PHYS_RADI%YRRADF%TRSC)
    VARIABLES%RADIATION%EMTU     = SELF%CREATE_VARIABLE(NAME='EMTU', DATA=PHYS_RADI%YRRADF%EMTU)
    VARIABLES%RADIATION%TAUAER   = SELF%CREATE_VARIABLE(NAME='TAUAER', DATA=PHYS_RADI%YRRADF%TAUAER)
    VARIABLES%RADIATION%SRSWD    = SELF%CREATE_VARIABLE(NAME='SRSWD', DATA=PHYS_RADI%YRRADF%SRSWD)
    VARIABLES%RADIATION%SRLWDC   = SELF%CREATE_VARIABLE(NAME='SRLWDC', DATA=PHYS_RADI%YRRADF%SRLWDC)
    VARIABLES%RADIATION%SRLWD    = SELF%CREATE_VARIABLE(NAME='SRLWD', DATA=PHYS_RADI%YRRADF%SRLWD)
    VARIABLES%RADIATION%SRSWDC   = SELF%CREATE_VARIABLE(NAME='SRSWDC', DATA=PHYS_RADI%YRRADF%SRSWDC)
    VARIABLES%RADIATION%SRSWDCS  = SELF%CREATE_VARIABLE(NAME='SRSWDCS', DATA=PHYS_RADI%YRRADF%SRSWDCS)
    VARIABLES%RADIATION%SRLWDCS  = SELF%CREATE_VARIABLE(NAME='SRLWDCS', DATA=PHYS_RADI%YRRADF%SRLWDCS)
    VARIABLES%RADIATION%SRSWDV   = SELF%CREATE_VARIABLE(NAME='SRSWDV', DATA=PHYS_RADI%YRRADF%SRSWDV)
    VARIABLES%RADIATION%SRSWDUV  = SELF%CREATE_VARIABLE(NAME='SRSWDUV', DATA=PHYS_RADI%YRRADF%SRSWDUV)
    VARIABLES%RADIATION%EDRO     = SELF%CREATE_VARIABLE(NAME='EDRO', DATA=PHYS_RADI%YRRADF%EDRO)
    VARIABLES%RADIATION%SRSWPAR  = SELF%CREATE_VARIABLE(NAME='SRSWPAR', DATA=PHYS_RADI%YRRADF%SRSWPAR)
    VARIABLES%RADIATION%SRSWUVB  = SELF%CREATE_VARIABLE(NAME='SRSWUVB', DATA=PHYS_RADI%YRRADF%SRSWUVB)
    VARIABLES%RADIATION%SRSWPARC = SELF%CREATE_VARIABLE(NAME='SRSWPARC', DATA=PHYS_RADI%YRRADF%SRSWPARC)
    VARIABLES%RADIATION%SRSWTINC = SELF%CREATE_VARIABLE(NAME='SRSWTINC', DATA=PHYS_RADI%YRRADF%SRSWTINC)
    VARIABLES%RADIATION%SRFDIR   = SELF%CREATE_VARIABLE(NAME='SRFDIR', DATA=PHYS_RADI%YRRADF%SRFDIR)
    VARIABLES%RADIATION%SRCDIR   = SELF%CREATE_VARIABLE(NAME='SRCDIR', DATA=PHYS_RADI%YRRADF%SRCDIR)
    VARIABLES%RADIATION%RMOON    = SELF%CREATE_VARIABLE(NAME='RMOON', DATA=PHYS_RADI%YRRADF%RMOON)
    VARIABLES%RADIATION%DERIVATIVELW = SELF%CREATE_VARIABLE(NAME='DERIVATIVELW', DATA=PHYS_RADI%YRRADF%DERIVATIVELW)
  END SUBROUTINE FIELD_REGISTRY_REGISTER_PHYSICS_RADIATION_FIELDS


  !----   Utility wrapper routines for surface variables   ----!

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_2D(SELF, NAME, VARIABLE, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create a single field from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_2D), INTENT(INOUT) :: VARIABLE
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:)
    TYPE(TYPE_SURF_MTL_2D), INTENT(IN) :: META
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT

    IF (.NOT. ACTIVE) THEN
      ! For inactive variables we still create full-sized temporaries,
      ! since the SURF module expects full NPROMA-sized buffers.
      VARIABLE = VARIABLE_2D(NAME, LACTIVE=.FALSE., LT1=.FALSE., LT9=.FALSE.)
      VARIABLE%FT0 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
      VARIABLE%FT1 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
      VARIABLE%FT9 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
    ELSE
      ! Create variable according to existing meta-data
      VARIABLE = VARIABLE_2D(NAME, LACTIVE=META%MP > 0, LT1=META%MP1 > 0, LT9=META%MP9 > 0)

      IF (META%MP > 0) THEN
        VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:), IDX=META%MP)
      ELSE
        VARIABLE%FT0 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
      END IF
      IF (META%MP1 > 0) THEN
        VARIABLE%FT1 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:), IDX=META%MP1)
      ELSE
        VARIABLE%FT1 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
      END IF
      IF (META%MP9 > 0) THEN
        VARIABLE%FT9 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:), IDX=META%MP9)
      ELSE
        VARIABLE%FT9 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
      END IF
    END IF

  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_2D

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_2D(SELF, NAME, VARIABLES, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create an array of fields from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_2D), ALLOCATABLE, INTENT(INOUT) :: VARIABLES(:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:)
    TYPE(TYPE_SURF_MTL_2D), INTENT(IN) :: META(:)
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: I
    CHARACTER(:), ALLOCATABLE :: VNAME

    ALLOCATE(VARIABLES(SIZE(META)))
    DO I=1, SIZE(META)
      VNAME = NAME//"_"//CHAR(I)
      CALL SELF%CREATE_SURFACE_VARIABLE_2D(VNAME, VARIABLES(I), ARRAY, META(I), DESCR, ACTIVE, PERSISTENT)
    END DO
  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_2D

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_2D(SELF, NAME, VARIABLES, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create an array of fields from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_2D), ALLOCATABLE, INTENT(INOUT) :: VARIABLES(:,:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:)
    TYPE(TYPE_SURF_MTL_2D), INTENT(IN) :: META(:,:)
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: I, J
    CHARACTER(:), ALLOCATABLE :: VNAME

    ALLOCATE(VARIABLES(SIZE(META, DIM=1), SIZE(META, DIM=2)))
    DO J=1, SIZE(META, DIM=2)
      DO I=1, SIZE(META, DIM=1)
        VNAME = NAME//"_"//CHAR(I)//"_"//CHAR(J)
        CALL SELF%CREATE_SURFACE_VARIABLE_2D(VNAME, VARIABLES(I,J), ARRAY, META(I,J), DESCR, ACTIVE, PERSISTENT)
      END DO
    END DO
  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_2D

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_3D(SELF, NAME, VARIABLE, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create a single field from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_3D), INTENT(INOUT) :: VARIABLE
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:,:)
    TYPE(TYPE_SURF_MTL_3D), INTENT(IN) :: META
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT

    IF (.NOT. ACTIVE) THEN
      ! For inactive variables we still create full-sized temporaries,
      ! since the SURF module expects full NPROMA-sized buffers.
      VARIABLE = VARIABLE_3D(NAME, LACTIVE=.FALSE., LT1=.FALSE., LT9=.FALSE.)
      VARIABLE%FT0 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
      VARIABLE%FT1 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
      VARIABLE%FT9 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
    ELSE
      ! Create variable according to existing meta-data
      VARIABLE = VARIABLE_3D(NAME, LACTIVE=META%MP > 0, LT1=META%MP1 > 0, LT9=META%MP9 > 0)

      IF (META%MP > 0) THEN
        VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:,:), IDX=META%MP)
      ELSE
        VARIABLE%FT0 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
      END IF
      IF (META%MP1 > 0) THEN
        VARIABLE%FT1 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:,:), IDX=META%MP1)
      ELSE
        VARIABLE%FT1 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
      END IF
      IF (META%MP9 > 0) THEN
        VARIABLE%FT9 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:,:), IDX=META%MP9)
      ELSE
        VARIABLE%FT9 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
      END IF
    END IF

  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_3D

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_3D(SELF, NAME, VARIABLES, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create an array of fields from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_3D), ALLOCATABLE, INTENT(INOUT) :: VARIABLES(:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:,:)
    TYPE(TYPE_SURF_MTL_3D), INTENT(IN) :: META(:)
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: I
    CHARACTER(:), ALLOCATABLE :: VNAME

    ALLOCATE(VARIABLES(SIZE(META)))
    DO I=1, SIZE(META)
      VNAME = NAME//"_"//CHAR(I)
      CALL SELF%CREATE_SURFACE_VARIABLE_3D(VNAME, VARIABLES(I), ARRAY, META(I), DESCR, ACTIVE, PERSISTENT)
    END DO
  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_3D

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_3D(SELF, NAME, VARIABLES, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create an array of fields from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_3D), ALLOCATABLE, INTENT(INOUT) :: VARIABLES(:,:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:,:)
    TYPE(TYPE_SURF_MTL_3D), INTENT(IN) :: META(:,:)
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: I, J
    CHARACTER(:), ALLOCATABLE :: VNAME

    ALLOCATE(VARIABLES(SIZE(META, DIM=1), SIZE(META, DIM=2)))
    DO J=1, SIZE(META, DIM=2)
      DO I=1, SIZE(META, DIM=1)
        VNAME = NAME//"_"//CHAR(I)//"_"//CHAR(J)
        CALL SELF%CREATE_SURFACE_VARIABLE_3D(VNAME, VARIABLES(I,J), ARRAY, META(I,J), DESCR, ACTIVE, PERSISTENT)
      END DO
    END DO
  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_3D

  SUBROUTINE FIELD_REGISTRY_REGISTER_SURFACE_FIELDS(SELF, SURFVARS, YDSURF, PERSISTENT)
    ! Register all surface variables detailed in the configuration file
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(SURFACE_VARIABLES), POINTER, INTENT(INOUT) :: SURFVARS
    TYPE(TSURF), TARGET, INTENT(INOUT) :: YDSURF
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT

    IF (.NOT. ASSOCIATED(SURFVARS)) ALLOCATE(SURFVARS)

#:for group in surface_prognostic
    ASSOCIATE(SP_${group.short}$=>YDSURF%SP_${group.short}$, YSP_${group.short}$=>YDSURF%YSP_${group.short}$, YSP_${group.short}$D=>YDSURF%YSP_${group.short}$D)
#:for v in group.variables
#:if v.array == 1
    IF (ASSOCIATED(YSP_${group.short}$%Y${v.name}$)) THEN
      CALL SELF%CREATE_SURFACE_VARIABLE_ARRAY_${group.dimension}$D(NAME='SP_${group.short}$_${v.name}$', &
       & VARIABLES=SURFVARS%GSP_${group.short}$%V${v.name}$, ARRAY=SP_${group.short}$, &
       & META=YSP_${group.short}$%Y${v.name}$(:), DESCR=YSP_${group.short}$D, &
       & ACTIVE=ASSOCIATED(YSP_${group.short}$%Y${v.name}$))
    END IF
#:elif v.array == 2
    IF (ASSOCIATED(YSP_${group.short}$%Y${v.name}$)) THEN
      CALL SELF%CREATE_SURFACE_VARIABLE_ARRAY_${group.dimension}$D(NAME='SP_${group.short}$_${v.name}$', &
       & VARIABLES=SURFVARS%GSP_${group.short}$%V${v.name}$, ARRAY=SP_${group.short}$, &
       & META=YSP_${group.short}$%Y${v.name}$(:,:), DESCR=YSP_${group.short}$D, &
       & ACTIVE=ASSOCIATED(YSP_${group.short}$%Y${v.name}$))
    END IF
#:else
    CALL SELF%CREATE_SURFACE_VARIABLE_${group.dimension}$D(NAME='SP_${group.short}$_${v.name}$', &
     & VARIABLE=SURFVARS%GSP_${group.short}$%V${v.name}$, ARRAY=SP_${group.short}$, &
     & META=YSP_${group.short}$%Y${v.name}$, DESCR=YSP_${group.short}$D, &
     & ACTIVE=ASSOCIATED(YSP_${group.short}$%Y${v.name}$))
#:endif
#:endfor

    IF (YSP_${group.short}$D%NDIM == 0) THEN
#:if group.dimension == 2
      SURFVARS%GSP_${group.short}$%F_GROUP = CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=1, PERSISTENT=PERSISTENT)
#:elif group.dimension == 3
      SURFVARS%GSP_${group.short}$%F_GROUP = CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=MAX(1,YSP_${group.short}$D%NLEVS), NDIM=1, PERSISTENT=PERSISTENT)
#:endif
    ELSE
      SURFVARS%GSP_${group.short}$%F_GROUP = FIELD_${group.dimension+1}$D(DATA=SP_${group.short}$)
    END IF
    END ASSOCIATE

#:endfor

#:for group in surface_diagnostic
    ASSOCIATE(SD_${group.short}$=>YDSURF%SD_${group.short}$, YSD_${group.short}$=>YDSURF%YSD_${group.short}$, YSD_${group.short}$D=>YDSURF%YSD_${group.short}$D)
#:for v in group.variables
#:if v.array == 1
    IF (ASSOCIATED(YSD_${group.short}$%Y${v.name}$)) THEN
      CALL SELF%CREATE_SURFACE_VARIABLE_ARRAY_${group.dimension}$D(NAME='SD_${group.short}$_${v.name}$', &
       & VARIABLES=SURFVARS%GSD_${group.short}$%V${v.name}$, ARRAY=SD_${group.short}$, &
       & META=YSD_${group.short}$%Y${v.name}$(:), DESCR=YSD_${group.short}$D, &
       & ACTIVE=ASSOCIATED(YSD_${group.short}$%Y${v.name}$))
    END IF
#:elif v.array == 2
    IF (ASSOCIATED(YSD_${group.short}$%Y${v.name}$)) THEN
      CALL SELF%CREATE_SURFACE_VARIABLE_ARRAY2_${group.dimension}$D(NAME='SD_${group.short}$_${v.name}$', &
       & VARIABLES=SURFVARS%GSD_${group.short}$%V${v.name}$, ARRAY=SD_${group.short}$, &
       & META=YSD_${group.short}$%Y${v.name}$(:,:), DESCR=YSD_${group.short}$D, &
       & ACTIVE=ASSOCIATED(YSD_${group.short}$%Y${v.name}$))
    END IF
#:else
    CALL SELF%CREATE_SURFACE_VARIABLE_${group.dimension}$D(NAME='SD_${group.short}$_${v.name}$', &
     & VARIABLE=SURFVARS%GSD_${group.short}$%V${v.name}$, ARRAY=SD_${group.short}$, &
     & META=YSD_${group.short}$%Y${v.name}$, DESCR=YSD_${group.short}$D, &
     & ACTIVE=ASSOCIATED(YSD_${group.short}$%Y${v.name}$))
#:endif
#:endfor

    IF (YSD_${group.short}$D%NDIM == 0) THEN
#:if group.dimension == 2
      SURFVARS%GSD_${group.short}$%F_GROUP = CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=1, PERSISTENT=PERSISTENT)
#:elif group.dimension == 3
      SURFVARS%GSD_${group.short}$%F_GROUP = CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=MAX(1,YSD_${group.short}$D%NLEVS), NDIM=1, PERSISTENT=PERSISTENT)
#:endif
    ELSE
      SURFVARS%GSD_${group.short}$%F_GROUP = FIELD_${group.dimension+1}$D(DATA=SD_${group.short}$)
    END IF
    END ASSOCIATE
#:endfor

  END SUBROUTINE FIELD_REGISTRY_REGISTER_SURFACE_FIELDS

END MODULE FIELD_REGISTRY_MOD
