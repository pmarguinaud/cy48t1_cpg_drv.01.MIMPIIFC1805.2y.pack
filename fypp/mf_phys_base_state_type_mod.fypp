#:set vars_ydvars = ['CVV', 'DIV', 'EFB1', 'EFB2', 'EFB3', 'G', 'H', 'I', 'L', 'O3', 'Q', 'R', 'S', 'SRC', 'T', 'TKE', 'U', 'V', 'VOR']
#:set grp_surf    = { &
& "GSP_SG" : [ 2, ['F', 'A', 'R'],        ], &
& "GSP_RR" : [ 1, ['T', 'FC', 'W', 'IC'], ], &
& "GSP_SB" : [ 2, ['Q', 'TL', 'T'],       ], &
& }

MODULE MF_PHYS_BASE_STATE_TYPE_MOD

USE PARKIND1, ONLY : JPIM, JPRB
USE CPG_TYPE_MOD, ONLY : CPG_DYN_TYPE, CPG_PHY_TYPE
USE FIELD_MODULE
IMPLICIT NONE

#:def gsp_type (name, defs)
TYPE MF_PHYS_STATE_${name}$_TYPE
#:set ndim = defs[0]
#:set vars = defs[1]
#:for var in vars
  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: ${var}$ (${','.join ([':'] * ndim)}$) => NULL ()
#:if ndim == 1
!>REAL (KIND=JPRB)                      :: ${var}$ (NPROMA)
#:else
!>REAL (KIND=JPRB)                      :: ${var}$ (NPROMA, YDCPG_DIM%YRSURF%YSP_${name}$)
#:endif
  TYPE (FIELD_${ndim+1}$D), POINTER :: F_${var}$ => NULL ()
#:endfor
END TYPE MF_PHYS_STATE_${name}$_TYPE
#:enddef

#:for grp in grp_surf
$:gsp_type (grp, grp_surf[grp])

#:endfor

TYPE MF_PHYS_BASE_STATE_TYPE
  TYPE (CPG_DYN_TYPE), POINTER :: YCPG_DYN    => NULL ()
!>TYPE (CPG_DYN_TYPE)          :: YCPG_DYN
  TYPE (CPG_PHY_TYPE), POINTER :: YCPG_PHY    => NULL ()
!>TYPE (CPG_PHY_TYPE)          :: YCPG_PHY    
  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: P1EXT  (:,:,:) => NULL ()
  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: P1CHEM (:,:,:) => NULL ()
  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: P1NOGW (:,:)   => NULL ()
  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: P2NOGW (:,:)   => NULL ()
  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: P1LIMA (:,:,:) => NULL ()
  
#:for var in vars_ydvars
  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: ${var}$ (:,:) => NULL ()
!>REAL (KIND=JPRB)                      :: ${var}$ (NPROMA,1:NLEV)
  TYPE (FIELD_3D), POINTER :: F_${var}$ => NULL ()
#:endfor

#:for grp in grp_surf
  TYPE (MF_PHYS_STATE_${grp}$_TYPE) :: Y${grp}$
#:endfor

CONTAINS

  PROCEDURE :: INIT => MF_PHYS_BASE_STATE_TYPE_INIT
  PROCEDURE :: UPDATE_VIEW => MF_PHYS_BASE_STATE_TYPE_UPDATE_VIEW

END TYPE MF_PHYS_BASE_STATE_TYPE

CONTAINS

#:def associate_t (t)
  SELF%YCPG_DYN => YDCPG_DYN${t}$
  SELF%YCPG_PHY => YDCPG_PHY${t}$

  SELF%P1EXT  => ZP1EXT${t}$
  SELF%P1CHEM => ZP1CHEM${t}$
  SELF%P1NOGW => ZP1NOGW${t}$
  SELF%P2NOGW => ZP2NOGW${t}$
  SELF%P1LIMA => ZP1LIMA${t}$

#:for var in vars_ydvars
  SELF%${var}$ (LBOUND (YDVARS%${var}$%T${t}$,1):, LBOUND (YDVARS%${var}$%T${t}$,2):) => YDVARS%${var}$%T${t}$
  SELF%F_${var}$ => YDVARS%${var}$%FT${t}$
#:endfor

#:for grp in grp_surf
  #:set ndim = grp_surf[grp][0]
  #:for var in grp_surf[grp][1]
  SELF%Y${grp}$%${var}$ ( &
                     &  LBOUND (YDMF_PHYS_SURF%${grp}$%P${var}$_T${t}$, 1):  &
     #:for d in range (2, ndim+1)
                     & ,LBOUND (YDMF_PHYS_SURF%${grp}$%P${var}$_T${t}$, ${d}$):  &
     #:endfor
                     &  ) => YDMF_PHYS_SURF%${grp}$%P${var}$_T${t}$
  SELF%Y${grp}$%F_${var}$ => YDMF_PHYS_SURF%${grp}$%F_${var}$_T${t}$

  #:endfor
#:endfor

#:enddef

SUBROUTINE MF_PHYS_BASE_STATE_TYPE_INIT (SELF, LDT0, YDCPG_DYN0, YDCPG_DYN9, YDCPG_PHY0, YDCPG_PHY9, YDVARS, YDMF_PHYS_SURF, YDMODEL, PGFL)

USE MF_PHYS_SURFACE_TYPE_MOD,ONLY : MF_PHYS_SURF_TYPE
USE FIELD_VARIABLES_MOD, ONLY: FIELD_VARIABLES
USE SC2PRG_MOD         , ONLY : SC2PRG
USE TYPE_MODEL         , ONLY : MODEL

CLASS (MF_PHYS_BASE_STATE_TYPE)              :: SELF
TYPE (MF_PHYS_SURF_TYPE),INTENT(INOUT) :: YDMF_PHYS_SURF
LOGICAL,                INTENT (IN)    :: LDT0
TYPE (CPG_DYN_TYPE),    INTENT (INOUT), TARGET :: YDCPG_DYN0, YDCPG_DYN9
TYPE (CPG_PHY_TYPE),    INTENT (INOUT), TARGET :: YDCPG_PHY0, YDCPG_PHY9
TYPE (FIELD_VARIABLES), INTENT (INOUT) :: YDVARS
TYPE(MODEL),            INTENT (IN)    :: YDMODEL
REAL (KIND=JPRB), TARGET, OPTIONAL :: PGFL (:,:,:)
REAL (KIND=JPRB), TARGET, SAVE :: ZDUM2 (1, 1), ZDUM3 (1, 1, 1)

REAL(KIND=JPRB), POINTER :: ZP1CHEM0(:,:,:), ZP1CHEM9(:,:,:)
REAL(KIND=JPRB), POINTER :: ZP1EXT0(:,:,:), ZP1EXT9(:,:,:)
REAL(KIND=JPRB), POINTER :: ZP1LIMA0(:,:,:), ZP1LIMA9(:,:,:)
REAL(KIND=JPRB), POINTER :: ZP1NOGW0(:,:), ZP1NOGW9(:,:), ZP2NOGW0(:,:), ZP2NOGW9(:,:)


ZP1CHEM0 => ZDUM3
ZP1CHEM9 => ZDUM3
ZP1LIMA0 => ZDUM3
ZP1LIMA9 => ZDUM3
ZP1EXT0  => ZDUM3
ZP1EXT9  => ZDUM3

ZP1NOGW0 => ZDUM2
ZP1NOGW9 => ZDUM2
ZP2NOGW0 => ZDUM2
ZP2NOGW9 => ZDUM2


IF (PRESENT (PGFL)) THEN
  CALL SC2PRG (1, YDMODEL%YRML_GCONF%YGFL%YCHEM(:)%MP , YDMODEL%YRML_GCONF%YGFL%NCHEM,    PGFL, ZP1CHEM0)    !  YDVARS%CHEM(1)%T0
  CALL SC2PRG (1, YDMODEL%YRML_GCONF%YGFL%YCHEM(:)%MP9, YDMODEL%YRML_GCONF%YGFL%NCHEM,    PGFL, ZP1CHEM9)    !  YDVARS%CHEM(1)%T9
  CALL SC2PRG (1, YDMODEL%YRML_GCONF%YGFL%YLIMA(:)%MP , YDMODEL%YRML_GCONF%YGFL%NLIMA,    PGFL, ZP1LIMA0)    !  YDVARS%LIMA(1)%T0
  CALL SC2PRG (1, YDMODEL%YRML_GCONF%YGFL%YLIMA(:)%MP9, YDMODEL%YRML_GCONF%YGFL%NLIMA,    PGFL, ZP1LIMA9)    !  YDVARS%LIMA(1)%T9
  CALL SC2PRG (1, YDMODEL%YRML_GCONF%YGFL%YEXT(:)%MP  , YDMODEL%YRML_GCONF%YGFL%NGFL_EXT, PGFL, ZP1EXT0 )    !  YDVARS%EXT(1)%T0
  CALL SC2PRG (1, YDMODEL%YRML_GCONF%YGFL%YEXT(:)%MP9 , YDMODEL%YRML_GCONF%YGFL%NGFL_EXT, PGFL, ZP1EXT9 )    !  YDVARS%EXT(1)%T9

  CALL SC2PRG (1, YDMODEL%YRML_GCONF%YGFL%YNOGW(:)%MP , PGFL ,ZP1NOGW0)    !  YDVARS%NOGW(1)%T0
  CALL SC2PRG (1, YDMODEL%YRML_GCONF%YGFL%YNOGW(:)%MP9, PGFL ,ZP1NOGW9)    !  YDVARS%NOGW(1)%T9 
  CALL SC2PRG (2, YDMODEL%YRML_GCONF%YGFL%YNOGW(:)%MP , PGFL ,ZP2NOGW0)    !  YDVARS%NOGW(2)%T0
  CALL SC2PRG (2, YDMODEL%YRML_GCONF%YGFL%YNOGW(:)%MP9, PGFL ,ZP2NOGW9)    !  YDVARS%NOGW(2)%T9 
ENDIF


IF (LDT0) THEN
$:associate_t ('0')
ELSE
$:associate_t ('9')
ENDIF

END SUBROUTINE MF_PHYS_BASE_STATE_TYPE_INIT

SUBROUTINE MF_PHYS_BASE_STATE_TYPE_UPDATE_VIEW (SELF, BLOCK_INDEX)
CLASS (MF_PHYS_BASE_STATE_TYPE)              :: SELF
INTEGER(KIND=JPIM), INTENT (IN)   :: BLOCK_INDEX

IF (ASSOCIATED (SELF%YCPG_DYN)) THEN
  CALL SELF%YCPG_DYN%UPDATE_VIEW (BLOCK_INDEX)
ENDIF
IF (ASSOCIATED (SELF%YCPG_PHY)) THEN
  CALL SELF%YCPG_PHY%UPDATE_VIEW (BLOCK_INDEX)
ENDIF

#:for var in vars_ydvars
IF (ASSOCIATED (SELF%F_${var}$)) THEN
  SELF%${var}$ => SELF%F_${var}$%GET_VIEW (BLOCK_INDEX)
ENDIF
#:endfor

#:for grp in grp_surf
  #:set defs = grp_surf[grp]
  #:set ndim = defs[0]
  #:set vars = defs[1]
  #:for var in vars
IF (ASSOCIATED (SELF%Y${grp}$%F_${var}$)) THEN
  SELF%Y${grp}$%${var}$ => SELF%Y${grp}$%F_${var}$%GET_VIEW (BLOCK_INDEX)
ENDIF
  #:endfor
#:endfor

END SUBROUTINE MF_PHYS_BASE_STATE_TYPE_UPDATE_VIEW

END MODULE MF_PHYS_BASE_STATE_TYPE_MOD
