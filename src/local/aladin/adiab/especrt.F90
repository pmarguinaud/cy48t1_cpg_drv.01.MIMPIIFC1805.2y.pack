SUBROUTINE ESPECRT(YDGEOMETRY,YDGFL,YGFL,KDIR,YDSP,LDINCR,YDGFL5,LDBCKGR,PSP7Q,PSP7I,PSP7L, &
     & PGP7Q,PGP7I,PGP7L,PTRAJEC)

!**** *ESPECRT* - Computes spectral coeffs of 'TV' (TV defined as RT/Rd) or
!                spectral coeffs of T from TV and Q

!     Purpose.
!     --------
!           COMPUTES SPECTRAL COEFFICIENTS OF 'TV' (i.e., RT/Rd) or T

!**   Interface.
!     ----------
!        *CALL* *ESPECRT(KDIR)

!        Explicit arguments :
!        --------------------
!        None

!        Implicit arguments :
!        --------------------

!     Method.
!     -------
!        See documentation

!     Externals.
!     ----------

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!       M. Szczech CNRM/GMAP stage (based on SPECRT)
!       Original : 01-03-20

!     Modifications.
!     --------------
!    R. El Khatib : 01-12-06 Cleaning sm variables
!    O.Spaniel    : 03-04-15 cleaning-a same named entity from modules
!    C. Fischer   : 03-03-01 Corrected call to ereespe
!    R. Ajjaji    : 03-05-19 correct OpenMP directives for IBM
!    A. Bogatchev : 03-09-22 Phasing to _CY26_r4, introducing the GFL structure
!    M.Hamrud      01-Oct-2003 CY28 Cleaning
!    Y. Seity     : 04-02-06 new arguments to GPRCP (rain,snow,graupel)
!    A. Bogatchev : 04-10-08 Phasing to CY29
!    A. Bogatchev : 06-02-20 Phasing to CY30R2, revised GPRCP
!    B. Bochenek (Apr 2015): Phasing: move some variables.
!    O. Marsden: June 2015 CY42 YRGMV, YRGFL, YRSURF, YRGMV5, and YRGFL5 are now passed by argument
!    O. Marsden: June 2015 CY42 YRGMV, YRGFL, YRSURF, YRGMV5, and YRGFL5 are now passed by argument
!     ------------------------------------------------------------------

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE YOMGFL   , ONLY : TGFL
USE PARKIND1 , ONLY : JPIM, JPRB
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK

USE YOMSPJB  , ONLY : BACKGROUND
USE ALGORITHM_STATE_MOD  , ONLY : GET_NUPTRA
USE YOMCST   , ONLY : RD
USE YOM_YGFL , ONLY : TYPE_GFLD
USE TRAJECTORY_MOD,ONLY : LTRAJGP
USE YOMLUN   , ONLY : NULOUT
USE YOMTRAJ  , ONLY : TRAJ_TYPE, LPRTTRAJ
USE SPECTRAL_FIELDS_DATA, ONLY: SPECTRAL_FIELD


!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY), INTENT(IN) :: YDGEOMETRY
TYPE(TGFL), INTENT(INOUT) :: YDGFL
TYPE(TYPE_GFLD),INTENT(IN):: YGFL
INTEGER(KIND=JPIM),INTENT(IN)    :: KDIR
TYPE(SPECTRAL_FIELD),   INTENT(INOUT)  :: YDSP
LOGICAL, OPTIONAL ,INTENT(IN)    :: LDINCR
TYPE(TGFL), OPTIONAL, INTENT(INOUT) :: YDGFL5
LOGICAL, OPTIONAL ,INTENT(IN)    :: LDBCKGR
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSP7Q(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSP7I(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSP7L(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PGP7Q(:,:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PGP7I(:,:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PGP7L(:,:,:)
TYPE(TRAJ_TYPE), OPTIONAL, INTENT(IN)  :: PTRAJEC
!     ------------------------------------------------------------------
REAL(KIND=JPRB) :: ZT(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB) :: ZR  (YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB) :: ZGFL7Q(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS), &
 & ZGFL7I(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB) :: ZGFL7L(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
LOGICAL         :: LLINCR,LLBCKGR

INTEGER(KIND=JPIM) :: IEND, IST, JKGLO, JL, JLEV, IBL
REAL(KIND=JPRB) :: ZHOOK_HANDLE

!     ------------------------------------------------------------------

#include "einv_trans.h"
#include "edir_trans.h"

#include "gprcp_pgfl.intfb.h"
#include "gprcp_qlirsg.intfb.h"
#include "abor1.intfb.h"

!     ------------------------------------------------------------------
IF (LHOOK) CALL DR_HOOK('ESPECRT',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP)
ASSOCIATE( &
 & NPROMA=>YDDIM%NPROMA, NGPBLKS=>YDDIM%NGPBLKS, NSPEC2=>YDDIM%NSPEC2, &
 & NRESOL=>YDDIM%NRESOL, NBSETLEV=>YDMP%NBSETLEV, &
 & NGPTOT=>YDGEM%NGPTOT, &
 & NFLEVG=>YDDIMV%NFLEVG)
!     ------------------------------------------------------------------

!*       1.    COMPUTES SPECTRAL COEFFS OF 'TV' OR T
!              -------------------------------------
! If the fields contain increments we use the trajectory q field to
!   calculate the convertion from Tv to T. The YRGFL field contains
!   the humidity increment, so it cannot be used to do the convertion
IF(PRESENT(LDINCR)) THEN
  LLINCR=LDINCR
ELSE
  LLINCR=.FALSE.
ENDIF
IF(LLINCR.AND.(.NOT. PRESENT(PTRAJEC))) THEN
  CALL ABOR1('MISSING TRAJECTORY OF MOISTURE TO CONVERT Tv->T')
ENDIF
IF(LLINCR.AND.(.NOT. PRESENT(YDGFL5))) THEN
  CALL ABOR1('MISSING YDGFL5 OF MOISTURE TO CONVERT Tv->T')
ENDIF
IF(PRESENT(LDBCKGR)) THEN
  LLBCKGR=LDBCKGR
ELSE
  LLBCKGR=.FALSE.
ENDIF
IF (LLINCR) THEN
  IF( LTRAJGP )THEN

!       Retrieve grid-point trajectory. We only need humidity

    IF (.NOT.ALLOCATED(YDGFL5%GFL5))  ALLOCATE (YDGFL5%GFL5(NPROMA,NFLEVG,YGFL%NDIM5,NGPBLKS))
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO,IEND,IBL)
    DO JKGLO=1,NGPTOT,NPROMA
      IEND=MIN(NPROMA,NGPTOT-JKGLO+1)
      IBL=(JKGLO-1)/NPROMA+1
      IF(.NOT.ASSOCIATED(PTRAJEC%MAIN(IBL)%GFL))&
         & CALL ABOR1('READING TRAJEC%MAIN: TRAJEC%MAIN%GFL NOT ALLOCATED')  
      YDGFL5%GFL5(1:IEND,:,1:YGFL%NDIM5,IBL)=PTRAJEC%MAIN(IBL)%GFL(1:IEND,:,1:YGFL%NDIM5)
    ENDDO
!$OMP END PARALLEL DO
    IF (LPRTTRAJ)  WRITE(NULOUT,*)'GREPTRAJ GET_TRAJ_GRID GRID/GFL in ESPECRT'
  ELSE
    IF(.NOT.ALLOCATED(YDGFL5%GFL5)) CALL ABOR1('ESPECRT:GFL5 NOT ALLOCATED')
  ENDIF
ENDIF
CALL GSTATS(25,0)
IF (.NOT. LLBCKGR) THEN
  CALL EINV_TRANS(PSPSCALAR=YDSP%T,KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,PGP=ZT)
  IF (.NOT.LLINCR) THEN
    IF(YGFL%YQ%LSP) THEN
      CALL EINV_TRANS(PSPSCALAR=YDSP%Q,KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,&
       & PGP=YDGFL%GFL(:,:,YGFL%YQ%MP,:))
    ENDIF
    IF(YGFL%YL%LSP) THEN
      CALL EINV_TRANS(PSPSCALAR=YDSP%L,KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,&
       & PGP=YDGFL%GFL(:,:,YGFL%YL%MP,:))
    ENDIF
    IF(YGFL%YI%LSP) THEN
      CALL EINV_TRANS(PSPSCALAR=YDSP%I,KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,&
       & PGP=YDGFL%GFL(:,:,YGFL%YI%MP,:))
    ENDIF
  ENDIF

  CALL GSTATS(1038,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) &
!$OMP&PRIVATE(JKGLO,IST,IEND,JLEV,JL,IBL,ZR)
  DO JKGLO=1,NGPTOT,NPROMA
    IST =1
    IEND=MIN(NPROMA,NGPTOT-JKGLO+1)
    IBL=(JKGLO-1)/NPROMA+1
    IF (.NOT.LLINCR) THEN
      CALL GPRCP_PGFL(NPROMA,IST,IEND,NFLEVG,PGFL=YDGFL%GFL(:,:,:,IBL),PR=ZR)
    ELSE
      CALL GPRCP_QLIRSG(NPROMA,IST,IEND,NFLEVG,PQ=YDGFL5%GFL5(:,:,YGFL%YQ%MP5,IBL),PR=ZR)
    ENDIF

    IF (KDIR == 0) THEN
      DO JLEV=1,NFLEVG
        DO JL=IST,IEND
          ZT(JL,JLEV,IBL)=ZR(JL,JLEV)*ZT(JL,JLEV,IBL)/RD
        ENDDO
      ENDDO
    ELSE
      DO JLEV=1,NFLEVG
        DO JL=IST,IEND
          ZT(JL,JLEV,IBL)=RD*ZT(JL,JLEV,IBL)/ZR(JL,JLEV)
        ENDDO
      ENDDO
    ENDIF
  ENDDO
!$OMP END PARALLEL DO
  CALL GSTATS(1038,1)
  CALL EDIR_TRANS(PSPSCALAR=YDSP%T,KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,PGP=ZT)
ELSE
  CALL EINV_TRANS(PSPSCALAR=BACKGROUND%SPEC(GET_NUPTRA())%T,KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,PGP=ZT)
  IF(PRESENT(PSP7Q).AND.UBOUND(PSP7Q,2)==NSPEC2) THEN
    CALL EINV_TRANS(PSPSCALAR=PSP7Q,KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,&
     & PGP=ZGFL7Q)
    WRITE(NULOUT,*) 'background T-->Tv: Q taken from spectral'
  ELSEIF (PRESENT(PGP7Q).AND.UBOUND(PGP7Q,1)==NPROMA.AND.&
     & UBOUND(PGP7Q,2)==NFLEVG.AND.UBOUND(PGP7Q,3)==NGPBLKS) THEN
    ZGFL7Q(:,:,:)=PGP7Q(:,:,:)
    WRITE(NULOUT,*) 'background T-->Tv: Q taken from gridpoint'
  ELSE
    ZGFL7Q(:,:,:)=0.0_JPRB
    WRITE(NULOUT,*) 'background T-->Tv: Q is assumed to be zero'
  ENDIF
  IF(PRESENT(PSP7L).AND.UBOUND(PSP7L,2)==NSPEC2) THEN
    CALL EINV_TRANS(PSPSCALAR=PSP7L,KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,&
     & PGP=ZGFL7L)
    WRITE(NULOUT,*) 'background T-->Tv: L taken from spectral'
  ELSEIF (PRESENT(PGP7L).AND.UBOUND(PGP7L,1)==NPROMA.AND.&
     & UBOUND(PGP7L,2)==NFLEVG.AND.UBOUND(PGP7L,3)==NGPBLKS) THEN
    ZGFL7L(:,:,:)=PGP7L(:,:,:)
    WRITE(NULOUT,*) 'background T-->Tv: L taken from gridpoint'
  ELSE
    ZGFL7L(:,:,:)=0.0_JPRB
    WRITE(NULOUT,*) 'background T-->Tv: L is assumed to be zero'
  ENDIF
  IF(PRESENT(PSP7I).AND.UBOUND(PSP7I,2)==NSPEC2) THEN
    CALL EINV_TRANS(PSPSCALAR=PSP7I,KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,&
     & PGP=ZGFL7I)
    WRITE(NULOUT,*) 'background T-->Tv: I taken from spectral'
  ELSEIF (PRESENT(PGP7I).AND.UBOUND(PGP7I,1)==NPROMA.AND.&
     & UBOUND(PGP7I,2)==NFLEVG.AND.UBOUND(PGP7I,3)==NGPBLKS) THEN
    ZGFL7I(:,:,:)=PGP7I(:,:,:)
    WRITE(NULOUT,*) 'background T-->Tv: I taken from gridpoint'
  ELSE
    ZGFL7I(:,:,:)=0.0_JPRB
    WRITE(NULOUT,*) 'background T-->Tv: I is assumed to be zero'
  ENDIF
  CALL GSTATS(1038,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) &
!$OMP&PRIVATE(JKGLO,IST,IEND,JLEV,JL,IBL,ZR)
  DO JKGLO=1,NGPTOT,NPROMA
    IST =1
    IEND=MIN(NPROMA,NGPTOT-JKGLO+1)
    IBL=(JKGLO-1)/NPROMA+1
    CALL GPRCP_QLIRSG(NPROMA,IST,IEND,NFLEVG,&
      & PQ=ZGFL7Q(1,1,IBL),PQI=ZGFL7I(1,1,IBL),PQL=ZGFL7L(1,1,IBL),PR=ZR)

    IF (KDIR == 0) THEN
      DO JLEV=1,NFLEVG
        DO JL=IST,IEND
          ZT(JL,JLEV,IBL)=ZR(JL,JLEV)*ZT(JL,JLEV,IBL)/RD
        ENDDO
      ENDDO
    ELSE
      DO JLEV=1,NFLEVG
        DO JL=IST,IEND
          ZT(JL,JLEV,IBL)=RD*ZT(JL,JLEV,IBL)/ZR(JL,JLEV)
        ENDDO
      ENDDO
    ENDIF
  ENDDO
!$OMP END PARALLEL DO
  CALL GSTATS(1038,1)
  CALL EDIR_TRANS(PSPSCALAR=BACKGROUND%SPEC(GET_NUPTRA())%T,KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,PGP=ZT)
ENDIF


CALL GSTATS(25,1)

!     ------------------------------------------------------------------
END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('ESPECRT',1,ZHOOK_HANDLE)
END SUBROUTINE ESPECRT

