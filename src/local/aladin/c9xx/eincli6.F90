SUBROUTINE EINCLI6(YDGEOMETRY,YDGFL,YDSURF,YDEPHY,YDML_PHY_MF)

!**** *EINCLI6*

!     PURPOSE.
!     --------

!     This routine calculates :
!    -climatological sea surface temperature
!    -climatological land surface temperature
!    -climatological mean soil temperature
!    -climatological surface moisture
!    -climatological soil moisture
!    -an empirically estimated equivalent water depth snow climatology

!**   INTERFACE.
!     ----------

!     CALL EINCLI6

!     METHOD.
!     -------

!     EXTERNALS.
!     ----------

!     EGEO923
!     EINTER6
!     EINTER8
!     EINTER10
!     ELECI
!     EBICLI (previously EBIEN)
!     FA-LFI package (FAITOU,LFILAF,FAIRME)
!     CCHIEN
!     ECHK923
!     ACSOLW
!     COORD_DTS
!     PPV923

!     AUTHORS.
!     --------
!      D. GIARD      SEPTEMBER 1997, from INCLI6

!     MODIFICATIONS.
!     --------------
!     D. Giard   01-11-12 : roughness lengths depending on sea-ice limit
!                           use of allocatable arrays to save memory
!     R. ElKhatib 01-12-06 : Cleaning sm variables
!     M. Hamrud  03-10-01 : CY28 Cleaning
!     D. Giard   02-11-29 : case of no water; mask checking depending on resolution
!     D. Giard   04-09-15 : update, bugfix for SST and LSOLV=.F.
!     D. Giard   05-04-07 : no packing for roughness lengths, new EBICLI
!     F. Taillefer 05-12-05 : add PPV923 to take the nearest point of the dataset
!                             grid in case of nature conflict for Ts and Tp (fixed
!                             values for Snow and Water)
!     A.Bogatchev 06-10-13 : replace NCSS with YSP_SBD%NLEVS
!     K. Yessad (Jul 2009): remove CDLOCK + some cleanings
!     O. Marsden: June 2015 CY42 YRGMV, YRGFL, YRSURF, YRGMV5, and YRGFL5 are now passed by argument
!     O. Marsden: June 2015 CY42 YRGMV, YRGFL, YRSURF, YRGMV5, and YRGFL5 are now passed by argument
!     ------------------------------------------------------------------

USE MODEL_PHYSICS_MF_MOD , ONLY : MODEL_PHYSICS_MF_TYPE
USE YOEPHY       , ONLY : TEPHY
USE GEOMETRY_MOD , ONLY : GEOMETRY
USE SURFACE_FIELDS_MIX , ONLY : TSURF
USE PARKIND1  ,ONLY : JPIM, JPRB, JPRD
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK

USE YOMLUN   , ONLY : NULOUT
USE YOMCST   , ONLY : RG       ,RTT
USE YOMSTA   , ONLY : RDTDZ1
USE YOMCLI   , ONLY : YRCLI
USE YOM_YGFL , ONLY : TYPE_GFLD

!     ------------------------------------------------------------------

IMPLICIT NONE

! JPBX/JPBY : number of extra longitudes/latitudes on each side of the data
!          grid required by interpolation (4 or 12 points -> 2/2)
! JPNV : maximum number of climatological soil variables to be derived
! JPNC : maximum number of sea/sea-ice characteristics to be modified
! JPNF : maximum number of fields to write

TYPE(GEOMETRY), INTENT(INOUT) :: YDGEOMETRY
TYPE(TYPE_GFLD)    ,INTENT(INOUT):: YDGFL
TYPE(TSURF), INTENT(INOUT) :: YDSURF
TYPE(TEPHY)    ,INTENT(INOUT) :: YDEPHY
TYPE(MODEL_PHYSICS_MF_TYPE),INTENT(INOUT):: YDML_PHY_MF
INTEGER(KIND=JPIM) :: JPBX,JPBY,JPNV,JPNC,JPNF

PARAMETER(JPBX=2,JPBY=2,JPNV=7,JPNC=4,JPNF=JPNV+JPNC)

!  Initial and interpolated datasets
REAL(KIND=JPRB) ,ALLOCATABLE :: ZLSM(:,:), ZREL(:,:), ZMSK(:,:), ZFLD(:,:)
REAL(KIND=JPRD) ,ALLOCATABLE :: ZAUX1(:), ZAUX2(:)
REAL(KIND=JPRB) ,ALLOCATABLE :: ZLON(:,:), ZLAT(:,:)
!  Interpolated data (C+I)
REAL(KIND=JPRB) :: ZCMP((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1),6)&
 & ,ZXMP((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))&
 & ,ZCMS((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))  
!  Work array
REAL(KIND=JPRB) :: ZXMS((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))
REAL(KIND=JPRB) :: ZLSR((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))
!  ALADIN fields
REAL(KIND=JPRB) :: ZLS((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))&
 & ,ZGO((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))&
 & ,ZTS((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))&
 & ,ZTP((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))&
 & ,ZWS((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))&
 & ,ZWP((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))&
 & ,ZSN((YDGEOMETRY%YRDIM%NDGUXG-YDGEOMETRY%YRDIM%NDGUNG+1)*(YDGEOMETRY%YRDIM%NDLUXG-YDGEOMETRY%YRDIM%NDLUNG+1))  
REAL(KIND=JPRB) ,ALLOCATABLE :: ZIV(:), ZAR(:), ZD2(:) ,ZSA(:)&
 & ,ZAL(:) ,ZEM(:) ,Z0D(:) ,Z0T(:)&
 & ,ZWSA(:) ,ZWFC(:) ,ZWWI(:) ,ZWPX(:) ,ZWSX(:)  
!  Writing array (C+I+E)
REAL(KIND=JPRB) ,ALLOCATABLE :: ZEXT(:,:)
REAL(KIND=JPRB) :: ZEPS, ZGST, ZNEI4, ZNEI5, ZTR
REAL(KIND=JPRB) :: ZHOOK_HANDLE

CHARACTER :: CLNOMC*16,CLNOMF*16,CLFORM*12
CHARACTER :: CLPREF(0:JPNF)*8,CLSUFF(0:JPNF)*12

INTEGER(KIND=JPIM) :: INIVL(0:JPNF),INDMIN(2)
INTEGER(KIND=JPIM) :: I, IARI, IARP, ICO, IDATX, IDATY, IFLD, IINF,&
 & IMER, IMES, IMSKI, IMSKR, INIV, INUM, IOS, IREP,&
 & ITFING, IXFING, IYFING, IZ, J, JC, JJ  

LOGICAL :: LLBIP(0:JPNF),LLWRI(0:JPNF),LLPAC(0:JPNF)
LOGICAL :: LLHMT, LLIMST, LLOP, LLRE, LLSOL, LLSN, LLST, LLTM,&
 & LLTP, LLTS, LLWP, LLWS  

!     ------------------------------------------------------------------

#include "abor1.intfb.h"
#include "acsolw.intfb.h"
#include "cchien.intfb.h"
#include "ebicli.intfb.h"
#include "echk923.intfb.h"
#include "egeo923.intfb.h"
#include "einter6.intfb.h"
#include "einter8.intfb.h"
#include "einter10.intfb.h"
#include "eleci.intfb.h"
#include "ppv923.intfb.h"
#include "coord_dts.intfb.h"

!     ------------------------------------------------------------------
!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('EINCLI6',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV, &
  & YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP, YDPHY1=>YDML_PHY_MF%YRPHY1,YDPHY=>YDML_PHY_MF%YRPHY)
ASSOCIATE(TMERGL=>YDPHY1%TMERGL, &
 & EDELY=>YDGEOMETRY%YREGEO%EDELY, EDELX=>YDGEOMETRY%YREGEO%EDELX, &
 & YSP_SBD=>YDSURF%YSP_SBD, &
 & NDGLG=>YDDIM%NDGLG, NDLUXG=>YDDIM%NDLUXG, NDGUNG=>YDDIM%NDGUNG, &
 & NDGUXG=>YDDIM%NDGUXG, NDLUNG=>YDDIM%NDLUNG, NDLON=>YDDIM%NDLON, &
 & LSOLV=>YDPHY%LSOLV)
!     1. SET INITIAL VALUES.
!        -------------------

!     1.1 Constants

ZEPS=0.1_JPRB * MAX(YRCLI%EDLAT,YRCLI%EDLON)

!  Maximum non-permanent snow value
ZNEI4=1000._JPRB
!  Permanent snow value on ice cap
ZNEI5=10000._JPRB
!  Vertical temperature gradient
ZGST=RDTDZ1/RG
!  Threshold for temperature in presence of snow
ZTR=RTT+YRCLI%RSTR

!     1.2 Interpolation

ICO=YRCLI%NPINT*YRCLI%NPINT
IXFING=NDLUXG-NDLUNG+1
IYFING=NDGUXG-NDGUNG+1
ITFING=IXFING*IYFING
IDATY=YRCLI%NDATY+2*JPBY
IDATX=YRCLI%NDATX+2*JPBX

!     1.3 ALADIN and data files

INUM=3
IMES=1
IARP=31
IREP=0
IARI=0
CLNOMF='Const.Clim'
CLNOMC='Const.Clim.Surfa'
LLIMST=.TRUE.

IINF=-1

IF (YRCLI%LIEEE) THEN
  CLFORM='UNFORMATTED'
ELSE
  CLFORM='FORMATTED'
ENDIF

!     1.4 Geometry : initialize YEMCLI and YOMDIL

CALL EGEO923(YDGEOMETRY%YRGEM)

!     1.5 Arrays for final biperiodization and writing

LLBIP(0)=.FALSE.
LLWRI(0)=.FALSE.
INIVL(0)= 0
DO J=1,JPNV
  LLBIP(J)=.TRUE.
  LLWRI(J)=.TRUE.
  LLPAC(J)=.TRUE.
  INIVL(J)= 1
ENDDO
DO J=JPNV+1,JPNF
  LLBIP(J)=.TRUE.
  LLWRI(J)=.TRUE.
  LLPAC(J)=.TRUE.
  INIVL(J)= 0
ENDDO

!     ------------------------------------------------------------------

!     2. CHECK REQUIRED FIELDS.
!        ----------------------

!     2.1 Check new datasets

!  Land-Sea mask
LLTM=.FALSE.
LLOP=.FALSE.
IOS= 0
INQUIRE(FILE='itm_GL',IOSTAT=IOS,EXIST=LLTM,OPENED=LLOP)
LLTM= LLTM .AND. (IOS == 0) .AND. .NOT.LLOP

!  Orography*g
LLRE=.FALSE.
LLOP=.FALSE.
IOS= 0
INQUIRE(FILE='rel_GL',IOSTAT=IOS,EXIST=LLRE,OPENED=LLOP)
LLRE= LLRE .AND. (IOS == 0) .AND. .NOT.LLOP

!  Sea Surface Temperature
LLST=.FALSE.
LLOP=.FALSE.
IOS= 0
INQUIRE(FILE='sst_GL',IOSTAT=IOS,EXIST=LLST,OPENED=LLOP)
LLST= LLST .AND. (IOS == 0) .AND. .NOT.LLOP

!  Land Surface Temperature
LLTS=.FALSE.
LLOP=.FALSE.
IOS= 0
INQUIRE(FILE='tsl_GL',IOSTAT=IOS,EXIST=LLTS,OPENED=LLOP)
LLTS= LLTS .AND. (IOS == 0) .AND. .NOT.LLOP

!  Mean Land Surface Temperature
LLTP=.FALSE.
LLOP=.FALSE.
IOS= 0
INQUIRE(FILE='tpl_GL',IOSTAT=IOS,EXIST=LLTP,OPENED=LLOP)
LLTP= LLTP .AND. (IOS == 0) .AND. .NOT.LLOP

!  Superficial soil moisture
LLWS=.FALSE.
LLOP=.FALSE.
IOS= 0
INQUIRE(FILE='wsl_GL',IOSTAT=IOS,EXIST=LLWS,OPENED=LLOP)
LLWS= LLWS .AND. (IOS == 0) .AND. .NOT.LLOP

!  Mean soil moisture
LLWP=.FALSE.
LLOP=.FALSE.
IOS= 0
INQUIRE(FILE='wpl_GL',IOSTAT=IOS,EXIST=LLWP,OPENED=LLOP)
LLWP= LLWP .AND. (IOS == 0) .AND. .NOT.LLOP

!  Snow cover
LLSN=.FALSE.
LLOP=.FALSE.
IOS= 0
INQUIRE(FILE='snl_GL',IOSTAT=IOS,EXIST=LLSN,OPENED=LLOP)
LLSN= LLSN .AND. (IOS == 0) .AND. .NOT.LLOP

!     2.2 Control and print

IF (LLST) THEN
  IF (.NOT.LLTM) CALL ABOR1(' EINCLI6 : LAND-SEA MASK MISSING !')
ELSE
  LLTM=.FALSE.
ENDIF
IF (LLTS.OR.LLTP) THEN
  IF (.NOT.LLRE) CALL ABOR1(' EINCLI6 : OROGRAPHY MISSING !')
ELSE
  LLRE=.FALSE.
ENDIF
IF (.NOT.LSOLV) THEN
  WRITE(NULOUT,'('' ONLY SST CAN BE MODIFIED'')')
  LLTS=.FALSE.
  LLTP=.FALSE.
  LLWS=.FALSE.
  LLWP=.FALSE.
  LLSN=.FALSE.
ENDIF
IF (LLTP.AND.YSP_SBD%NLEVS > 1) THEN
  WRITE(NULOUT,'('' SEVERAL TEMP. LAYERS IN SOIL : NOT CODED'')')
  LLTP=.FALSE.
ENDIF
IF (.NOT.(LLST.OR.LLTS.OR.LLTP.OR.LLWS.OR.LLWP.OR.LLSN)) THEN
  WRITE(NULOUT,'('' EINCLI6 : NEW SURFACE FIELDS MISSING !'')')
  IF (LHOOK) CALL DR_HOOK('EINCLI6',1,ZHOOK_HANDLE)
  RETURN
ENDIF
LLSOL=LLTS.OR.LLTP.OR.LLWS.OR.LLWP.OR.LLSN

WRITE(NULOUT,'('' NEW FIELDS TO BE USED BY EINCLI6 :'')')
IF (LLST) WRITE(NULOUT,'('' SEA SURFACE TEMPERATURE'')')
IF (LLTS) WRITE(NULOUT,'('' LAND SURFACE TEMPERATURE'')')
IF (LLTP) WRITE(NULOUT,'('' MEAN LAND SURFACE TEMPERATURE'')')
IF (LLWS) WRITE(NULOUT,'('' (RELATIVE) SURFACE MOISTURE'')')
IF (LLWP) WRITE(NULOUT,'('' (RELATIVE) MEAN SOIL MOISTURE'')')
IF (LLSN) WRITE(NULOUT,'('' SNOW COVER'')')
IF (LLTS.AND..NOT.LLTP)&
 & WRITE(NULOUT,'('' CAUTION : ONLY Ts IS AVAILABLE !'')')  
IF (LLTP.AND..NOT.LLTS)&
 & WRITE(NULOUT,'('' CAUTION : ONLY Tp IS AVAILABLE -> Ts=Tp'')')  
IF (LLWS.AND..NOT.LLWP)&
 & WRITE(NULOUT,'('' CAUTION : ONLY ws IS AVAILABLE !'')')  
IF (LLWP.AND..NOT.LLWS)&
 & WRITE(NULOUT,'('' CAUTION : ONLY wp IS AVAILABLE -> ws=wp'')')  

WRITE(NULOUT,'(A,F6.2,A,F3.2)')' CONTROL FOR SNOW IF Ts,Tp > ',ZTR,' K OR wp <',YRCLI%RSWR  
WRITE(NULOUT,'(A)') '12/4 POINTS INTERPOLATION FOR SST , WITH LAND-SEA MASK' 
WRITE(NULOUT,'(A)') ' 4 POINTS INTERPOLATION FOR LAND VARIABLES WITH THE MASK OF MISSING DATA ' 

!     2.3 Open ALADIN fields

CALL FAITOU(IREP,INUM,.TRUE.,CLNOMF,'OLD',.TRUE.,LLIMST,&
 & IMES,IARP,IARI,CLNOMC)  
CALL CCHIEN(YDGEOMETRY,CLNOMC,INUM,IINF)

!     2.4 Read ALADIN fields - surface constants

INIV=0

!  Land-sea mask
CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'IND.TERREMER',ZLS,NULOUT)
IMER=0
DO J=1,ITFING
  ZLSR(J)=1.0_JPRB-ZLS(J)
  IF (ZLS(J) <= YRCLI%SMASK ) IMER=IMER+1
ENDDO

! Case of no real update
IF (IMER == ITFING) THEN
  WRITE(NULOUT,'(A)')' PURE SEA DOMAIN, CORRECTION OF Ts,Tp,Ws,Wp,Sn USELESS'  
  LLTS=.FALSE.
  LLTP=.FALSE.
  LLWS=.FALSE.
  LLWP=.FALSE.
  LLSN=.FALSE.
ENDIF
IF (IMER == 0) THEN
  WRITE(NULOUT,'(A)')' PURE LAND DOMAIN, CORRECTION OF SST USELESS' 
  LLST=.FALSE.
ENDIF
IF (.NOT.(LLST.OR.LLTS.OR.LLTP.OR.LLWS.OR.LLWP.OR.LLSN)) THEN
  WRITE(NULOUT,'(A)')' EINCLI6 : NO REAL UPDATE OF SURFACE FIELDS !'
  CALL FAIRME(IREP,INUM,'KEEP')
  IF (LHOOK) CALL DR_HOOK('EINCLI6',1,ZHOOK_HANDLE)
  RETURN
ENDIF

!  Orography*g (if required for temperature)
IF (LLRE.OR.LLST) THEN
  CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'GEOPOTENTIEL',ZGO,NULOUT)
ENDIF

!  Land-use type and soil characteristics (for controls on land)
IF (LLSOL) THEN
  ALLOCATE ( ZIV(ITFING) )
  ALLOCATE ( ZAR(ITFING) )
  ALLOCATE ( ZSA(ITFING) )
  ALLOCATE ( ZD2(ITFING) )
  CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'IND.VEG.DOMI',ZIV,NULOUT)
  CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'PROP.ARGILE ',ZAR,NULOUT)
  CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'PROP.SABLE  ',ZSA,NULOUT)
  CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'EPAIS.SOL   ',ZD2,NULOUT)
ENDIF

!  Albedo, emissivity, roughness (to be modified according to SST)
IF (LLST.AND.LSOLV) THEN
  ALLOCATE ( ZAL(ITFING) )
  ALLOCATE ( ZEM(ITFING) )
  ALLOCATE ( Z0D(ITFING) )
  ALLOCATE ( Z0T(ITFING) )
  CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'ALBEDO      ',ZAL,NULOUT)
  CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'EMISSIVITE  ',ZEM,NULOUT)
  CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'Z0.FOIS.G   ',Z0D,NULOUT)
  CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'GZ0.THERM   ',Z0T,NULOUT)
ENDIF

!     2.5 Read ALADIN fields - climatology

INIV=1
CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'TEMPERATURE ',ZTS,NULOUT)
CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'PROF',INIV,'TEMPERATURE ',ZTP,NULOUT)
CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'PROP.RMAX.EA',ZWS,NULOUT)
CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'PROF',INIV,'PROP.RMAX.EA',ZWP,NULOUT)
CALL ELECI(YDGEOMETRY%YRDIM,IREP,INUM,'SURF',INIV,'RESERV.NEIGE',ZSN,NULOUT)

!     2.6 Calculate latitudes and longitudes of the initial grid

ALLOCATE(ZLON(YRCLI%NDATX,YRCLI%NDATY))
ALLOCATE(ZLAT(YRCLI%NDATX,YRCLI%NDATY))
CALL COORD_DTS(YRCLI%NDATX,YRCLI%NDATY,ZLON,ZLAT)

!     ------------------------------------------------------------------

!     3. READ AND INTERPOLATE NEW FIELDS.
!        --------------------------------

!     3.1 Land Sea Mask and Sea Surface Temperature

310 CONTINUE
IF (.NOT.LLST) GO TO 320

ALLOCATE ( ZLSM(IDATX,IDATY) )
ALLOCATE ( ZFLD(IDATX,IDATY) )
IF (YRCLI%LIEEE) THEN
  ALLOCATE ( ZAUX1(YRCLI%NDATX*YRCLI%NDATY) )
  ALLOCATE ( ZAUX2(YRCLI%NDATX*YRCLI%NDATY) )
ENDIF

!  Read
OPEN(UNIT=11,FILE='itm_GL',FORM=CLFORM)
OPEN(UNIT=13,FILE='sst_GL',FORM=CLFORM)
IF (YRCLI%LIEEE) THEN
  READ(11) ZAUX1
  READ(13) ZAUX2
  DO JJ=YRCLI%NDATY+JPBY,1+JPBY,-1
    DO J=1+JPBX,YRCLI%NDATX+JPBX
      IZ=J-JPBX+(YRCLI%NDATY+JPBY-JJ)*YRCLI%NDATX
      ZLSM(J,JJ)= ZAUX1(IZ)
      ZFLD(J,JJ)= ZAUX2(IZ)
    ENDDO
  ENDDO
ELSE
  READ(11,*)((ZLSM(J,JJ),J=1+JPBX,YRCLI%NDATX+JPBX),JJ=YRCLI%NDATY+JPBY,1+JPBY,-1)
  READ(13,*)((ZFLD(J,JJ),J=1+JPBX,YRCLI%NDATX+JPBX),JJ=YRCLI%NDATY+JPBY,1+JPBY,-1)
ENDIF
CLOSE(11)
CLOSE(13)

!  Interpolate temperature with land-sea mask (12/4 points)
CALL EINTER6(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,1),&
 & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT,&
 & ZLSM,ZLS(1),YRCLI%SMASK)  

DEALLOCATE(ZFLD)
DEALLOCATE(ZLSM)
IF (YRCLI%LIEEE) THEN
  DEALLOCATE(ZAUX1)
  DEALLOCATE(ZAUX2)
ENDIF

!  Move to model height
DO J=1,ITFING
  ZCMP(J,1)= ZCMP(J,1)+ZGST*ZGO(J)
ENDDO

!     3.2 g*Orography

320 CONTINUE
IF (.NOT.LLRE) GO TO 330

ALLOCATE ( ZREL(IDATX,IDATY) )
IF (YRCLI%LIEEE) THEN
  ALLOCATE( ZAUX1(YRCLI%NDATX*YRCLI%NDATY) )
ENDIF

!  Read
OPEN(UNIT=12,FILE='rel_GL',FORM=CLFORM)
IF (YRCLI%LIEEE) THEN
  READ(12) ZAUX1
  DO JJ=YRCLI%NDATY+JPBY,1+JPBY,-1
    DO J=1+JPBX,YRCLI%NDATX+JPBX
      IZ=J-JPBX+(YRCLI%NDATY+JPBY-JJ)*YRCLI%NDATX
      ZREL(J,JJ)= ZAUX1(IZ)
    ENDDO
  ENDDO
ELSE
  READ(12,*)((ZREL(J,JJ),J=1+JPBX,YRCLI%NDATX+JPBX),JJ=YRCLI%NDATY+JPBY,1+JPBY,-1)
ENDIF
CLOSE(12)
IF (YRCLI%LIEEE) THEN
  DEALLOCATE(ZAUX1)
ENDIF

!     3.3 Land Surface Temperature

330 CONTINUE
IF (.NOT.LLTS) GO TO 340

ALLOCATE ( ZFLD(IDATX,IDATY) )
ALLOCATE ( ZMSK(IDATX,IDATY) )
IF (YRCLI%LIEEE) THEN
  ALLOCATE ( ZAUX1(YRCLI%NDATX*YRCLI%NDATY) )
ENDIF

!  Read
OPEN(UNIT=14,FILE='tsl_GL',FORM=CLFORM)
IF (YRCLI%LIEEE) THEN
  READ(14) ZAUX1
  DO JJ=YRCLI%NDATY+JPBY,1+JPBY,-1
    DO J=1+JPBX,YRCLI%NDATX+JPBX
      IZ=J-JPBX+(YRCLI%NDATY+JPBY-JJ)*YRCLI%NDATX
      ZFLD(J,JJ)= ZAUX1(IZ)
    ENDDO
  ENDDO
ELSE
  READ(14,*)((ZFLD(J,JJ),J=1+JPBX,YRCLI%NDATX+JPBX),JJ=YRCLI%NDATY+JPBY,1+JPBY,-1)
ENDIF
CLOSE(14)
IF (YRCLI%LIEEE) THEN
  DEALLOCATE(ZAUX1)
ENDIF

!  Define mask then reduce to sea level before interpolation
DO JJ=JPBY+1,JPBY+YRCLI%NDATY
  DO J=JPBX+1,JPBX+YRCLI%NDATX
    IF (ZFLD(J,JJ) <= YRCLI%SMANQ) THEN
      ZMSK(J,JJ)= 1.0_JPRB
    ELSE
      ZMSK(J,JJ)= 0.0_JPRB
      ZFLD(J,JJ)= ZFLD(J,JJ)-ZGST*ZREL(J,JJ)
    ENDIF
  ENDDO
ENDDO

!  Interpolate mask
CALL EINTER8(YDGEOMETRY%YREGEO,ZMSK,IDATY,IDATX,1,ZXMP,&
 & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT)  

!  Intersection between mask and domain
IMSKR=0
IMSKI=0
DO J=1,ITFING
  IF (ZXMP(J) > ZEPS) IMSKR=IMSKR+1
  IF (ZXMP(J) > 1.0_JPRB-ZEPS) IMSKI=IMSKI+1
ENDDO

!  No mask over the ALADIN domain : interpolation of data without mask
IF (IMSKR == 0) THEN
  WRITE(NULOUT,'(A)')' NO EFFECTIVE MASK FOR Ts'
  CALL EINTER8(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,2),&
   & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT)  

!  No available data over the ALADIN domain
ELSEIF (IMSKI == ITFING) THEN
  WRITE(NULOUT,'(A)')' Ts : NO AVAILABLE DATA FOR THIS AREA !'
  LLTS=.FALSE.

!  Standard case : interpolation of data with a mask (4 points)
ELSE
  CALL EINTER10(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,2),ZCMS,&
   & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT,&
   & ZMSK,ZXMP,ZLSR,ZXMS,YRCLI%SMASK)  
  DO J=1,ITFING
    IF (ZLS(J) > YRCLI%SMASK) THEN
      IF (ZCMP(J,2) <= YRCLI%SMANQ) THEN
        CALL PPV923(YDGEOMETRY,J,YRCLI%NDATX,YRCLI%NDATY,INDMIN,&
                  & ZMSK(1+JPBX:YRCLI%NDATX+JPBX,1+JPBY:YRCLI%NDATY+JPBY),&
                  & ZLON,ZLAT)
        ZCMP(J,2)=ZFLD(INDMIN(1)+JPBX,INDMIN(2)+JPBY)
      ENDIF
    ENDIF
  ENDDO
ENDIF

DEALLOCATE(ZFLD)
DEALLOCATE(ZMSK)

!  Move to model height
IF (LLTS) THEN
  DO J=1,ITFING
    ZCMP(J,2)=ZCMP(J,2)+ZGST*ZGO(J)
  ENDDO
ENDIF

!     3.4 Mean Soil Temperature

340 CONTINUE
IF (.NOT.LLTP) GO TO 350

ALLOCATE ( ZFLD(IDATX,IDATY) )
ALLOCATE ( ZMSK(IDATX,IDATY) )
IF (YRCLI%LIEEE) THEN
  ALLOCATE ( ZAUX1(YRCLI%NDATX*YRCLI%NDATY) )
ENDIF

!  Read
OPEN(UNIT=15,FILE='tpl_GL',FORM=CLFORM)
IF (YRCLI%LIEEE) THEN
  READ(15) ZAUX1
  DO JJ=YRCLI%NDATY+JPBY,1+JPBY,-1
    DO J=1+JPBX,YRCLI%NDATX+JPBX
      IZ=J-JPBX+(YRCLI%NDATY+JPBY-JJ)*YRCLI%NDATX
      ZFLD(J,JJ)= ZAUX1(IZ)
    ENDDO
  ENDDO
ELSE
  READ(15,*)((ZFLD(J,JJ),J=1+JPBX,YRCLI%NDATX+JPBX),JJ=YRCLI%NDATY+JPBY,1+JPBY,-1)
ENDIF
CLOSE(15)
IF (YRCLI%LIEEE) THEN
  DEALLOCATE(ZAUX1)
ENDIF

!  Define mask then reduce to sea level before interpolation
DO JJ=JPBY+1,JPBY+YRCLI%NDATY
  DO J=JPBX+1,JPBX+YRCLI%NDATX
    IF (ZFLD(J,JJ) <= YRCLI%SMANQ) THEN
      ZMSK(J,JJ)= 1.0_JPRB
    ELSE
      ZMSK(J,JJ)= 0.0_JPRB
      ZFLD(J,JJ)= ZFLD(J,JJ) - ZGST*ZREL(J,JJ)
    ENDIF
  ENDDO
ENDDO

!  Interpolate mask
CALL EINTER8(YDGEOMETRY%YREGEO,ZMSK,IDATY,IDATX,1,ZXMP,&
 & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT)  

!  Intersection between mask and domain
IMSKR=0
IMSKI=0
DO J=1,ITFING
  IF (ZXMP(J) > ZEPS) IMSKR=IMSKR+1
  IF (ZXMP(J) > 1.0_JPRB-ZEPS) IMSKI=IMSKI+1
ENDDO

!  No mask over the ALADIN domain : interpolation of data without mask

IF (IMSKR == 0) THEN
  WRITE(NULOUT,'('' NO EFFECTIVE MASK FOR Tp'')')
  CALL EINTER8(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,3),&
   & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT)  

!  No available data over the ALADIN domain
ELSEIF (IMSKI == ITFING) THEN
  WRITE(NULOUT,'('' Tp : NO AVAILABLE DATA FOR THIS AREA !'')')
  LLTP=.FALSE.

!  Standard case : interpolation of data with a mask (4 points)
ELSE
  CALL EINTER10(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,3),ZCMS,&
   & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT,&
   & ZMSK,ZXMP,ZLSR,ZXMS,YRCLI%SMASK)  
  DO J=1,ITFING
    IF (ZLS(J) > YRCLI%SMASK) THEN
      IF (ZCMP(J,3) <= YRCLI%SMANQ) THEN
        CALL PPV923(YDGEOMETRY,J,YRCLI%NDATX,YRCLI%NDATY,INDMIN,&
                  & ZMSK(1+JPBX:YRCLI%NDATX+JPBX,1+JPBY:YRCLI%NDATY+JPBY),&
                  & ZLON,ZLAT)
        ZCMP(J,3)=ZFLD(INDMIN(1)+JPBX,INDMIN(2)+JPBY)
      ENDIF
    ENDIF
  ENDDO
ENDIF

DEALLOCATE(ZFLD)
DEALLOCATE(ZMSK)
DEALLOCATE(ZLON)
DEALLOCATE(ZLAT)

!  Move to model height
IF (LLTP) THEN
  DO J=1,ITFING
    ZCMP(J,3)=ZCMP(J,3)+ZGST*ZGO(J)
  ENDDO
ENDIF

!     3.5 Surface moisture

350 CONTINUE
IF (LLRE) DEALLOCATE(ZREL)
IF (.NOT.LLWS) GO TO 360

ALLOCATE ( ZFLD(IDATX,IDATY) )
ALLOCATE ( ZMSK(IDATX,IDATY) )
IF (YRCLI%LIEEE) THEN
  ALLOCATE ( ZAUX1(YRCLI%NDATX*YRCLI%NDATY) )
ENDIF

!  Read
OPEN(UNIT=16,FILE='wsl_GL',FORM=CLFORM)
IF (YRCLI%LIEEE) THEN
  READ(16) ZAUX1
  DO JJ=YRCLI%NDATY+JPBY,1+JPBY,-1
    DO J=1+JPBX,YRCLI%NDATX+JPBX
      IZ=J-JPBX+(YRCLI%NDATY+JPBY-JJ)*YRCLI%NDATX
      ZFLD(J,JJ)= ZAUX1(IZ)
    ENDDO
  ENDDO
ELSE
  READ(16,*)((ZFLD(J,JJ),J=1+JPBX,YRCLI%NDATX+JPBX),JJ=YRCLI%NDATY+JPBY,1+JPBY,-1)
ENDIF
CLOSE(16)
IF (YRCLI%LIEEE) THEN
  DEALLOCATE(ZAUX1)
ENDIF

!  Define mask
DO JJ=JPBY+1,JPBY+YRCLI%NDATY
  DO J=JPBX+1,JPBX+YRCLI%NDATX
    IF (ZFLD(J,JJ) <= YRCLI%SMANQ) THEN
      ZMSK(J,JJ)= 1.0_JPRB
    ELSE
      ZMSK(J,JJ)= 0.0_JPRB
    ENDIF
  ENDDO
ENDDO

!  Interpolate mask
CALL EINTER8(YDGEOMETRY%YREGEO,ZMSK,IDATY,IDATX,1,ZXMP,&
 & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT)  

!  Intersection between mask and domain
IMSKR=0
IMSKI=0
DO J=1,ITFING
  IF (ZXMP(J) > ZEPS) IMSKR=IMSKR+1
  IF (ZXMP(J) > 1.0_JPRB-ZEPS) IMSKI=IMSKI+1
ENDDO

!  No mask over the ALADIN domain : interpolation of data without mask
IF (IMSKR == 0) THEN
  WRITE(NULOUT,'(A)')' NO EFFECTIVE MASK FOR ws'
  CALL EINTER8(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,4),&
   & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT)  

!  No available data over the ALADIN domain
ELSEIF (IMSKI == ITFING) THEN
  WRITE(NULOUT,'(A)')' ws : NO AVAILABLE DATA FOR THIS AREA !'
  LLWS=.FALSE.

!  Standard case : interpolation of data with a mask (4 points)
ELSE
  CALL EINTER10(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,4),ZCMS,&
   & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT,&
   & ZMSK,ZXMP,ZLSR,ZXMS,YRCLI%SMASK)  
  DO J=1,ITFING
    IF (ZLS(J) > YRCLI%SMASK) THEN
!      IF (ZCMP(J,4) <= SMANQ) ZCMP(J,4)= ZCMS(J)
      IF (ZCMP(J,4) <= YRCLI%SMANQ) ZCMP(J,4)= 0.5_JPRB
    ENDIF
  ENDDO
ENDIF

DEALLOCATE(ZFLD)
DEALLOCATE(ZMSK)

!     3.6 Soil moisture

360 CONTINUE
IF (.NOT.LLWP) GO TO 370

ALLOCATE ( ZFLD(IDATX,IDATY) )
ALLOCATE ( ZMSK(IDATX,IDATY) )
IF (YRCLI%LIEEE) THEN
  ALLOCATE ( ZAUX1(YRCLI%NDATX*YRCLI%NDATY) )
ENDIF

!  Read
OPEN(UNIT=17,FILE='wpl_GL',FORM=CLFORM)
IF (YRCLI%LIEEE) THEN
  READ(17) ZAUX1
  DO JJ=YRCLI%NDATY+JPBY,1+JPBY,-1
    DO J=1+JPBX,YRCLI%NDATX+JPBX
      IZ=J-JPBX+(YRCLI%NDATY+JPBY-JJ)*YRCLI%NDATX
      ZFLD(J,JJ)= ZAUX1(IZ)
    ENDDO
  ENDDO
ELSE
  READ(17,*)((ZFLD(J,JJ),J=1+JPBX,YRCLI%NDATX+JPBX),JJ=YRCLI%NDATY+JPBY,1+JPBY,-1)
ENDIF
CLOSE(17)
IF (YRCLI%LIEEE) THEN
  DEALLOCATE(ZAUX1)
ENDIF

!  Define mask
DO JJ=JPBY+1,JPBY+YRCLI%NDATY
  DO J=JPBX+1,JPBX+YRCLI%NDATX
    IF (ZFLD(J,JJ) <= YRCLI%SMANQ) THEN
      ZMSK(J,JJ)= 1.0_JPRB
    ELSE
      ZMSK(J,JJ)= 0.0_JPRB
    ENDIF
  ENDDO
ENDDO

!  Interpolate mask
CALL EINTER8(YDGEOMETRY%YREGEO,ZMSK,IDATY,IDATX,1,ZXMP,&
 & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT)  

!  Intersection between mask and domain
IMSKR=0
IMSKI=0
DO J=1,ITFING
  IF (ZXMP(J) > ZEPS) IMSKR=IMSKR+1
  IF (ZXMP(J) > 1.0_JPRB-ZEPS) IMSKI=IMSKI+1
ENDDO

!  No mask over the ALADIN domain : interpolation of data without mask
IF (IMSKR == 0) THEN
  WRITE(NULOUT,'('' NO EFFECTIVE MASK FOR wp'')')
  CALL EINTER8(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,5),&
   & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT)  

!  No available data over the ALADIN domain
ELSEIF (IMSKI == ITFING) THEN
  WRITE(NULOUT,'('' wp : NO AVAILABLE DATA FOR THIS AREA !'')')
  LLWP=.FALSE.

!  Standard case : interpolation of data with a mask (4 points)
ELSE
  CALL EINTER10(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,5),ZCMS,&
   & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT,&
   & ZMSK,ZXMP,ZLSR,ZXMS,YRCLI%SMASK)  
  DO J=1,ITFING
    IF (ZLS(J) > YRCLI%SMASK) THEN
!      IF (ZCMP(J,5) <= SMANQ) ZCMP(J,5)= ZCMS(J)
      IF (ZCMP(J,5) <= YRCLI%SMANQ) ZCMP(J,5)= 0.5_JPRB
    ENDIF
  ENDDO
ENDIF

DEALLOCATE(ZFLD)
DEALLOCATE(ZMSK)

!     3.7 Snow cover

370 CONTINUE
IF (.NOT.LLSN) GO TO 400

ALLOCATE ( ZFLD(IDATX,IDATY) )
ALLOCATE ( ZMSK(IDATX,IDATY) )
IF (YRCLI%LIEEE) THEN
  ALLOCATE ( ZAUX1(YRCLI%NDATX*YRCLI%NDATY) )
ENDIF

!  Read
OPEN(UNIT=18,FILE='snl_GL',FORM=CLFORM)
IF (YRCLI%LIEEE) THEN
  READ(18) ZAUX1
  DO JJ=YRCLI%NDATY+JPBY,1+JPBY,-1
    DO J=1+JPBX,YRCLI%NDATX+JPBX
      IZ=J-JPBX+(YRCLI%NDATY+JPBY-JJ)*YRCLI%NDATX
      ZFLD(J,JJ)= ZAUX1(IZ)
    ENDDO
  ENDDO
ELSE
  READ(18,*)((ZFLD(J,JJ),J=1+JPBX,YRCLI%NDATX+JPBX),JJ=YRCLI%NDATY+JPBY,1+JPBY,-1)
ENDIF
CLOSE(18)
IF (YRCLI%LIEEE) THEN
  DEALLOCATE(ZAUX1)
ENDIF

!  Define mask
DO JJ=JPBY+1,JPBY+YRCLI%NDATY
  DO J=JPBX+1,JPBX+YRCLI%NDATX
    IF (ZFLD(J,JJ) <= YRCLI%SMANQ) THEN
      ZMSK(J,JJ)= 1.0_JPRB
    ELSE
      ZMSK(J,JJ)= 0.0_JPRB
    ENDIF
  ENDDO
ENDDO

!  Interpolate mask
CALL EINTER8(YDGEOMETRY%YREGEO,ZMSK,IDATY,IDATX,1,ZXMP,&
 & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT)  

!  Intersection between mask and domain
IMSKR=0
IMSKI=0
DO J=1,ITFING
  IF (ZXMP(J) > ZEPS) IMSKR=IMSKR+1
  IF (ZXMP(J) > 1.0_JPRB-ZEPS) IMSKI=IMSKI+1
ENDDO

!  No mask over the ALADIN domain : interpolation of data without mask
IF (IMSKR == 0) THEN
  WRITE(NULOUT,'(A)')' NO EFFECTIVE MASK FOR Sn'
  CALL EINTER8(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,6),&
   & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT)  

!  No available data over the ALADIN domain
ELSEIF (IMSKI == ITFING) THEN
  WRITE(NULOUT,'(A)')' Sn : NO AVAILABLE DATA FOR THIS AREA !'
  LLSN=.FALSE.

!  Standard case : interpolation of data with a mask (4 points)
ELSE
  CALL EINTER10(YDGEOMETRY%YREGEO,ZFLD,IDATY,IDATX,1,ZCMP(1,6),ZCMS,&
   & IYFING,IXFING,ITFING,EDELX,EDELY,YRCLI%NPINT,ICO,NULOUT,&
   & ZMSK,ZXMP,ZLSR,ZXMS,YRCLI%SMASK)  
  DO J=1,ITFING
    IF (ZLS(J) > YRCLI%SMASK) THEN
!      IF (ZCMP(J,6) <= SMANQ) ZCMP(J,6)= ZCMS(J)
      IF (ZCMP(J,6) <= YRCLI%SMANQ) ZCMP(J,6)= 0.0_JPRB
    ENDIF
  ENDDO
ENDIF

DEALLOCATE(ZFLD)
DEALLOCATE(ZMSK)

!     ------------------------------------------------------------------

!     4. MODIFY INITIAL FIELDS.
!        ----------------------

400 CONTINUE

!     4.1 Modifications on sea

IF (LLST) THEN
! New scheme
  IF (LSOLV) THEN
    DO J=1,ITFING
      IF (ZLS(J) <= YRCLI%SMASK) THEN
        ZTS(J)=MAX(0.0_JPRB,ZCMP(J,1))
        ZTP(J)=MAX(0.0_JPRB,ZCMP(J,1))
        IF (ZCMP(J,1) <= TMERGL) THEN
          ZAL(J)= YRCLI%SALBB
          ZEM(J)= YRCLI%SEMIB
          Z0D(J)= YRCLI%SZZ0B*RG
          Z0T(J)= YRCLI%SZZ0B*RG
        ELSE
          ZAL(J)= YRCLI%SALBM
          ZEM(J)= YRCLI%SEMIM
          Z0D(J)= YRCLI%SZZ0M*RG
          Z0T(J)= YRCLI%SZZ0M*RG
        ENDIF
      ENDIF
    ENDDO
! Old scheme
  ELSE
    DO J=1,ITFING
      IF (ZLS(J) <= YRCLI%SMASK) THEN
        ZTS(J)=MAX(0.0_JPRB,ZCMP(J,1))
        ZTP(J)=MAX(0.0_JPRB,ZCMP(J,1))
      ENDIF
    ENDDO
  ENDIF
ENDIF

!     4.2 Modifications on land

IF (LLSOL) THEN
  ALLOCATE ( ZWSA(ITFING) )
  ALLOCATE ( ZWFC(ITFING) )
  ALLOCATE ( ZWWI(ITFING) )
  ALLOCATE ( ZWPX(ITFING) )
  ALLOCATE ( ZWSX(ITFING) )
  LLHMT=.FALSE.
  CALL ACSOLW(YDPHY1,1,ITFING,ITFING,ZAR,ZD2,ZLS,ZIV,ZSA,&
   & LLHMT,ZWFC,ZWPX,ZWSA,ZWSX,ZWWI)

  DO J=1,ITFING
    IF (ZLS(J) > YRCLI%SMASK) THEN
!  Read new fields
      IF (LLTS) ZTS(J)=MAX(0.0_JPRB,ZCMP(J,2))
      IF (LLTP) ZTP(J)=MAX(0.0_JPRB,ZCMP(J,3))
      IF (LLWS) ZWS(J)=MIN(1.0_JPRB,MAX(0.0_JPRB,ZCMP(J,4)))
      IF (LLWP) ZWP(J)=MIN(1.0_JPRB,MAX(0.0_JPRB,ZCMP(J,5)))
      IF (LLSN) ZSN(J)=MAX(0.0_JPRB,ZCMP(J,6))
!  No superficial fields available
      IF (LLTP.AND..NOT.LLTS) ZTS(J)=ZTP(J)
      IF (LLWP.AND..NOT.LLWS) ZWS(J)=ZWP(J)
!  Control of snow against temperature and moisture
      IF ((ZTS(J) > ZTR).AND.LLTS) ZSN(J)=0.0_JPRB
      IF ((ZTP(J) > ZTR).AND.LLTP) ZSN(J)=0.0_JPRB
      IF ((ZWP(J) < YRCLI%RSWR).AND.LLWP) ZSN(J)=0.0_JPRB
!  Control of soil moisture
      ZWS(J)=MIN(ZWS(J),ZWFC(J)/ZWSA(J))
      ZWP(J)=MIN(ZWP(J),ZWFC(J)/ZWSA(J))
!  Control for ice cap
      IF (NINT(ZIV(J)) == YRCLI%NTPGLA) THEN
        ZWS(J)= 1.0_JPRB
        ZWP(J)= 1.0_JPRB
        ZSN(J)= ZNEI5
      ELSE
        ZSN(J)= MIN(ZSN(J),ZNEI4)
      ENDIF
    ENDIF
  ENDDO

  DEALLOCATE(ZWSA)
  DEALLOCATE(ZWFC)
  DEALLOCATE(ZWWI)
  DEALLOCATE(ZWPX)
  DEALLOCATE(ZWSX)
  DEALLOCATE(ZIV)
  DEALLOCATE(ZAR)
  DEALLOCATE(ZSA)
  DEALLOCATE(ZD2)
ENDIF

!     ------------------------------------------------------------------

!     5. WRITE.
!        ------

!     5.1 Setup

! Writing array
ALLOCATE ( ZEXT(NDLON*NDGLG,0:JPNF) )
DO JC=0,JPNF
  DO J=1,NDGLG*NDLON
    ZEXT(J,JC)= 0.0_JPRB
  ENDDO
ENDDO

! Land-sea mask
CLPREF(0)= 'SURF'
CLSUFF(0)= 'IND.TERREMER'
ZEXT(1:ITFING,0)= ZLS(1:ITFING)

! Climatological surface fields
CLPREF(1)= 'SURF'
CLPREF(2)= 'PROF'
CLPREF(3)= 'SURF'
CLPREF(4)= 'PROF'
CLPREF(5)= 'SURF'
CLSUFF(1)= 'TEMPERATURE '
CLSUFF(2)= 'TEMPERATURE '
CLSUFF(3)= 'PROP.RMAX.EA'
CLSUFF(4)= 'PROP.RMAX.EA'
CLSUFF(5)= 'RESERV.NEIGE'
DO J=1,ITFING
  ZEXT(J,1)= ZTS(J)
  ZEXT(J,2)= ZTP(J)
  ZEXT(J,3)= ZWS(J)
  ZEXT(J,4)= ZWP(J)
  ZEXT(J,5)= ZSN(J)
ENDDO
IFLD=5
I=IFLD

! Relaxation fields
IF (LLTP) THEN
  I=I+1
  CLPREF(I)= 'RELA'
  CLSUFF(I)= 'TEMPERATURE '
  DO J=1,ITFING
    ZEXT(J,I)= ZTP(J)
  ENDDO
ENDIF
IF (LLWP) THEN
  I=I+1
  CLPREF(I)= 'RELA'
  CLSUFF(I)= 'PROP.RMAX.EA'
  DO J=1,ITFING
    ZEXT(J,I)= ZWP(J)
  ENDDO
ENDIF
IFLD=I

! Albedo and emissivity
IF (LLST.AND.LSOLV) THEN
  DO JC=I+1,I+JPNC
    CLPREF(JC)= 'SURF'
    INIVL(JC)= 0
  ENDDO
  CLSUFF(I+1)= 'ALBEDO      '
  CLSUFF(I+2)= 'EMISSIVITE  '
  CLSUFF(I+3)= 'Z0.FOIS.G   '
  CLSUFF(I+4)= 'GZ0.THERM   '
  LLPAC(I+3)= .FALSE.
  LLPAC(I+4)= .FALSE.
  DO J=1,ITFING
    ZEXT(J,I+1)= ZAL(J)
    ZEXT(J,I+2)= ZEM(J)
    ZEXT(J,I+3)= Z0D(J)
    ZEXT(J,I+4)= Z0T(J)
  ENDDO
  DEALLOCATE(ZAL)
  DEALLOCATE(ZEM)
  DEALLOCATE(Z0D)
  DEALLOCATE(Z0T)
  IFLD=IFLD+4
ENDIF

!     5.2 Biperiodization and writing

CALL EBICLI(YDGEOMETRY,YDGFL,YDEPHY,YDML_PHY_MF,IFLD+1,INIVL(0),CLPREF(0),CLSUFF(0),INUM,ZEXT(1,0),&
 & LLBIP(0),LLWRI(0),LLPAC(0))

DEALLOCATE(ZEXT)

!     5.3 Control and close ALADIN file

CALL ECHK923(YDGEOMETRY%YRDIM,INUM)

CALL LFILAF(IREP,INUM,.TRUE.)
CALL FAIRME(IREP,INUM,'KEEP')

!     ------------------------------------------------------------------


END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('EINCLI6',1,ZHOOK_HANDLE)
END SUBROUTINE EINCLI6
