SUBROUTINE ETRANSINV_MDL(YDGEOMETRY,YDGMV,YDMDDH,YDML_GCONF,PSPVOR,PSPDIV,PSPMEANU,PSPMEANV,PSPSP,PSPHV,PSPGFL,&
 & PGMV,PGMVS,PGFL,LDERR,&
 & PSPTNDSI_VOR,PSPTNDSI_DIV,PSPTNDSI_T,&
 & PSPTNDSI_SPD,PSPTNDSI_SVD,&
 & PSPTNDHD_VOR,PSPTNDHD_DIV,PSPTNDHD_T,&
 & PSPTNDHD_SPD,PSPTNDHD_SVD,PSPTNDHD_SNHX,PSPTNDHD_GFL,&
 & PGMVTNDSI,PGMVTNDHD,PGFLTNDHD,&
 & LDSIDDH,LDHDDDH,PSPVOR_FLT,PSPDIV_FLT,PSPUB_FLT,PSPVB_FLT)

!**** *ETRANSINV_MDL * - Inverse transforms for model

!     Purpose.  Perform inverse transform (spectral to gridpoint)
!     --------

!**   Interface.  CALL ETRANSINV_MDL(...)
!     ---------- 

!     Explicit arguments : 
!     --------------------
!        PSPVOR - spectral vorticity
!        PSPDIV - spectral divergence
!        PSPSP  - spectral surface pressure
!        PSPHV  - spectral thermodynamic variables
!        PSPGFL - spectral GFL variables
!        PGMV   - GMV gridpoint
!        PGMVS  - GMV single level gridpoint
!        PGFL   - GFL gridpoint
!        LDERR  - TRUE if derivatives required
!        LDFSCOMP - true if "scientific" computations in fourier space req.
!        PSPVOR_FLT,PSPDIV_FLT - optional filtered gradients if LGRADSP
!        PSPUB_FLT,PSPVB_FLT - optional mean wind of filtered gradients

!        Called by TRANSINVH

!     Externals.
!     ----------
!     INV_TRANS - inverse transform (TRANS library)

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!      Mats Hamrud *ECMWF*
!      Original : 00-10-25

!     Modifications.
!     --------------
!      R. El Khatib 02-09-05 : Fix for passive scalars.
!      Modified : 02-09-30 P. Smolikova (PGPAUX transf. for d4 in NH)
!      03-09-30 Y. Seity and G. Radnoti (phasing for AL27)
!      M.Hamrud      01-Oct-2003 CY28 Cleaning
!      O.Spaniel     Oct-2004 phasing for AL29
!      R.Brozkova    Jul-2005 cleaning the specific VDAUX structure
!      K. Yessad (Jan 2011): cleanings.
!      A. Bogatchev 14-04-2013 coherence with modified modules
!      M. Hortal     Nov-2013 adaptation of Wedi's LGRADSP
!      B. Bochenek (Apr 2015): Phasing: move some variables and update
!      O. Marsden: June 2015 CY42 YRGMV, YRGFL, YRSURF, YRGMV5, and YRGFL5 are now passed by argument
!      O. Marsden: June 2015 CY42 YRGMV, YRGFL, YRSURF, YRGMV5, and YRGFL5 are now passed by argument
!     ------------------------------------------------------------------

USE MODEL_GENERAL_CONF_MOD , ONLY : MODEL_GENERAL_CONF_TYPE
USE GEOMETRY_MOD , ONLY : GEOMETRY
USE YOMGMV   , ONLY : TGMV
USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
USE YOMCT3   , ONLY : NSTEP
USE YOMMP0    ,ONLY : MYSETV
USE YOMMDDH  , ONLY : TMDDH
USE YOMCT0   , ONLY : LNHDYN
USE YOMDYNA  , ONLY : YRDYNA

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY), INTENT(IN) :: YDGEOMETRY
TYPE(TGMV) , INTENT(INOUT) :: YDGMV
TYPE(TMDDH) ,INTENT(IN)    :: YDMDDH
TYPE(MODEL_GENERAL_CONF_TYPE),INTENT(IN) :: YDML_GCONF
REAL(KIND=JPRB),INTENT(IN)   :: PSPVOR(:,:)
REAL(KIND=JPRB),INTENT(IN)   :: PSPDIV(:,:)
REAL(KIND=JPRB),INTENT(IN)   :: PSPMEANU(:)
REAL(KIND=JPRB),INTENT(IN)   :: PSPMEANV(:)
REAL(KIND=JPRB),INTENT(IN)   :: PSPSP(:) 
REAL(KIND=JPRB),INTENT(IN)   :: PSPHV(:,:,:)
REAL(KIND=JPRB),INTENT(IN)   :: PSPGFL(:,:,:)
REAL(KIND=JPRB),INTENT(OUT)  :: PGMV(:,:,:,:)
REAL(KIND=JPRB),INTENT(OUT)  :: PGMVS(:,:,:)
REAL(KIND=JPRB),INTENT(OUT)  :: PGFL(:,:,:,:)
LOGICAL        ,INTENT(IN)   :: LDERR 
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDSI_VOR(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDSI_DIV(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDSI_T(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDSI_SPD(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDSI_SVD(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDHD_VOR(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDHD_DIV(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDHD_T(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDHD_SPD(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDHD_SVD(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDHD_SNHX(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPTNDHD_GFL(:,:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(INOUT) :: PGMVTNDSI(:,:,:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(INOUT) :: PGMVTNDHD(:,:,:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(INOUT) :: PGFLTNDHD(:,:,:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPVOR_FLT(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPDIV_FLT(:,:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPUB_FLT(:)
REAL(KIND=JPRB) ,OPTIONAL,INTENT(IN)    :: PSPVB_FLT(:)
LOGICAL  ,OPTIONAL  ,INTENT(IN)  :: LDSIDDH
LOGICAL  ,OPTIONAL  ,INTENT(IN)  :: LDHDDDH
!     ------------------------------------------------------------------
REAL(KIND=JPRB) :: ZSP(1,YDGEOMETRY%YRDIM%NSPEC2)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPTND_HV(:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZGRAD(:,:,:,:)
INTEGER(KIND=JPIM) :: IST,IOFF,IDIM3,ISTGMV,IENGMV,IDIMGMVS,ISTUV,IENUV,IFLDHV
INTEGER(KIND=JPIM) :: IVSETSC(1), IBL, ICEND, JKGLO, JLEV, JROF
LOGICAL :: LLUVDER,LLVOR,LLSCDERS,LLDIVGP,LLSIDDH,LLHDDDH,LLGRADSP
REAL(KIND=JPRB) :: ZHOOK_HANDLE

!     ------------------------------------------------------------------

#include "einv_trans.h"
!     ------------------------------------------------------------------
IF (LHOOK) CALL DR_HOOK('ETRANSINV_MDL',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM, &
  & YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP, YDDIMF=>YDML_GCONF%YRDIMF)
ASSOCIATE( &
 & YT0=>YDGMV%YT0, YT9=>YDGMV%YT9, &
 & NGPTOT=>YDGEM%NGPTOT, NGPBLKS=>YDDIM%NGPBLKS, &
 & NFTHER=>YDDIMF%NFTHER, LVOR=>YDDIMF%LVOR, LUVDER=>YDDIMF%LUVDER, &
 & NSPEC2=>YDDIM%NSPEC2, NPROMA=>YDDIM%NPROMA, &
 & NFLEVG=>YDDIMV%NFLEVG, NRESOL=>YDDIM%NRESOL, &
 & NBSETLEV=>YDMP%NBSETLEV, NBSETSP=>YDMP%NBSETSP, &
 & MHDDDH_Q=>YDMDDH%MHDDDH_Q, MHDDDH_U=>YDMDDH%MHDDDH_U, &
 & MHDDDH_V=>YDMDDH%MHDDDH_V, MSIDDH_U1=>YDMDDH%MSIDDH_U1, &
 & MSIDDH_V1=>YDMDDH%MSIDDH_V1, NDIMSIGMV=>YDMDDH%NDIMSIGMV)
!     ------------------------------------------------------------------

LLUVDER  = LUVDER .AND. LDERR
LLVOR    = LVOR   .AND. LDERR
LLSCDERS = LDERR
LLDIVGP  = LDERR

IVSETSC(1) = NBSETSP

IF (PRESENT(PSPVOR_FLT)) THEN
  LLGRADSP = .TRUE.
ELSE
  LLGRADSP = .FALSE.
ENDIF
IF (PRESENT(LDSIDDH)) THEN
  LLSIDDH = LDSIDDH
ELSE
  LLSIDDH = .FALSE.
ENDIF

IF (PRESENT(LDHDDDH)) THEN
  LLHDDDH = LDHDDDH
ELSE
  LLHDDDH = .FALSE.
ENDIF

CALL GSTATS(1897,0)
IF(NBSETSP == MYSETV) THEN
  IST = 1
  ZSP(IST,:) = PSPSP(:)
ELSE
  IST = 0
ENDIF
CALL GSTATS(1897,1)
ISTGMV = YT0%NDIMUV+1
IENGMV = YT0%NDIM
IDIMGMVS = YT0%NDIMS
ISTUV = 1
IENUV = YT0%NDIMUV
IF( YRDYNA%LGRADSP ) THEN
  IENGMV = IENGMV-2
ENDIF
IF( LLGRADSP ) THEN
  IF( NSTEP > 0 ) THEN
    ALLOCATE(ZGRAD(NPROMA,NFLEVG,2,NGPBLKS))
    CALL EINV_TRANS(&
     & PSPVOR=PSPVOR_FLT,PSPDIV=PSPDIV_FLT,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,&
     & PGPUV=ZGRAD,&
     & PMEANU=PSPUB_FLT,PMEANV=PSPVB_FLT)

    !$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) &
    !$OMP& PRIVATE (JKGLO,IBL,ICEND) &
    !$OMP& PRIVATE (JROF,JLEV)
    DO JKGLO=1,NGPTOT,NPROMA
      IBL=(JKGLO-1)/NPROMA+1
      ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)
      DO JLEV=1,NFLEVG
        DO JROF=1,ICEND
          ! store the filtered rhs
          PGMV(JROF,JLEV,YT0%MSGRTL,IBL) = ZGRAD(JROF,JLEV,1,IBL)  
          PGMV(JROF,JLEV,YT0%MSGRTM,IBL) = ZGRAD(JROF,JLEV,2,IBL)  
        ENDDO
      ENDDO
    ENDDO
    !$OMP END PARALLEL DO
    DEALLOCATE(ZGRAD)
  ELSE
    ! step 0, set to zero

    !$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) &
    !$OMP& PRIVATE (JKGLO,IBL,ICEND) &
    !$OMP& PRIVATE (JROF,JLEV)
    DO JKGLO=1,NGPTOT,NPROMA
      IBL=(JKGLO-1)/NPROMA+1
      ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)
      DO JLEV=1,NFLEVG
        DO JROF=1,ICEND
          ! initialize unfiltered and filtered rhs
          PGMV(JROF,JLEV,YT9%MSGRTL,IBL) = 0.0_JPRB
          PGMV(JROF,JLEV,YT9%MSGRTM,IBL) = 0.0_JPRB

          PGMV(JROF,JLEV,YT0%MSGRTL,IBL) = 0.0_JPRB
          PGMV(JROF,JLEV,YT0%MSGRTM,IBL) = 0.0_JPRB
        ENDDO
      ENDDO
    ENDDO
    !$OMP END PARALLEL DO
  ENDIF
ENDIF
IF(.NOT. LLSCDERS) THEN
  IENGMV = MAX(ISTGMV,ISTGMV-1+(IENGMV-ISTGMV+1)/3)
  IDIMGMVS = MAX(1,IDIMGMVS/3)
  ISTUV = YT0%MU
  IENUV = YT0%MV
ENDIF
IF(YDML_GCONF%YGFL%NUMSPFLDS>0) THEN
  IOFF = YDML_GCONF%YGFL%NUMFLDS-YDML_GCONF%YGFL%NUMSPFLDS
  IDIM3 = YDML_GCONF%YGFL%NUMSPFLDS
  IF (LLSCDERS) IDIM3 = IDIM3*3
  CALL EINV_TRANS(&
   & PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:IST,:),PSPSC3A=PSPHV,&
   & PSPSC3B=PSPGFL,&
   & LDSCDERS=LLSCDERS,LDVORGP=LLVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
   & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
   & KVSETSC3A=NBSETLEV,KVSETSC3B=NBSETLEV,&
   & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
   & PGP3A=PGMV(:,:,ISTGMV:IENGMV,:),&
   & PGP3B=PGFL(:,:,IOFF+1:IOFF+IDIM3,:),PMEANU=PSPMEANU,PMEANV=PSPMEANV)  
ELSEIF (ISTGMV>IENGMV) THEN
    CALL EINV_TRANS(PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:1,:),&
     & LDSCDERS=LLSCDERS,LDVORGP=LLVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
     & PMEANU=PSPMEANU,PMEANV=PSPMEANV) 
ELSE
  CALL EINV_TRANS(PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:1,:),PSPSC3A=PSPHV,&
   & LDSCDERS=LLSCDERS,LDVORGP=LLVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
   & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
   & KVSETSC3A=NBSETLEV,&
   & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
   & PGP3A=PGMV(:,:,ISTGMV:IENGMV,:),PMEANU=PSPMEANU,PMEANV=PSPMEANV)  
ENDIF


!     ------------------------------------------------------------------
!     .INVERSE TRANSFORM OF SPECTRAL DDH TENDENCIES
!     ------------------------------------------------------------------

IF (LLSIDDH) THEN
  ISTGMV = MSIDDH_V1+1
  IENGMV = MAX(2,NDIMSIGMV/3)
  ! Inverse transform spectral SI tendencies
  IF (ISTGMV > IENGMV) THEN
    CALL EINV_TRANS(&
     & PSPVOR=PSPTNDSI_VOR,PSPDIV=PSPTNDSI_DIV,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,&
     & PGPUV=PGMVTNDSI(:,:,MSIDDH_U1:MSIDDH_V1,:),&
     & PMEANU=PSPMEANU,PMEANV=PSPMEANV)
  ELSE
    IFLDHV=MIN(3,NFTHER)
    ALLOCATE(ZSPTND_HV(NFLEVG,NSPEC2,IFLDHV))
    IF (IFLDHV < 3) THEN
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,1)= PSPTNDSI_T(1:NFLEVG,1:NSPEC2)
    ELSE
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,1)= PSPTNDSI_T(1:NFLEVG,1:NSPEC2)
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,2)= PSPTNDSI_SPD(1:NFLEVG,1:NSPEC2)
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,3)= PSPTNDSI_SVD(1:NFLEVG,1:NSPEC2)
    ENDIF
    CALL EINV_TRANS(&
     & PSPVOR=PSPTNDSI_VOR,PSPDIV=PSPTNDSI_DIV,PSPSC3A=ZSPTND_HV,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC3A=NBSETLEV,&
     & PGPUV=PGMVTNDSI(:,:,MSIDDH_U1:MSIDDH_V1,:),&
     & PGP3A=PGMVTNDSI(:,:,ISTGMV:IENGMV,:),&
     & PMEANU=PSPMEANU,PMEANV=PSPMEANV)
    DEALLOCATE(ZSPTND_HV)
  ENDIF
ENDIF

IF (LLHDDDH) THEN
  ! Inverse transform spectral HD tendencies
  IF (NFTHER > 0) THEN
    ALLOCATE(ZSPTND_HV(NFLEVG,NSPEC2,NFTHER))
    ZSPTND_HV(1:NFLEVG,1:NSPEC2,1)= PSPTNDHD_T(1:NFLEVG,1:NSPEC2)
    IF (LNHDYN) THEN
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,2)= PSPTNDHD_SPD(1:NFLEVG,1:NSPEC2)
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,3)= PSPTNDHD_SVD(1:NFLEVG,1:NSPEC2)
    ENDIF
    IF (YRDYNA%LNHX) ZSPTND_HV(1:NFLEVG,1:NSPEC2,4)= PSPTNDHD_SNHX(1:NFLEVG,1:NSPEC2)
    IF (YDML_GCONF%YGFL%NUMSPFLDS>0) THEN
      CALL EINV_TRANS(&
       & PSPVOR=PSPTNDHD_VOR,PSPDIV=PSPTNDHD_DIV,&
       & PSPSC3A=ZSPTND_HV,PSPSC3B=PSPTNDHD_GFL,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,&
       & KVSETSC3A=NBSETLEV,KVSETSC3B=NBSETLEV,&
       & PGPUV=PGMVTNDHD(:,:,MHDDDH_U:MHDDDH_V,:),&
       & PGP3A=PGMVTNDHD(:,:,MHDDDH_V+1:MHDDDH_V+NFTHER,:),&
       & PGP3B=PGFLTNDHD(:,:,1:MHDDDH_Q,:),&
       & PMEANU=PSPMEANU,PMEANV=PSPMEANV)
    ELSE
      CALL EINV_TRANS(&
       & PSPVOR=PSPTNDHD_VOR,PSPDIV=PSPTNDHD_DIV,PSPSC3A=ZSPTND_HV,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC3A=NBSETLEV,&
       & PGPUV=PGMVTNDHD(:,:,MHDDDH_U:MHDDDH_V,:),&
       & PGP3A=PGMVTNDHD(:,:,MHDDDH_V+1:MHDDDH_V+NFTHER,:),&
       & PMEANU=PSPMEANU,PMEANV=PSPMEANV)
    ENDIF
    DEALLOCATE(ZSPTND_HV)
  ELSE
    IF (YDML_GCONF%YGFL%NUMSPFLDS>0) THEN
      CALL EINV_TRANS(&
       & PSPVOR=PSPTNDHD_VOR,PSPDIV=PSPTNDHD_DIV,&
       & PSPSC3B=PSPTNDHD_GFL,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,&
       & KVSETSC3B=NBSETLEV,&
       & PGPUV=PGMVTNDHD(:,:,MHDDDH_U:MHDDDH_V,:),&
       & PGP3B=PGFLTNDHD(:,:,1:MHDDDH_Q,:),&
       & PMEANU=PSPMEANU,PMEANV=PSPMEANV)
    ELSE
      CALL EINV_TRANS(&
       & PSPVOR=PSPTNDHD_VOR,PSPDIV=PSPTNDHD_DIV,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,&
       & PGPUV=PGMVTNDHD(:,:,MHDDDH_U:MHDDDH_V,:),&
       & PMEANU=PSPMEANU,PMEANV=PSPMEANV)
    ENDIF
  ENDIF
ENDIF

!     ------------------------------------------------------------------
END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('ETRANSINV_MDL',1,ZHOOK_HANDLE)
END SUBROUTINE ETRANSINV_MDL
