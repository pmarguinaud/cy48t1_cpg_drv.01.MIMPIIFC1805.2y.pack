#ifdef RS6K
@PROCESS NOCHECK
#endif
SUBROUTINE CALL_SL_AD(YDGEOMETRY,YDGMV,YDMODEL,YDSL,KGPTOT,PB1,PB15,PB2,&
 & PGMVT1,PGMVT1S,PGFLT1,KGPBLKS)

!**** *CALL_SL_AD* - Semi-Lagrangian Interpolation AD

!     Purpose.
!     --------
!           Semi-Lagrangian Interpolation AD

!**   Interface.
!     ----------
!        *CALL* *CALL_SL_AD*

!        Explicit arguments :
!        --------------------
!        INPUT/OUTPUT:
!          YDSL    - SL_STRUCT definition.
!          PB1     - SLBUF1-buffer for interpolations.
!          PB2     - SLBUF2-buf to communicate info from non lag. to lag. dyn.
!          PB15    - SLBUF1-buf traj for interpolations
!          Some other dummy arguments documented for ex in LAPINE(A,B)AD

!        Implicit arguments :
!        --------------------

!     Method.
!     -------
!        See documentation

!     Externals.
!     ----------
!        Called by GP_MODEL_AD.

!     Author.
!     -------
!        Deborah Salmond 

!     Modifications.
!     --------------
!   Modified 01-08-30 by K. YESSAD: pruning and some other cleanings.
!   Modified at ECMWF (24 -> 24R1): some local arrays become allocatable.
!   Modified 02-10-01 G.Mozdzynski: support for radiation on-demand comms
!   M.Hamrud      01-Oct-2003 CY28 Cleaning
!   Modified 05-02-02 by C. Temperton: streamlining.
!   D.Salmond     08-Feb-2005 New versions of LAPINEAAD+LAPINEBAD
!   F.Vana        08-Jan-2007 plane geometry extension
!   N. Wedi and K. Yessad (Jan 2008): different dev for NH model and PC scheme
!   F. Vana       15-Aug-2008  Weights driven interpolation.
!   K. Yessad Nov 2008: rationalisation of dummy argument interfaces
!   K. Yessad Dec 2008: merge SLCOMM+SLCOMM1 -> SLCOMM.
!   K. Yessad Dec 2008: merge the different (E)SLEXTPOL.. -> (E)SLEXTPOL.
!   F. Vana       11-Dec-2008 OpenMP for vector platforms
!   F. Vana   13-Jan-2009: TL/AD of SLHD
!   K. Yessad (Aug 2009): always use root (QX,QY) for (p,q) variables names
!   K. Yessad (Jan 2011): introduce INTDYN_MOD structures.
!   G. Mozdzynski (Jan 2011): OOPS cleaning, use of derived type SL_STRUCT
!   G. Mozdzynski (Feb 2011): OOPS cleaning, use of derived types TGSGEOM and TCSGEOM
!   G.Mozdzynski (Aug 2011): support higher order interpolation
!   G. Mozdzynski (May 2012): further cleaning
!   F. Vana   09-Jan-2014 fixed dimension for SLCOMM2A
!   T. Wilhelmsson and K. Yessad (Oct 2013) Geometry and setup refactoring.
!   K. Yessad (July 2014): Move some variables.
!   F. Vana  21-Nov-2017: Options LSLDP_CURV and LHOISLT 
!   F. Vana July 2018: RK4 scheme for trajectory research.
!   F. Vana October 2018: Extended LSLDP_CURV & better OpenMP support.
!   F. Vana 25-Feb-2019: quintic ivertical interpolation for RHS
!   R. El Khatib 07-May-2019 Remove bounds violations if LVECADIN
! End Modifications
!     ------------------------------------------------------------------

USE TYPE_MODEL   , ONLY : MODEL
USE GEOMETRY_MOD , ONLY : GEOMETRY
USE YOMGMV       , ONLY : TGMV
USE PARKIND1     , ONLY : JPIM, JPRB
USE YOMHOOK      , ONLY : LHOOK, DR_HOOK
USE YOMMP0       , ONLY : NPROC, LSLDEBUG
USE YOMDYNA      , ONLY : LSLTVWENO, LHOISLT, LRHSVWENO
USE YOMCT3       , ONLY : NSTEP
USE YOMVAR       , ONLY : LVECADIN, LSLADREP
USE ALGORITHM_STATE_MOD  , ONLY : GET_NSIM4D
USE YOMMASK      , ONLY : NFIXSFLD
USE OML_MOD      , ONLY : OML_OMP, OML_SET_EVENT
USE EINT_MOD     , ONLY : SL_STRUCT
USE YOMCT0       , ONLY : L_OOPS

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)    ,INTENT(IN)    :: YDGEOMETRY
TYPE(TGMV)        ,INTENT(INOUT) :: YDGMV
TYPE(MODEL)       ,INTENT(INOUT) :: YDMODEL
TYPE(SL_STRUCT)   ,INTENT(INOUT) :: YDSL
INTEGER(KIND=JPIM),INTENT(IN)    :: KGPTOT
INTEGER(KIND=JPIM),INTENT(IN)    :: KGPBLKS 
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PB1(YDSL%NASLB1,YDMODEL%YRML_DYN%YRPTRSLB1%NFLDSLB1) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PB15(YDSL%NASLB1,YDMODEL%YRML_DYN%YRPTRSLB15%NFLDSLB15) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PB2(YDGEOMETRY%YRDIM%NPROMA,YDMODEL%YRML_DYN%YRPTRSLB2%NFLDSLB2,KGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGMVT1(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGMV%YT1%NDIM,KGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGMVT1S(YDGEOMETRY%YRDIM%NPROMA,YDGMV%YT1%NDIMS,KGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGFLT1(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NDIM1,KGPBLKS) 
!     ------------------------------------------------------------------
INTEGER(KIND=JPIM) :: JSTGLO, IST, IEND, IBL, JSTEP, IDIM1, IDIM2, IDIM3,&
 & JINC, JROF, JLEV, ILEVELS, ISTART, ISTOP, IDIM, JGFL, JITER
INTEGER(KIND=JPIM) :: ISTAGE2, ISTAGE3

INTEGER(KIND=JPIM) :: IDUMARR(2)

LOGICAL :: LLINC, LL2TLFFO, LLEXCLUDE
!LOGICAL :: L_OOPS

! * interpolated quantities arrays.
REAL(KIND=JPRB), ALLOCATABLE :: ZUF5(:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZVF5(:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZZF5(:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZUF05(:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZVF05(:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZZF05(:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZWF05(:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZUS5(:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZVS5(:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZZS5(:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZWS5(:,:,:,:,:)

! * interpolation weights
INTEGER(KIND=JPIM), ALLOCATABLE :: IL0(:,:,:,:,:,:)
INTEGER(KIND=JPIM), ALLOCATABLE :: ILH0(:,:,:,:)
INTEGER(KIND=JPIM), ALLOCATABLE :: IDEP(:,:,:,:,:)
INTEGER(KIND=JPIM), ALLOCATABLE :: INOWENO(:,:,:,:,:)

REAL(KIND=JPRB), ALLOCATABLE :: ZLSCAW(:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZRSCAW(:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZLSCAW5(:,:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZRSCAW5(:,:,:,:,:,:)

! * trigonometric arrays.
REAL(KIND=JPRB), ALLOCATABLE :: ZSCO(:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSCO5(:,:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZCCO(:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZCCO5(:,:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZLEV(:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZLEV5(:,:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZOUT5(:,:,:,:)

REAL(KIND=JPRB), ALLOCATABLE :: ZINC(:,:,:)
INTEGER(KIND=JPIM), ALLOCATABLE :: INC(:,:,:)

REAL(KIND=JPRB), POINTER :: ZB1(:,:)
INTEGER(KIND=JPIM),PARAMETER :: JP_LOCKS=55
INTEGER(KIND=JPIM) :: ILOCK(JP_LOCKS)
INTEGER(KIND=JPIM) :: JII,IVSEP
REAL(KIND=JPRB) :: ZHOOK_HANDLE

!     ------------------------------------------------------------------

#include "lapinea5.intfb.h"
#include "lapineaad.intfb.h"
#include "lapinebad.intfb.h"
#include "slcomm.intfb.h"
#include "slcomm2.intfb.h"
#include "slcomm2a.intfb.h"
#include "slextpol.intfb.h"
#include "check_sl_struct.intfb.h"
#include "slextpolad.intfb.h"

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('CALL_SL_AD',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP, &
 &  YDCSGEOM=>YDGEOMETRY%YRCSGEOM, YDGSGEOM=>YDGEOMETRY%YRGSGEOM , YDDYN=>YDMODEL%YRML_DYN%YRDYN, &
 & YDPHY=>YDMODEL%YRML_PHY_MF%YRPHY, &
 & YDPTRSLB2=>YDMODEL%YRML_DYN%YRPTRSLB2,YDPTRSLB1=>YDMODEL%YRML_DYN%YRPTRSLB1,YDRIP=>YDMODEL%YRML_GCONF%YRRIP, &
 & YGFL=>YDMODEL%YRML_GCONF%YGFL, &
 & YDEPHY=>YDMODEL%YRML_PHY_EC%YREPHY,YDPTRSLB15=>YDMODEL%YRML_DYN%YRPTRSLB15)

ASSOCIATE(NDIM1=>YGFL%NDIM1, NUMFLDS=>YGFL%NUMFLDS, YCOMP=>YGFL%YCOMP, &
 & NPROMA=>YDDIM%NPROMA, NSTENCILWIDE=>YDDIM%NSTENCILWIDE, &
 & NFLEN=>YDDIMV%NFLEN, NFLEVG=>YDDIMV%NFLEVG, NFLSUL=>YDDIMV%NFLSUL, &
 & L2TLFF=>YDDYN%L2TLFF, NITMP=>YDDYN%NITMP, NTLAG=>YDDYN%NTLAG, &
 & NVLAG=>YDDYN%NVLAG, NVSEPC=>YDDYN%NVSEPC, NVSEPL=>YDDYN%NVSEPL, &
 & NWLAG=>YDDYN%NWLAG, LSLDP_CURV=>YDDYN%LSLDP_CURV, LSLDP_RK=>YDDYN%LSLDP_RK, &
 & LVWENO_W=>YDDYN%LVWENO_W,LVWENO_T=>YDDYN%LVWENO_T,LVWENO_SP=>YDDYN%LVWENO_SP, &
 & LAGPHY=>YDEPHY%LAGPHY, LEPHYS=>YDEPHY%LEPHYS, &
 & YT1=>YDGMV%YT1, LMPHYS=>YDPHY%LMPHYS, &
 & NFLDSLB1=>YDPTRSLB1%NFLDSLB1, RPARSL1=>YDPTRSLB1%RPARSL1, &
 & MSLB1UR05=>YDPTRSLB15%MSLB1UR05, MSLB1WR05=>YDPTRSLB15%MSLB1WR05, &
 & MSLB1WR005=>YDPTRSLB15%MSLB1WR005, &
 & NFLDSLB15=>YDPTRSLB15%NFLDSLB15, RPARSL15=>YDPTRSLB15%RPARSL15, &
 & NFLDSLB2=>YDPTRSLB2%NFLDSLB2, &
 & NSTART=>YDRIP%NSTART, NSTOP=>YDRIP%NSTOP)
!     ------------------------------------------------------------------

!*       0.    PRELIMINARY ALLOCATIONS.
!              ------------------------

IF (LSLDP_RK) THEN
  ISTAGE2=2
  ISTAGE3=3
ELSE
  ISTAGE2=1
  ISTAGE3=1
ENDIF

ALLOCATE(IL0(NPROMA,NFLEVG,0:3,NITMP,ISTAGE3,KGPBLKS))
ALLOCATE(ILH0(NPROMA,NFLEVG,0:3,KGPBLKS))
ALLOCATE(IDEP(NPROMA,NFLEVG,NITMP,ISTAGE3,KGPBLKS))
ALLOCATE(INOWENO(NPROMA,NFLEVG,NITMP,ISTAGE3,KGPBLKS))

ALLOCATE(ZLSCAW(NPROMA,NFLEVG,YDMODEL%YRML_DYN%YYTLSCAW%NDIM,KGPBLKS))
ALLOCATE(ZRSCAW(NPROMA,NFLEVG,YDMODEL%YRML_DYN%YYTRSCAW%NDIM,KGPBLKS))
ALLOCATE(ZLSCAW5(NPROMA,NFLEVG,YDMODEL%YRML_DYN%YYTLSCAW%NDIM,NITMP,ISTAGE3,KGPBLKS))
ALLOCATE(ZRSCAW5(NPROMA,NFLEVG,YDMODEL%YRML_DYN%YYTRSCAW%NDIM,NITMP,ISTAGE3,KGPBLKS))

ALLOCATE(ZSCO(NPROMA,NFLEVG,YDMODEL%YRML_DYN%YYTSCO%NDIM,KGPBLKS))
ALLOCATE(ZSCO5(NPROMA,NFLEVG,YDMODEL%YRML_DYN%YYTSCO%NDIM,NITMP,ISTAGE2,KGPBLKS))
ALLOCATE(ZCCO(NPROMA,NFLEVG,YDMODEL%YRML_DYN%YYTCCO%NDIM,KGPBLKS))
ALLOCATE(ZCCO5(NPROMA,NFLEVG,YDMODEL%YRML_DYN%YYTCCO%NDIM,NITMP,ISTAGE3,KGPBLKS))
ALLOCATE(ZLEV(NPROMA,NFLEVG,KGPBLKS))
ALLOCATE(ZLEV5(NPROMA,NFLEVG,NITMP,ISTAGE3,KGPBLKS))
ALLOCATE(ZOUT5(NPROMA,NFLEVG,NITMP,KGPBLKS))

IF (LVECADIN) THEN
  ZB1(1:YDSL%NASLB1*NFLDSLB1,1:1) => PB1
ENDIF

IF (LSLDP_RK) THEN
  ALLOCATE(ZUF5(1,1,1,KGPBLKS)) 
  ALLOCATE(ZVF5(1,1,1,KGPBLKS)) 
  ALLOCATE(ZZF5(1,1,1,KGPBLKS)) 
  ALLOCATE(ZUF05(NPROMA,NFLEVG,ISTAGE2,NITMP,KGPBLKS))
  ALLOCATE(ZVF05(NPROMA,NFLEVG,ISTAGE2,NITMP,KGPBLKS))
  ALLOCATE(ZZF05(NPROMA,NFLEVG,ISTAGE2,NITMP,KGPBLKS))
  ALLOCATE(ZWF05(NPROMA,NFLEVG,ISTAGE2,NITMP,KGPBLKS))
  ALLOCATE(ZUS5(NPROMA,NFLEVG,ISTAGE3,NITMP,KGPBLKS))
  ALLOCATE(ZVS5(NPROMA,NFLEVG,ISTAGE3,NITMP,KGPBLKS))
  ALLOCATE(ZZS5(NPROMA,NFLEVG,ISTAGE3,NITMP,KGPBLKS))
  ALLOCATE(ZWS5(NPROMA,NFLEVG,ISTAGE3,NITMP,KGPBLKS))
ELSE
  ALLOCATE(ZUF5(NPROMA,NFLEVG,NITMP-1,KGPBLKS))
  ALLOCATE(ZVF5(NPROMA,NFLEVG,NITMP-1,KGPBLKS))
  ALLOCATE(ZZF5(NPROMA,NFLEVG,NITMP-1,KGPBLKS))
  ALLOCATE(ZUF05(1,1,1,1,KGPBLKS))
  ALLOCATE(ZVF05(1,1,1,1,KGPBLKS))
  ALLOCATE(ZZF05(1,1,1,1,KGPBLKS))
  ALLOCATE(ZWF05(1,1,1,1,KGPBLKS))
  ALLOCATE(ZUS5(1,1,1,1,KGPBLKS))
  ALLOCATE(ZVS5(1,1,1,1,KGPBLKS))
  ALLOCATE(ZZS5(1,1,1,1,KGPBLKS))
  ALLOCATE(ZWS5(1,1,1,1,KGPBLKS))
ENDIF

!     ------------------------------------------------------------------

!*       1.    Interface to global arrays.
!              ---------------------------

!L_OOPS=.TRUE.

IF(OML_OMP()) THEN
  DO JII=1,JP_LOCKS
    CALL OML_SET_EVENT(KGPTOT,ILOCK(JII))
  ENDDO
ENDIF

! Physics is called in CPGLAG
LLINC=.FALSE.

CALL GSTATS(35,2)
CALL GSTATS(63,0)

IF (NPROC > 1) THEN

  IF(YDSL%LSLONDEM)THEN
    YDSL%LSLONDEM_ACTIVE=.TRUE.
  ENDIF

! The Optimisation for the SLCOMM in the minimisations does not work in the OOPS context
! and will need to be reworked cleanly for OOPS

  IF (YDSL%LSLONDEM_ACTIVE) THEN
    YDSL%MASK_SL2=0
    IF(.NOT.L_OOPS)THEN
      IF( .NOT.YDSL%LSLT_ARRAYS_INIT )THEN
        YDSL%LSLT_ARRAYS_INIT=.TRUE.
        IF(ALLOCATED(YDSL%MASK_SL2T))DEALLOCATE(YDSL%MASK_SL2T)
        ALLOCATE(YDSL%MASK_SL2T(YDSL%NASLB1+NSTENCILWIDE*2,NSTART:NSTOP-1))
        IF(ALLOCATED(YDSL%LSLCOMM))DEALLOCATE(YDSL%LSLCOMM)
        ALLOCATE(YDSL%LSLCOMM(YDSL%NSLPROCS,NSTART:NSTOP-1))
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JSTEP)
        DO JSTEP=NSTART,NSTOP-1
          YDSL%MASK_SL2T(:,JSTEP)=0
          YDSL%LSLCOMM(:,JSTEP)=.FALSE.
        ENDDO
!$OMP END PARALLEL DO    
      ENDIF
    ENDIF
  ENDIF

  IF (YDSL%LSLONDEM_ACTIVE) THEN
    IF( L_OOPS .OR. GET_NSIM4D()==0 .OR. LSLADREP )THEN
      NFIXSFLD(1)=MSLB1UR05
      IF (LSLDP_RK) THEN
        NFIXSFLD(2)=MSLB1WR005+NFLEVG+NFLSUL
      ELSE
        NFIXSFLD(2)=MSLB1WR05+NFLEVG+NFLSUL
      ENDIF
      IF(.NOT.L_OOPS)THEN
        CALL SLCOMM(YDSL,NFIXSFLD,NFLDSLB15,LLINC,0,PB15,LDSLCOMM=YDSL%LSLCOMM(:,NSTEP), &
 &                  LD_TLEVOL=YDMODEL%YRML_PHY_SLIN%YREPHLI%LTLEVOL)
      ELSE
        CALL SLCOMM(YDSL,NFIXSFLD,NFLDSLB15,LLINC,0,PB15)
      ENDIF
    ELSE
      NFIXSFLD(1)=1
      NFIXSFLD(2)=NFLDSLB15
      LLEXCLUDE=.FALSE.
      IF(.NOT.L_OOPS)THEN
        CALL SLCOMM2A(YDGEOMETRY%YRDIM,YDSL,NFIXSFLD,LLEXCLUDE,&
         & YDSL%MASK_SL2T(:,NSTEP),&
         & NFLDSLB15,LLINC,PB15,LDSLCOMM=YDSL%LSLCOMM(:,NSTEP),LDTLEVOL=YDMODEL%YRML_PHY_SLIN%YREPHLI%LTLEVOL)
      ELSE
        CALL SLCOMM2A(YDGEOMETRY%YRDIM,YDSL,NFIXSFLD,LLEXCLUDE,&
         & YDSL%MASK_SL2,&
         & NFLDSLB15,LLINC,PB15)
      ENDIF
    ENDIF
  ELSE
    CALL SLCOMM(YDSL,IDUMARR,NFLDSLB15,LLINC,0,PB15)
  ENDIF

ENDIF

IF (YDSL%LSLONDEM_ACTIVE) THEN
  CALL SLEXTPOL(YDGEOMETRY%YRDIM,YDSL,NFLDSLB15,NFIXSFLD,3,RPARSL15,PB15,KMASK2=YDSL%MASK_SL2)  
ELSE
  CALL SLEXTPOL(YDGEOMETRY%YRDIM,YDSL,NFLDSLB15,IDUMARR,1,RPARSL15,PB15)
ENDIF
IF( LSLDEBUG) CALL CHECK_SL_STRUCT(YDSL,'SLEXTPOL')

CALL GSTATS(63,1)
CALL GSTATS(35,3)

CALL GSTATS(1017,0)
!$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) PRIVATE(JSTGLO,IST,IEND,IBL)

DO JSTGLO=1,KGPTOT,NPROMA
  IST=1
  IEND=MIN(NPROMA,KGPTOT-JSTGLO+1)
  IBL=(JSTGLO-1)/NPROMA+1

  CALL LAPINEA5(YDGEOMETRY,YDRIP,YDMODEL%YRML_DYN,IST,IEND,YDSL,.TRUE.,&
   & IBL,ISTAGE2,ISTAGE3,&
   & PB15(1,1),PB2(1,1,IBL),&
   & ZCCO5(1,1,1,1,1,IBL),ZUF5(1,1,1,IBL),ZVF5(1,1,1,IBL),ZZF5(1,1,1,IBL),&
   & ZUF05(1,1,1,1,IBL),ZVF05(1,1,1,1,IBL),ZZF05(1,1,1,1,IBL),ZWF05(1,1,1,1,IBL),&
   & ZUS5(1,1,1,1,IBL),ZVS5(1,1,1,1,IBL),ZZS5(1,1,1,1,IBL),ZWS5(1,1,1,1,IBL),&
   & IL0(1,1,0,1,1,IBL),ILH0(1,1,0,IBL),ZLSCAW5(1,1,1,1,1,IBL),ZRSCAW5(1,1,1,1,1,IBL),&
   & ZSCO5(1,1,1,1,1,IBL),ZLEV5(1,1,1,1,IBL),ZOUT5(1,1,1,IBL),&
   & IDEP(1,1,1,1,IBL),INOWENO(1,1,1,1,IBL))

ENDDO

!$OMP END PARALLEL DO
CALL GSTATS(1017,1)

IF (NPROC > 1 .AND. YDSL%LSLONDEM_ACTIVE) THEN

  IF( L_OOPS .OR. GET_NSIM4D()==0 .OR. LSLADREP )THEN
    LLINC=.FALSE.

    CALL GSTATS(35,2)
    CALL GSTATS(64,0)

    NFIXSFLD(1)=MSLB1UR05
    IF (LSLDP_RK) THEN
      NFIXSFLD(2)=MSLB1WR005+NFLEVG+NFLSUL
    ELSE
      NFIXSFLD(2)=MSLB1WR05+NFLEVG+NFLSUL
    ENDIF
    LLEXCLUDE=.TRUE.

    IF(.NOT.L_OOPS)THEN
      CALL SLCOMM2A(YDGEOMETRY%YRDIM,YDSL,NFIXSFLD,LLEXCLUDE,&
       & YDSL%MASK_SL2,&
       & NFLDSLB15,LLINC,PB15,LDSLCOMM=YDSL%LSLCOMM(:,NSTEP),LDTLEVOL=YDMODEL%YRML_PHY_SLIN%YREPHLI%LTLEVOL)
    ELSE
      CALL SLCOMM2A(YDGEOMETRY%YRDIM,YDSL,NFIXSFLD,LLEXCLUDE,&
       & YDSL%MASK_SL2,&
       & NFLDSLB15,LLINC,PB15)
    ENDIF
  
    CALL SLEXTPOL(YDGEOMETRY%YRDIM,YDSL,NFLDSLB15,NFIXSFLD,2,RPARSL15,PB15)
    IF( LSLDEBUG) CALL CHECK_SL_STRUCT(YDSL,'SLEXTPOL')

    CALL GSTATS(64,1)
    CALL GSTATS(35,3)

    IF(.NOT.L_OOPS)THEN
      IF( YDSL%CVER == 'AD' )THEN
        ! only copy over masks if we have different masks to TL (i.e.CVER='SL') 
        YDSL%MASK_SL2T(:,NSTEP)=YDSL%MASK_SL2
      ENDIF
    ENDIF

  ENDIF

ENDIF

CALL GSTATS(1018,0)

LL2TLFFO=L2TLFF.AND.(LMPHYS.OR.LEPHYS).AND.(.NOT.LAGPHY)

! Compute number of updates for LARCINBAD:
IDIM=0
IVSEP=NVSEPC
IF(LRHSVWENO) IVSEP=IVSEP+2
! U and V treated together
IF (NWLAG == 3) IDIM=IDIM+16 !2*8
IF (NWLAG == 3 .AND. LL2TLFFO) THEN
  IF (LVWENO_W) THEN
    IDIM=IDIM+112   ! 2*56
  ELSE
    IDIM=IDIM+64    ! 2*32
  ENDIF
ENDIF
IF (LVWENO_W) THEN
  IDIM=IDIM+112   ! 2*56
ELSE
  IDIM=IDIM+64    ! 2*32
ENDIF
! Temperature
IF (NTLAG == 3) IDIM=IDIM+8
IF (LVWENO_T) THEN
  IDIM=IDIM+56
ELSE
  IDIM=IDIM+32
ENDIF
DO JGFL=1,YGFL%NUMFLDS
  IF(YCOMP(JGFL)%LADV) THEN
    IF (YCOMP(JGFL)%CSLINT=='LAITRWENO   ') THEN
      IDIM=IDIM+56
    ELSE
      IDIM=IDIM+32
    ENDIF
  ENDIF
ENDDO
! Continuity equation
IF (NVLAG == 2) THEN
  IF (LVWENO_SP) THEN
    IDIM=IDIM+56
  ELSE
    IDIM=IDIM+32
  ENDIF
ELSEIF (NVLAG == 3) THEN
  IDIM=IDIM+8
ENDIF
IDIM=IDIM+12

IF (LVECADIN) THEN
  IDIM1=IDIM*NFLEVG+1
  IDIM2=NPROMA
ELSE
  IDIM1=IDIM
  IDIM2=1
ENDIF

!$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) &
!$OMP& PRIVATE(JSTGLO,IST,IEND,IBL,JII,ZINC,INC) &
!$OMP& PRIVATE(JINC,ISTART,ISTOP,ILEVELS,JROF,JLEV)

DO JSTGLO=1,KGPTOT,NPROMA

  ALLOCATE(ZINC(IDIM1,IDIM2,1))
  ALLOCATE( INC(IDIM1,IDIM2,1))

  IST=1
  IEND=MIN(NPROMA,KGPTOT-JSTGLO+1)
  IBL=(JSTGLO-1)/NPROMA+1
  IF(OML_OMP().AND.JSTGLO == 1) THEN
    DO JII=1,JP_LOCKS
      CALL OML_SET_EVENT(1,ILOCK(JII))
    ENDDO
  ENDIF

  CALL LAPINEBAD(YDGEOMETRY,YDGMV,YDEPHY,YDMODEL%YRML_GCONF,YDMODEL%YRML_DYN,YDPHY,IST,IEND,YDSL,JSTGLO,&
   & IBL,INOWENO(1,1,NITMP,ISTAGE3,IBL),&
   & PB1(1,1),PB15(1,1),&
   & PGMVT1(1,1,1,IBL),PGMVT1S(1,1,IBL),PGFLT1(1,1,1,IBL),PB2(1,1,IBL),&
   & ZINC,INC,IDIM,IDIM1,IDIM2,&
   & ZCCO(1,1,1,IBL),ZCCO5(1,1,1,NITMP,ISTAGE3,IBL),&
   & IL0(1,1,0,NITMP,ISTAGE3,IBL),ILH0(1,1,0,IBL),ZLSCAW(1,1,1,IBL),ZRSCAW(1,1,1,IBL),&
   & ZLSCAW5(1,1,1,NITMP,ISTAGE3,IBL),ZRSCAW5(1,1,1,NITMP,ISTAGE3,IBL),&
   & ZSCO(1,1,1,IBL),ZLEV(1,1,IBL),IDEP(1,1,NITMP,ISTAGE3,IBL),ILOCK)

  IF (LVECADIN) THEN

    ! The global update (moved from LARCINBAD to here)

    !!! NOTE: On no account should the following loop ordering be changed!
    !!! (loop on JINC must be innermost for vectorization;
    !!! the chopping is done to guarantee safety of the vectorization;
    !!! outer loop must be on JROF for reproducibility)

!$OMP CRITICAL

    DO JROF=IST,IEND
      ISTOP=0
      DO JLEV=1,IVSEP
        ILEVELS=(NFLEVG-JLEV)/IVSEP + 1
        ISTART=ISTOP+1
        ISTOP=ISTART+ILEVELS*IDIM-1
#if defined(VPP)
!OCL NOVREC
#elif defined(NECSX)
!CDIR VWORK=STACK
!CDIR VWORKSZ=4M
!CDIR UNROLL=4
!CDIR NODEP
!CDIR GTHREORDER
!CDIR VOVERTAKE(ZB1),VOB
#endif
        DO JINC=ISTART,ISTOP
          ZB1(INC(JINC,JROF,1),1)=ZB1(INC(JINC,JROF,1),1)+ZINC(JINC,JROF,1)
        ENDDO
      ENDDO
    ENDDO

!$OMP END CRITICAL
  ENDIF

  DEALLOCATE(ZINC)
  DEALLOCATE(INC)

ENDDO

!$OMP END PARALLEL DO

IF(OML_OMP()) THEN
  DO JII=1,JP_LOCKS
    CALL OML_SET_EVENT(KGPTOT,ILOCK(JII))
  ENDDO
ENDIF


! Compute number of updates for LARCINAAD:
IF (LSLTVWENO) THEN
  ! High order interpolation with WENO along vertical, 56 stencil each
  IDIM=168
  IF (LSLDP_CURV) IDIM = IDIM + 56 ! one more interpolation for z component
  IVSEP=NVSEPC+2
ELSEIF (LHOISLT) THEN
  ! High order interpolation, 32 each
  IDIM=96
  IF (LSLDP_CURV) IDIM = IDIM + 32 ! one more interpolation for z component
  IVSEP=NVSEPC
ELSE
  ! 3D-linear interpolations, 8 each
  IDIM=24
  IF (LSLDP_CURV) IDIM = IDIM + 8  ! one more interpolation for z component
  IVSEP=NVSEPL
ENDIF

IF (LVECADIN) THEN
  IDIM1=IDIM*NFLEVG+1
ELSE
  IDIM1=IDIM
ENDIF

IF (LSLDP_RK) THEN
  IDIM3=3*(NITMP-1)
ELSE
  IDIM3=NITMP-1
ENDIF
  

!$OMP PARALLEL DO SCHEDULE (DYNAMIC,1) &
!$OMP& PRIVATE(JSTGLO,IST,IEND,IBL,JII,ZINC,INC ) &
!$OMP& PRIVATE(JINC,ISTART,ISTOP,ILEVELS,JROF,JLEV,JITER)

DO JSTGLO=1,KGPTOT,NPROMA

  ALLOCATE(ZINC(IDIM1,IDIM2,IDIM3))
  ALLOCATE( INC(IDIM1,IDIM2,IDIM3))

  IST=1
  IEND=MIN(NPROMA,KGPTOT-JSTGLO+1)
  IBL=(JSTGLO-1)/NPROMA+1
  IF(OML_OMP().AND.JSTGLO == 1) THEN
    DO JII=1,JP_LOCKS
      CALL OML_SET_EVENT(1,ILOCK(JII))
    ENDDO
  ENDIF

  CALL LAPINEAAD(YDGEOMETRY,YDRIP,YDMODEL%YRML_DYN,IST,IEND,YDSL,JSTGLO,&
   & IBL,ISTAGE2,ISTAGE3,IDEP(1,1,1,1,IBL),INOWENO(1,1,1,1,IBL),&
   & ZINC,INC,IDIM1,IDIM2,IDIM3,&
   & PB1(1,1),PB2(1,1,IBL),PB15(1,1),&
   & ZCCO(1,1,1,IBL),ZCCO5(1,1,1,1,1,IBL),&
   & IL0(1,1,0,1,1,IBL),ZLSCAW(1,1,1,IBL),ZRSCAW(1,1,1,IBL),&
   & ZLSCAW5(1,1,1,1,1,IBL),ZRSCAW5(1,1,1,1,1,IBL),& 
   & ZSCO(1,1,1,IBL),ZLEV(1,1,IBL),ZSCO5(1,1,1,1,1,IBL),ZLEV5(1,1,1,1,IBL),&
   & ZUF5(1,1,1,IBL),ZVF5(1,1,1,IBL),ZZF5(1,1,1,IBL),&
   & ZUF05(1,1,1,1,IBL),ZVF05(1,1,1,1,IBL), ZZF05(1,1,1,1,IBL),ZWF05(1,1,1,1,IBL),&
   & ZUS5(1,1,1,1,IBL),ZVS5(1,1,1,1,IBL), ZZS5(1,1,1,1,IBL),ZWS5(1,1,1,1,IBL),&
   & ZOUT5(1,1,1,IBL),ILOCK)

  IF (LVECADIN) THEN
!$OMP CRITICAL

    ! Finally, do all the updates together (if in vector mode):

    !!! NOTE: On no account should the following loop ordering be changed!
    !!! (loop on JINC must be innermost for vectorization;
    !!! the chopping is done to guarantee safety of the vectorization;
    !!! outer loop must be JITER (counted backward) and JROF for
    !!! reproducibility)

    DO JITER=IDIM3,1,-1
      DO JROF=IST,IEND
      ISTOP=0
        DO JLEV=1,IVSEP
          ILEVELS=(NFLEVG-JLEV)/IVSEP + 1
          ISTART=ISTOP+1
          ISTOP=ISTART+ILEVELS*IDIM-1
#if defined(VPP)
!OCL NOVREC
#elif defined(NECSX)
!CDIR VWORK=STACK
!CDIR VWORKSZ=4M
!CDIR UNROLL=4
!CDIR NODEP
!CDIR GTHREORDER
!CDIR VOVERTAKE(ZB1),VOB
#endif
          DO JINC=ISTART,ISTOP
            ZB1(INC(JINC,JROF,JITER),1)=ZB1(INC(JINC,JROF,JITER),1)&
             & +ZINC(JINC,JROF,JITER)
          ENDDO
        ENDDO
      ENDDO
    ENDDO

!$OMP END CRITICAL
  ENDIF

  DEALLOCATE(ZINC)
  DEALLOCATE(INC)

ENDDO

!$OMP END PARALLEL DO

CALL GSTATS(1018,1)

IF(.NOT.LSLADREP)THEN

  CALL SLEXTPOLAD(YDGEOMETRY%YRDIM,YDSL,NFLDSLB1,RPARSL1,PB1,KMASK1=YDSL%MASK_SL1)

  IF(YDSL%LSLONDEM_ACTIVE)THEN

    NFIXSFLD(1)=1
    NFIXSFLD(2)=0

    IF (NPROC > 1) THEN
      LLINC=.TRUE.
      CALL GSTATS(85,0)
      IF(.NOT.L_OOPS)THEN
        CALL SLCOMM2(YDGEOMETRY%YRDIM,YDSL,NFIXSFLD,YDSL%MASK_SL1,YDSL%MASK_SL2,&
         &           NFLDSLB1,LLINC,PB1,LDSLCOMM=YDSL%LSLCOMM(:,NSTEP),LDSWITCH=.TRUE., &
         &           LDTLEVOL=YDMODEL%YRML_PHY_SLIN%YREPHLI%LTLEVOL)
      ELSE
        CALL SLCOMM2(YDGEOMETRY%YRDIM,YDSL,NFIXSFLD,YDSL%MASK_SL1,YDSL%MASK_SL2,&
         &           NFLDSLB1,LLINC,PB1,LDSWITCH=.TRUE.)
      ENDIF
      CALL GSTATS(85,1)
    ENDIF

  ELSE

    IF (NPROC > 1) THEN
      LLINC=.TRUE.
      CALL GSTATS(85,0)
      CALL SLCOMM(YDSL,IDUMARR,NFLDSLB1,LLINC,0,PB1,LDSWITCH=.TRUE.)
      CALL GSTATS(85,1)
    ENDIF

  ENDIF

ENDIF

!     ------------------------------------------------------------------

!*       2.    FINAL ACTIONS AND DEALLOCATIONS.
!              ---------------------------------

DEALLOCATE(IL0)
DEALLOCATE(ILH0)
DEALLOCATE(IDEP)
DEALLOCATE(INOWENO)
DEALLOCATE(ZLSCAW)
DEALLOCATE(ZRSCAW)
DEALLOCATE(ZSCO)
DEALLOCATE(ZCCO)
DEALLOCATE(ZLEV)

DEALLOCATE(ZLSCAW5)
DEALLOCATE(ZRSCAW5)
DEALLOCATE(ZSCO5)
DEALLOCATE(ZCCO5)
DEALLOCATE(ZLEV5)
DEALLOCATE(ZOUT5)
DEALLOCATE(ZUF5,ZVF5,ZZF5)
DEALLOCATE(ZUF05,ZVF05,ZZF05,ZWF05)
DEALLOCATE(ZUS5,ZVS5,ZZS5,ZWS5)

!     ------------------------------------------------------------------

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('CALL_SL_AD',1,ZHOOK_HANDLE)
END SUBROUTINE CALL_SL_AD
