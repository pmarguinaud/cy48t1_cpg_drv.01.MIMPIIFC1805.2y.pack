#ifdef RS6K
@PROCESS NOCHECK
#endif
SUBROUTINE CPG_DRV(YDGEOMETRY,YDMODEL,YDFIELDS,YDVARS,&
 !---------------------------------------------------------------------
 ! - INPUT .
 & CDCONF,LD_DFISTEP,YDSL,KGPCOMP,&
 & PGFLSLP,PSAVTEND,PGMVTNDHD_DDH,PGFLTNDHD_DDH,PGPSDT2D,PSD_PF,&
 & PGRADIENT,&
 & PFORCEU,PFORCEV,PFORCET,PFORCEQ,&
 !---------------------------------------------------------------------
 ! - INPUT/OUTPUT .
 & PGMV,PGMVS,PGFL,PGFLPC,PGFLPT,&
 & PSP_SB,PSP_SG,PSP_RR,PSP_CL,PSD_VF,PSD_VP,PSD_VV,PSD_VH,PSD_VK,PSD_VA,PSD_VC,&
 & PSD_VD,PSD_SFL,PSD_SFO,PSD_XA,PSD_DI,PSD_XP,PSD_XP2,&
 & PEMTD,PEMTU,PTRSW,PRMOON,PGMVTNDSI_DDH,&
 & PGDEOSI,PGUEOSI,PGMU0,PGMU0_MIN,PGMU0_MAX,&
 & PGDEOTI,PGDEOTI2,PGUEOTI,PGUEOTI2,PGEOLT,PGEOXT,&
 & PGRPROX,PGMIXP,PGFLUXC,PGRSURF,&
 !---------------------------------------------------------------------
 ! - OUTPUT .
 & PB1,PB2,PGMVT1,PGMVT1S,PGFLT1,PEXTRA,PGMVTNDSL_DDH,PGFLTNDSL_DDH,YDDDH,&
 & PHIF0,PRCP0,PRE0F,PCTY0,PWRL9,PTRAJEC,PTRAJEC_OOPS)

!**** *CPG_DRV* - Grid point calculations driver routine.

!     Purpose.
!     --------
!           Do the parallel loop calling CPG, the grid point calculations.

!**   Interface.
!     ----------
!        *CALL* *CPG_DRV(...)*

!        Explicit arguments :
!        --------------------

!     INPUT:
!     ------
!        CDCONF       : configuration of work
!        LD_DFISTEP   : T if work - dfi
!        YDSL         : SL_STRUCT definition
!        KGPCOMP      : total number of grid points:
!                       ndglg*ndlon in global / ndguxg*ndlon in LAM
!                       used for model computations.
!        PGFLSLP      : GFL array for use in semi-lagrangian physics
!        PSAVTEND     : tendencies buffer for split ECMWF physics.
!        PGMVTNDHD_DDH: tendencies of horizontal diffusion scheme for GMV.
!        PGFLTNDHD_DDH: tendencies of horizontal diffusion for spectrally treated GFL.
!        PGPSDT2D     : cf. YGPSDT%GP2D in YOMSPSDT (buffer for stochastic physics).

!     INPUT/OUTPUT:
!     -------------
!        PGMV         : upper air GMV variables at t and t-dt.
!        PGMVS        : surface GMV variables at t and t-dt.
!        PGFL         : unified_treatment grid-point fields at t
!        PGFLPC       : unified_treatment grid-point fields at t (3TL PC only)
!        PGFLPT       : tendency of X variable from phy.
!        PSP_SB       : soil prognostic quantities for the different reservoirs
!        PSP_SG       : surface snow prognostic quantities
!        PSP_RR       : surface prognostic quantities 
!        PSP_CL       : cls diagnostic quantities fields
!        PSD_VF       : climatological/geographical diagnostic fields
!        PSD_VP       : deep soil diagnostic fields
!        PSD_VV       : vegetation diagnostic fields
!        PSD_VH       : convective cloud diagnostic fields
!        PSD_VK       : convective cloud prognostic fields
!        PSD_VA       : aerosol diagnostic fields
!        PSD_VC       : climatological ozone profiles diagnostic fields
!        PSD_VD       : diagnostic fields
!        PSD_SFL      : SFLUX diagnostic fields
!        PSD_SFO      : SFORC diagonstic fields
!        PSD_PF       : precip fraction 
!        PGRADIENT    : horizontal gradients for 3D physics 
!        PSD_XP       : precipitation type diagnostic
!        PSD_XP2      : precipitation type diagnostic
!        PEMTD        : downward longwave emissivity
!        PEMTU        : upward longwave emissivity
!        PTRSW        : shortwave transmissivity
!        PRMOON       : Moon radiation
!        PGMVTNDSI_DDH: tendencies of semi-implicit scheme.
!        PGDEOSI      : DESCENDING INCREMENTAL OPTICAL DEPTHS, SOLAR
!        PGUEOSI      : ASCENDING  INCREMENTAL OPTICAL DEPTHS, SOLAR
!        PGMU0        : COSINE OF SOLAR ZENITH ANGLE, APPROXIMATE ACTUAL VALUE
!        PGMU0_MIN    : COSINE OF SOLAR ZENITH ANGLE, MIN VALUE
!        PGMU0_MAX    : COSINE OF SOLAR ZENITH ANGLE, MAX VALUE
!        PGDEOTI      : descending incremental optical depths, dB/dT(T0) weights
!        PGDEOTI2     : descending incremental optical depths, B weights with
!                       linear T_e correction
!        PGUEOTI      : ascending incremental optical depths, dB/dT(T0) weights
!        PGUEOTI2     : ascending incremental optical depths, B weights with
!                       linear T_e correction
!        PGEOLT       : local optical depths, dB/dT(T0) weights
!        PGEOXT       : maximum optical depths for EBL-EAL, dB/dT(T0) weights
!        PGRPROX      : correction term for adjacent exchanges
!        PGMIXP       : non-statistical weights for bracketing
!        PGFLUXC      : out of bracket part of EBL, resp. EBL-EAL flux
!        PGRSURF      : corrective ratio for surface CTS contribution
!        YDDDH        : diagnostic superstructure

!     OUTPUT:
!     -------
!        PB1          : "SLBUF1" buffer for interpolations in SL scheme.
!        PB2          : "SLBUF2" buffer.
!        PGMVT1       : upper air GMV variables buffer.
!        PGMVT1S      : surface GMV variables buffer.
!        PGFLT1       : GFL variables buffer.
!        PGMVTNDSL_DDH: GMV(t+dt,F)-GMV(t or t-dt,O) for DDH
!        PGFLNDSL_DDH : GFL(t+dt,F)-GFL(t or t-dt,O) for DDH

!        Implicit arguments :
!        --------------------

!     Method.
!     -------
!        See documentation

!     Externals.
!     ----------

!     Reference.
!     ----------
!        ARPEGE documentation vol 2 ch 1 and vol 3 ch 6

!     Author.
!     -------
!      Tomas Wilhelmsson  *ECMWF*
!      Original : 2012-03-06 Created from CPG.

! Modifications
! -------------
!     T. Wilhelmsson (Sept 2013) Geometry and setup refactoring.
!     2013-11, J. Masek: Passing intermittency arrays for ACRANEB2.
!     F. Vana  28-Nov-2013 : Redesigned trajectory handling.
!     M. Diamantakis Dec 13 Add code for LSETTLSVF=T option
!     M. Ahlgrimm Apr 2014: Add lake variables and precip fraction to DDH oon to DDH output
!     K. Yessad (July 2014): Move some variables.
!     K. Yessad (Dec 2016): Prune obsolete options.
!     2017-09, J. Masek: Shifted dimensioning of PGMU0.
!     R. El Khatib 05-Jun-2018 computation of periods moved from cnt4 (OOPS refactoring)
!     M. Diamantakis (June 2018): Extra arguments for multiple (Atlas) grid advection scheme
!     J. Vivoda (July 2018): mixed NESC/SETTLS scheme.
!     R. El Khatib 27-02-2019 Use pointer function SC2PRG to against bounds violation
! End Modifications
!-------------------------------------------------------------------------------

USE TYPE_MODEL         , ONLY : MODEL
!
USE FIELDS_MOD         , ONLY : FIELDS
!
USE GEOMETRY_MOD       , ONLY : GEOMETRY
USE PARKIND1           , ONLY : JPIM, JPRB
USE YOMHOOK            , ONLY : LHOOK, DR_HOOK
USE YOMCT0             , ONLY : LSLAG, LRPLANE, NFRHIS  ,NHISTS  ,NHISTSMIN, LTWOTL
USE YOMCT1             , ONLY : N1HIS
USE YOMDYNA            , ONLY : LPC_FULL, LPC_CHEAP, LMIXETTLS, LMIXETTLS_PRINT
USE YOMCT3             , ONLY : NSTEP
USE YOMLUN             , ONLY : NULOUT
USE EINT_MOD           , ONLY : SL_STRUCT
USE YOMLSFORC          , ONLY : LMUSCLFA, NMUSCLFA
USE YOMSPSDT           , ONLY : YSPPT
USE YOMTRAJ            , ONLY : TRAJ_TYPE, TRAJ_PHYS_TYPE, TRAJ_SLAG_TYPE
USE YOMTRAJ_OOPS       , ONLY : TRAJ_TYPE_OOPS
USE MPL_MODULE         , ONLY : MPL_ALLREDUCE
USE YOMMP0             , ONLY : MYPROC, NPROC
USE DDH_MIX            , ONLY : TYP_DDH
USE INTDYN_MOD         , ONLY : YYTCTY0, YYTRCP0, YYTTND
USE SC2PRG_MOD         , ONLY : SC2PRG
USE FIELD_VARIABLES_MOD, ONLY: FIELD_VARIABLES
USE MF_PHYS_SURFACE_TYPE_MOD, ONLY : MF_PHYS_SURF_TYPE
USE CPG_TYPE_MOD, ONLY : CPG_DYN_TYPE,  CPG_PHY_TYPE, CPG_TND_TYPE, &
                       & CPG_MISC_TYPE, CPG_TMP_TYPE, CPG_DDH_TYPE, &
                       & CPG_SL1_TYPE,  CPG_SL2_TYPE, CPG_GPAR_TYPE
USE CPG_OPTS_TYPE_MOD, ONLY : CPG_BNDS_TYPE, CPG_OPTS_TYPE
USE MF_PHYS_TYPE_MOD, ONLY : MF_PHYS_TYPE
!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)    ,INTENT(IN)    :: YDGEOMETRY
TYPE(MODEL)       ,INTENT(INOUT) :: YDMODEL
!
TYPE(FIELDS)       ,INTENT(INOUT) :: YDFIELDS
TYPE(FIELD_VARIABLES), INTENT(INOUT)  :: YDVARS
!
CHARACTER(LEN=1)  ,INTENT(IN)    :: CDCONF 
LOGICAL           ,INTENT(IN)    :: LD_DFISTEP
TYPE(SL_STRUCT)   ,INTENT(IN)    :: YDSL
INTEGER(KIND=JPIM),INTENT(IN)    :: KGPCOMP 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGFLSLP(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NDIMSLP,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSAVTEND(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_PHY_G%YRSLPHY%NVTEND,&
 & YDGEOMETRY%YRDIM%NGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGMVTNDHD_DDH(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG, &
 & 2+YDMODEL%YRML_GCONF%YRDIMF%NFTHER,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(IN), TARGET :: PGFLTNDHD_DDH(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,1,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(IN), TARGET :: PGPSDT2D(YDGEOMETRY%YRDIM%NPROMA,YSPPT%YGPSDT(1)%NG2D,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(IN), TARGET :: PFORCEU(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(IN), TARGET :: PFORCEV(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(IN), TARGET :: PFORCET(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(IN), TARGET :: PFORCEQ(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_PF(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_PFD%NLEVS,YDFIELDS%YRSURF%YSD_PFD%NDIM,&
 & YDGEOMETRY%YRDIM%NGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGRADIENT(YDGEOMETRY%YRDIM%NPROMA,YDMODEL%YRML_PHY_MF%YRARPHY%NGRADIENTS,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGMV(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDFIELDS%YRGMV%NDIMGMV,&
 & YDGEOMETRY%YRDIM%NGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGMVS(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRGMV%NDIMGMVS,YDGEOMETRY%YRDIM%NGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGFL(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NDIM, &
 & YDGEOMETRY%YRDIM%NGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGFLPC(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NDIMPC, &
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB),   INTENT(INOUT) :: PGFLPT(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NDIMPT, &
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSP_SB(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSP_SBD%NLEVS,YDFIELDS%YRSURF%YSP_SBD%NDIM,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSP_SG(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSP_SGD%NLEVS,YDFIELDS%YRSURF%YSP_SGD%NDIM,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSP_RR(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSP_RRD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSP_CL(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSP_CLD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_VF(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_VFD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_VP(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_VPD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_VV(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_VVD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_VH(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_VHD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_VK(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_VKD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_VA(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_VAD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_VC(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_VCD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_VD(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_VDD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_SFL(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_SFLD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_SFO(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_SFOD%NDIM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_XA(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_XAD%NLEVS,YDFIELDS%YRSURF%YSD_XAD%NDIM,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_DI(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_DID%NLEVS,YDFIELDS%YRSURF%YSD_DID%NDIM,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_XP(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_XPD%NLEVS,YDFIELDS%YRSURF%YSD_XPD%NDIM,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSD_XP2(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRSURF%YSD_XP2D%NLEVS,YDFIELDS%YRSURF%YSD_XP2D%NDIM,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PEMTD(YDGEOMETRY%YRDIM%NPROMA,1:YDGEOMETRY%YRDIMV%NFLEVG+1,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PEMTU(YDGEOMETRY%YRDIM%NPROMA,1:YDGEOMETRY%YRDIMV%NFLEVG+1,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PTRSW(YDGEOMETRY%YRDIM%NPROMA,1:YDGEOMETRY%YRDIMV%NFLEVG+1,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PRMOON(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGMVTNDSI_DDH(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG, &
 & YDMODEL%YRML_DIAG%YRMDDH%NDIMSIGMV,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGDEOSI(YDGEOMETRY%YRDIM%NPROMM,0:YDGEOMETRY%YRDIMV%NFLEVG,2,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGUEOSI(YDGEOMETRY%YRDIM%NPROMM,0:YDGEOMETRY%YRDIMV%NFLEVG,2,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGMU0(YDGEOMETRY%YRDIM%NPROMM,0:YDMODEL%YRML_PHY_MF%YRPHY%NSORAYFR-1,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGMU0_MIN(YDGEOMETRY%YRDIM%NPROMM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGMU0_MAX(YDGEOMETRY%YRDIM%NPROMM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGDEOTI(YDGEOMETRY%YRDIM%NPROMM,0:YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGDEOTI2(YDGEOMETRY%YRDIM%NPROMM,0:YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGUEOTI(YDGEOMETRY%YRDIM%NPROMM,0:YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGUEOTI2(YDGEOMETRY%YRDIM%NPROMM,0:YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGEOLT(YDGEOMETRY%YRDIM%NPROMM,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGEOXT(YDGEOMETRY%YRDIM%NPROMM,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGRPROX(YDGEOMETRY%YRDIM%NPROMM,0:YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGMIXP(YDGEOMETRY%YRDIM%NPROMM,0:YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGFLUXC(YDGEOMETRY%YRDIM%NPROMM,0:YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(INOUT), TARGET :: PGRSURF(YDGEOMETRY%YRDIM%NPROMM,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PB1(YDSL%NASLB1,YDMODEL%YRML_DYN%YRPTRSLB1%NFLDSLB1)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PB2(YDGEOMETRY%YRDIM%NPROMA,YDMODEL%YRML_DYN%YRPTRSLB2%NFLDSLB2,YDGEOMETRY%YRDIM%NGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGMVT1(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDFIELDS%YRGMV%YT1%NDIM,&
 & YDGEOMETRY%YRDIM%NGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGMVT1S(YDGEOMETRY%YRDIM%NPROMA,YDFIELDS%YRGMV%YT1%NDIMS,YDGEOMETRY%YRDIM%NGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGFLT1(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NDIM1, &
 & YDGEOMETRY%YRDIM%NGPBLKS) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PEXTRA(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_PHY_G%YRDPHY%NVEXTRDYN,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGMVTNDSL_DDH(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG, &
 & 2+YDMODEL%YRML_GCONF%YRDIMF%NFTHER,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGFLTNDSL_DDH(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG, &
 & YDMODEL%YRML_GCONF%YGFL%NUMFLDS,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
TYPE(TYP_DDH)     ,INTENT(INOUT) :: YDDDH
REAL(KIND=JPRB) ,INTENT(OUT), TARGET :: PHIF0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB) ,INTENT(OUT), TARGET :: PRCP0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YYTRCP0%NDIM,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB) ,INTENT(OUT), TARGET :: PRE0F(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB),INTENT(OUT) , TARGET :: PCTY0(YDGEOMETRY%YRDIM%NPROMA,0:YDGEOMETRY%YRDIMV%NFLEVG,YYTCTY0%NDIM,&
 & YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB) ,INTENT(OUT), TARGET :: PWRL9(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,& 
 & YDGEOMETRY%YRDIM%NGPBLKS)
TYPE(TRAJ_TYPE),OPTIONAL,INTENT(INOUT)         :: PTRAJEC
TYPE(TRAJ_TYPE_OOPS),OPTIONAL,INTENT(INOUT)    :: PTRAJEC_OOPS
!     ------------------------------------------------------------------
LOGICAL :: LLDIAB, LLFSTEP, LLSLPHY, LLUSEPB1, LLCT, LLCTC, LLCONFX
INTEGER(KIND=JPIM) :: JKGLO, IBL, JLEV, IOFF, ING
INTEGER(KIND=JPIM) :: ISETTLOFF(YDGEOMETRY%YRDIMV%NFLEVG)
INTEGER(KIND=JPIM) :: IWSETTLOFF(YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB)    :: ZDT, ZDTPHY, ZTE, ZBETADT
REAL(KIND=JPRB)    :: ZPD_STAT
! - IRAZTS : CONTROLS INSTANTANEOUS FLUX RESET
INTEGER(KIND=JPIM) :: IRAZTS(NSTEP/YDFIELDS%YRXFU%NFRRAZ:NSTEP/YDFIELDS%YRXFU%NFRRAZ)
! - IHISTS : ARRAY CONTAINING TRAJECTORY TIME STEPS
INTEGER(KIND=JPIM), ALLOCATABLE :: IHISTS(:)
INTEGER(KIND=JPIM) :: JJ, IFRGST, IFRGST2, IPERIOD,IFRVISI,IFRVISI2,IFRPRECIP,IFRPRECIP2
LOGICAL :: LLMEAN, LLMLPP
TYPE(TRAJ_PHYS_TYPE), POINTER :: ZTRAJEC_PHYS
TYPE(TRAJ_SLAG_TYPE), POINTER :: ZTRAJEC_SLAG
TYPE(MF_PHYS_SURF_TYPE) :: YLMF_PHYS_SURF
TYPE(CPG_DYN_TYPE) :: YLCPG_DYN0, YLCPG_DYN9
TYPE(CPG_PHY_TYPE) :: YLCPG_PHY0, YLCPG_PHY9
TYPE(CPG_TND_TYPE) :: YLCPG_TND
TYPE(CPG_MISC_TYPE):: YLCPG_MISC
TYPE(CPG_TMP_TYPE) :: YLCPG_TMP
TYPE(CPG_OPTS_TYPE):: YLCPG_OPTS
TYPE(CPG_BNDS_TYPE):: YLCPG_BNDS
TYPE(CPG_DDH_TYPE) :: YLCPG_DDH
TYPE(CPG_SL1_TYPE) :: YLCPG_SL1
TYPE(CPG_SL2_TYPE) :: YLCPG_SL2
TYPE(CPG_GPAR_TYPE) :: YLCPG_GPAR
TYPE(MF_PHYS_TYPE) :: YLMF_PHYS
CHARACTER (LEN=3)  :: CLPART
INTEGER(KIND=JPIM) :: ILPART, INPART
LOGICAL :: LLPERSISTENT
REAL(KIND=JPRB)    :: ZHOOK_HANDLE_INIT
REAL(KIND=JPRB)    :: ZHOOK_HANDLE_EXIT
REAL(KIND=JPRB)    :: ZHOOK_HANDLE_LOOP
REAL(KIND=JPRB)    :: ZHOOK_HANDLE

!     ------------------------------------------------------------------

#include "abor1.intfb.h"
#include "cpg.intfb.h"
#include "open_output_lfa.intfb.h"
#include "monio_t.intfb.h"
#include "mf_phys_openmp.intfb.h"

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('CPG_DRV',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, YDDYN=>YDMODEL%YRML_DYN%YRDYN, &
 & YDPTRSLB1=>YDMODEL%YRML_DYN%YRPTRSLB1,YDPTRSLB2=>YDMODEL%YRML_DYN%YRPTRSLB2, &
 & YDMDDH=>YDMODEL%YRML_DIAG%YRMDDH,YDRIP=>YDMODEL%YRML_GCONF%YRRIP,YDDPHY=>YDMODEL%YRML_PHY_G%YRDPHY, &
 & YDXFU=>YDFIELDS%YRXFU, &
 & YGFL=>YDMODEL%YRML_GCONF%YGFL,YDEPHY=>YDMODEL%YRML_PHY_EC%YREPHY, &
 & YDDIMF=>YDMODEL%YRML_GCONF%YRDIMF,YDSLPHY=>YDMODEL%YRML_PHY_G%YRSLPHY,YDPHY=>YDMODEL%YRML_PHY_MF%YRPHY)
ASSOCIATE(NDIM=>YGFL%NDIM, NDIM1=>YGFL%NDIM1, NDIMPC=>YGFL%NDIMPC, &
 & NDIMPT=>YGFL%NDIMPT, NDIMSLP=>YGFL%NDIMSLP, NUMFLDS=>YGFL%NUMFLDS, &
 & NDGENL=>YDDIM%NDGENL, NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, &
 & NPROMM=>YDDIM%NPROMM, &
 & NPROMNH=>YDDIM%NPROMNH, &
 & NFTHER=>YDDIMF%NFTHER, &
 & NFLEN=>YDDIMV%NFLEN, NFLEVG=>YDDIMV%NFLEVG, NFLSA=>YDDIMV%NFLSA, &
 & NTSSG=>YDDPHY%NTSSG, NVCLIS=>YDDPHY%NVCLIS, NVEXTRDYN=>YDDPHY%NVEXTRDYN, &
 & BETADT=>YDDYN%BETADT, LSETFSTAT=>YDDYN%LSETFSTAT, LSETTLSVF=>YDDYN%LSETTLSVF, &
 & NCURRENT_ITER=>YDDYN%NCURRENT_ITER, NFLEVSF=>YDDYN%NFLEVSF, &
 & LAGPHY=>YDEPHY%LAGPHY, LEPHYS=>YDEPHY%LEPHYS,LSLPHY=>YDEPHY%LSLPHY, &
 & NGPTOTG=>YDGEM%NGPTOTG, NDGUXG=>YDDIM%NDGUXG, NDLON=>YDDIM%NDLON, &
 & NDIMGMV=>YDFIELDS%YRGMV%NDIMGMV, NDIMGMVS=>YDFIELDS%YRGMV%NDIMGMVS, YT0=>YDFIELDS%YRGMV%YT0, &
 & YT1=>YDFIELDS%YRGMV%YT1, &
 & NDIMSIGMV=>YDMDDH%NDIMSIGMV, &
 & NFLDSLB1=>YDPTRSLB1%NFLDSLB1, &
 & NFLDSLB2=>YDPTRSLB2%NFLDSLB2, &
 & NSTART=>YDRIP%NSTART, TDT=>YDRIP%TDT, TSTEP=>YDRIP%TSTEP, NSTOP=>YDRIP%NSTOP, &
 & NVTEND=>YDSLPHY%NVTEND, &
 & YSD_PFD=>YDFIELDS%YRSURF%YSD_PFD, YSD_SFLD=>YDFIELDS%YRSURF%YSD_SFLD, &
 & YSD_SFOD=>YDFIELDS%YRSURF%YSD_SFOD, YSD_VAD=>YDFIELDS%YRSURF%YSD_VAD, YSD_VCD=>YDFIELDS%YRSURF%YSD_VCD, &
 & YSD_VDD=>YDFIELDS%YRSURF%YSD_VDD, YSD_VF=>YDFIELDS%YRSURF%YSD_VF, YSD_VFD=>YDFIELDS%YRSURF%YSD_VFD, &
 & YSD_VHD=>YDFIELDS%YRSURF%YSD_VHD, YSD_VKD=>YDFIELDS%YRSURF%YSD_VKD, YSD_VPD=>YDFIELDS%YRSURF%YSD_VPD,&
 & YSD_VVD=>YDFIELDS%YRSURF%YSD_VVD, YSD_XPD=>YDFIELDS%YRSURF%YSD_XPD, YSD_XP2D=>YDFIELDS%YRSURF%YSD_XP2D,&
 & YSD_XAD=>YDFIELDS%YRSURF%YSD_XAD, YSP_RR=>YDFIELDS%YRSURF%YSP_RR, YSP_RRD=>YDFIELDS%YRSURF%YSP_RRD, &
 & YSP_SBD=>YDFIELDS%YRSURF%YSP_SBD, YSP_SGD=>YDFIELDS%YRSURF%YSP_SGD, &
 & LRESET=>YDXFU%LRESET, LRESET_GST=>YDXFU%LRESET_GST,LRESET_GST2=>YDXFU%LRESET_GST2, &
 & LXXGST=>YDXFU%LXXGST, LXXGST2=>YDXFU%LXXGST2,LRESET_PRECIP=>YDXFU%LRESET_PRECIP, &
 & LRESET_PRECIP2=>YDXFU%LRESET_PRECIP2,LRESET_VISI=>YDXFU%LRESET_VISI, LRESET_VISI2=>YDXFU%LRESET_VISI2, &
 & LXXDIAGH=>YDXFU%LXXDIAGH, MEANPERIOD=>YDXFU%MEANPERIOD, NFRRAZ=>YDXFU%NFRRAZ, NMEANSTEPS=>YDXFU%NMEANSTEPS, &
 & NXGSTPERIOD=>YDXFU%NXGSTPERIOD, NXGSTPERIOD2=>YDXFU%NXGSTPERIOD2, LXMWINDCLS=>YDXFU%LXMWINDCLS, &
 & NVISIPERIOD=>YDXFU%NVISIPERIOD,NVISIPERIOD2=>YDXFU%NVISIPERIOD2, &
 & NDPRECPERIOD=>YDPHY%NDPRECPERIOD,NDTPREC=>YDPHY%YRDPRECIPS%NDTPREC, &
 & NDTPREC2=>YDPHY%YRDPRECIPS%NDTPREC2,&
 & NDPRECPERIOD2=>YDPHY%NDPRECPERIOD2,&
 & LDPRECIPS=>YDPHY%LDPRECIPS,LDPRECIPS2=>YDPHY%LDPRECIPS2,&
 & LXVISI=>YDXFU%LXVISI, LXVISI2=>YDXFU%LXVISI2,&
 & NSORAYFR=>YDPHY%NSORAYFR, LMPHYS=>YDPHY%LMPHYS,&
 & YDSIMPHL=>YDMODEL%YRML_PHY_MF%YRSIMPHL, &
 & LSIMPH=>YDMODEL%YRML_PHY_MF%YRSIMPHL%LSIMPH)

IF (LMUSCLFA) CALL OPEN_OUTPUT_LFA(YDMODEL%YRML_PHY_MF%YRPHY2)

!     ------------------------------------------------------------------

!*       1.    PRELIMINARY INITIALISATION OF SOME SCALARS.
!              -------------------------------------------

LLCT =LPC_FULL.AND.(NCURRENT_ITER > 0)
LLCTC=LPC_CHEAP.AND.(NCURRENT_ITER > 0)
IF(NSTEP > 0) THEN
  LLFSTEP=.FALSE.
ELSE
  LLFSTEP=.TRUE.
ENDIF

! Physics is called in CPG
LLDIAB= (LMPHYS.OR.LEPHYS) .AND. .NOT.LAGPHY .AND. (NCURRENT_ITER == 0)
LLSLPHY = LSLPHY.AND.LSLAG.AND.(.NOT.LLCTC)
! Initial fluxes
IF (CDCONF == 'X') THEN
  LLFSTEP=.TRUE.
ENDIF

IF (LSLAG .AND. ((NCURRENT_ITER == 0).OR.(LLCT.AND.(.NOT.LLCTC))) ) THEN 
  LLUSEPB1=.TRUE.
ELSE
  LLUSEPB1=.FALSE.
ENDIF

IF (CDCONF == 'A'.OR.CDCONF == 'B') THEN
  ! usual time-step
  ZDT=TDT
  ZDTPHY=TDT
  ZTE=1.0_JPRB
  ZBETADT=BETADT
  LLCONFX=.FALSE.
ELSEIF (CDCONF == 'X') THEN
  ! usual time-step for diagnostics but no SI scheme.
  ZDT=TDT
  ZDTPHY=TDT
  ZTE=1.0_JPRB
  ZBETADT=0.0_JPRB
  LLCONFX=.TRUE.
ELSE
  WRITE(NULOUT,*)'*********ERROR ON CDCONF'
  CALL ABOR1('CPG_DRV: ABOR1 CALLED')
ENDIF

!*    XFU CONTROL UPDATE

IF (.NOT.LLCONFX) THEN

  ! INSTANTANEOUS FLUX RESET
  CALL MONIO_T(NSTEP,YDRIP,IRAZTS(NSTEP:),YDXFU%N1RAZ,NFRRAZ,YDXFU%NRAZTS)
  LRESET=LLFSTEP.OR.(IRAZTS(NSTEP/NFRRAZ) == 1.AND.MOD(NSTEP,NFRRAZ) == 0)

  IF (LXMWINDCLS) THEN !WE WANT TO COMPUTE MEAN CLS WIND
    IPERIOD=MAX(0,NINT(REAL(MEANPERIOD,JPRB)/TSTEP)-1)
    ! HISTORY EVENTS FOR ATMOSPHERE
    ALLOCATE(IHISTS(NSTEP/NFRHIS:(NSTEP+1+IPERIOD)/NFRHIS))
    CALL MONIO_T(NSTEP/NFRHIS,YDRIP,IHISTS(NSTEP/NFRHIS:),N1HIS,NFRHIS,NHISTS,KN___TSMIN=NHISTSMIN)
    !IF WE SAVE HISTORY FILE THIS TIME STEP, WE REINIT MEAN CALCUL
    LLMLPP =IHISTS(NSTEP/NFRHIS) == 1.AND.MOD(NSTEP,NFRHIS) == 0
    IF(NSTART/=0.AND..NOT.YDMODEL%YRML_AOC%YRMCC%LMULTIYR)THEN
      LLMLPP = LLMLPP.AND.NSTEP/=NSTART
    ENDIF
    IF(LLMLPP) THEN
      NMEANSTEPS=0
    ENDIF
    !IF WE WILL SAVE HISTORY FILE IN THE NEXT MEANPERIOD SECONDS
    LLMEAN=.FALSE.
    DO JJ=0,IPERIOD
      IF(NSTEP+JJ+1<=NSTOP) THEN
        IF(IHISTS((NSTEP+JJ+1)/NFRHIS)==1.AND.MOD(NSTEP+JJ+1,NFRHIS) == 0) THEN
          LLMEAN=.TRUE.
        ENDIF
      ENDIF
    ENDDO
    IF (LLMEAN) THEN
      NMEANSTEPS=NMEANSTEPS+1
    ENDIF
    !IF WE RESET FLUXES WE WILL TRUNC THE MEAN PERIOD, SO NMEANSTEPS=1
    IF (NMEANSTEPS/=0 .AND. LRESET) THEN
      NMEANSTEPS=1
    ENDIF
  ENDIF

  !IF WE WANT TO COMPUTE MAX GUST OVER A DEFINED PERIOD (NXGSTPERIOD)
  IF((LXXGST.OR.LXXDIAGH) .AND. NXGSTPERIOD>0) THEN
    !IF WE SAVE HISTORY OR FULLPOS FILE THIS TIME STEP, WE REINIT MAX CALCULATION
    IFRGST=NINT(REAL(NXGSTPERIOD,JPRB)/TSTEP)
    LRESET_GST=.FALSE.
    IF(MOD(NSTEP,IFRGST)==0) LRESET_GST=.TRUE.
  ENDIF

  IF(LXXGST2.AND.NXGSTPERIOD2>0) THEN
    !IF WE SAVE HISTORY OR FULLPOS FILE THIS TIME STEP, WE REINIT MAX CALCULATION
    IFRGST2=NINT(REAL(NXGSTPERIOD2,JPRB)/TSTEP)
    LRESET_GST2=.FALSE.
    IF(MOD(NSTEP,IFRGST2)==0) LRESET_GST2=.TRUE.
  ENDIF

  IF(LXVISI .AND. NVISIPERIOD>0) THEN
    !IF WE SAVE HISTORY OR FULLPOS FILE THIS TIME STEP, WE REINIT 
    !CALCULATION
    IFRVISI=NINT(REAL(NVISIPERIOD,JPRB)/TSTEP)
    !WRITE(20,*),'IFRVISI=',IFRVISI,NVISIPERIOD,TSTEP,JSTEP
    LRESET_VISI=.FALSE.
    IF(MOD(NSTEP,IFRVISI)==0) LRESET_VISI=.TRUE.

  ENDIF
  IF(LXVISI2 .AND.NVISIPERIOD2>0) THEN
    !IF WE SAVE HISTORY OR FULLPOS FILE THIS TIME STEP, WE REINIT MAX
    !CALCULATION
    IFRVISI2=NINT(REAL(NVISIPERIOD2,JPRB)/TSTEP)
    !WRITE(20,*),'IFRVISI2=',IFRVISI2,NVISIPERIOD2,TSTEP,JSTEP
    LRESET_VISI2=.FALSE.
    IF(MOD(NSTEP,IFRVISI2)==0) LRESET_VISI2=.TRUE.
  ENDIF

  !IF WE WANT TO COMPUTE PRECIPS TYPE OVER A DEFINED PERIOD (NDPRECPERIOD)
  IF (LDPRECIPS.AND.NDPRECPERIOD>0) THEN
     !IF WE SAVE HISTORY OR FULLPOS FILE THIS TIME STEP, WE REINIT 
     ! PRECIPS TYPE
     IFRPRECIP=NINT(REAL(NDPRECPERIOD,JPRB)/TSTEP)
     LRESET_PRECIP=.FALSE.
    IF(MOD(NSTEP,IFRPRECIP)==0) LRESET_PRECIP=.TRUE.
  ENDIF

  !IF WE WANT TO COMPUTE PRECIPS TYPE OVER A DEFINED PERIOD (NDPRECPERIOD2)
  IF (LDPRECIPS2.AND.NDPRECPERIOD2>0) THEN
     !IF WE SAVE HISTORY OR FULLPOS FILE THIS TIME STEP, WE REINIT 
     ! PRECIPS TYPE
     IFRPRECIP2=NINT(REAL(NDPRECPERIOD2,JPRB)/TSTEP)
     LRESET_PRECIP2=.FALSE.
    IF(MOD(NSTEP,IFRPRECIP2)==0) LRESET_PRECIP2=.TRUE.
  ENDIF


ELSE

  LRESET=.TRUE.
  LRESET_GST=.TRUE.
  LRESET_GST2=.TRUE.
  LRESET_VISI=.TRUE.
  LRESET_VISI2=.TRUE.
  LRESET_PRECIP=.TRUE.
  LRESET_PRECIP2=.TRUE.

ENDIF

!     ------------------------------------------------------------------

!*       3.    READ BUFFERS, COMPUTE AUXILIARY QUANTITIES.
!              -------------------------------------------


IF (LHOOK) CALL DR_HOOK('CPG_DRV:INIT',0,ZHOOK_HANDLE_INIT)

CALL GETENV ('INPART', CLPART)

IF (CLPART /= '' .AND. CLPART /= '0') THEN
  INPART = 3
ELSE
  INPART = 1
ENDIF

LLPERSISTENT = INPART > 1

CALL YLCPG_OPTS%INIT (YDGEOMETRY, YDMODEL, YDFIELDS, LLCONFX)
CALL YLCPG_BNDS%INIT (YDGEOMETRY, YDMODEL, YDFIELDS)
CALL YLMF_PHYS_SURF%INIT (YDFIELDS%SURFVARS)
CALL YLCPG_DYN0%INIT (0_JPIM, YDFIELDS%REGISTRY, NLEV=NFLEVG, PHIF=PHIF0, PRCP=PRCP0, PREF=PRE0F, PCTY=PCTY0, PERSISTENT=LLPERSISTENT)
CALL YLCPG_PHY0%INIT (0_JPIM, YDFIELDS%REGISTRY, NLEV=NFLEVG, LDMF_PHYS=LMPHYS.OR.LSIMPH, PERSISTENT=LLPERSISTENT)

CALL YLCPG_SL1%INIT (YDFIELDS%REGISTRY, NLEV=NFLEVG, YDTPTRSLB1=YDMODEL%YRML_DYN%YRPTRSLB1, YGFL=YDFIELDS%YRGFL%YGFL, YDMODEL=YDMODEL, PERSISTENT=LLPERSISTENT)
CALL YLCPG_SL2%INIT (YDFIELDS%REGISTRY, NLEV=NFLEVG, YDTPTRSLB2=YDMODEL%YRML_DYN%YRPTRSLB2, PB2=PB2, PERSISTENT=LLPERSISTENT)

IF (.NOT. LTWOTL) THEN
  CALL YLCPG_DYN9%INIT (9_JPIM, YDFIELDS%REGISTRY, NLEV=NFLEVG, PWRL=PWRL9, PERSISTENT=LLPERSISTENT)
  CALL YLCPG_PHY9%INIT (9_JPIM, YDFIELDS%REGISTRY, NLEV=NFLEVG, LDMF_PHYS=LMPHYS.OR.LSIMPH, PERSISTENT=LLPERSISTENT)
ENDIF

CALL YLCPG_TMP%INIT (YDFIELDS%REGISTRY, NLEV=NFLEVG, PERSISTENT=LLPERSISTENT)

CALL YLCPG_DDH%INIT (YDFIELDS%REGISTRY, NLEV=NFLEVG, YDMODEL=YDMODEL, YDDDH=YDDDH, PERSISTENT=LLPERSISTENT)
CALL YLCPG_TND%INIT (YDFIELDS%REGISTRY, NLEV=NFLEVG, YDTTND=YYTTND, PERSISTENT=LLPERSISTENT)
CALL YLCPG_MISC%INIT (YDFIELDS%REGISTRY, YDCPG_OPTS=YLCPG_OPTS, PERSISTENT=LLPERSISTENT)
CALL YLCPG_GPAR%INIT (YDFIELDS%REGISTRY, YLCPG_OPTS, YDMODEL%YRML_PHY_MF%YRPARAR, PERSISTENT=LLPERSISTENT)

CALL YLMF_PHYS%OUT%INIT (YDFIELDS%REGISTRY, YDCPG_OPTS=YLCPG_OPTS, PERSISTENT=LLPERSISTENT)
CALL YLMF_PHYS%OPT%INIT (YDFIELDS%REGISTRY, YDCPG_OPTS=YLCPG_OPTS, LDMF_PHYS=LMPHYS.OR.LSIMPH, &
                       & PGDEOSI=PGDEOSI, PGUEOSI=PGUEOSI, PGMU0=PGMU0, &
                       & PGMU0_MIN=PGMU0_MIN, PGMU0_MAX=PGMU0_MAX, PGDEOTI=PGDEOTI, &
                       & PGDEOTI2=PGDEOTI2, PGUEOTI=PGUEOTI, PGUEOTI2=PGUEOTI2, &
                       & PGEOLT=PGEOLT, PGEOXT=PGEOXT, PGRPROX=PGRPROX, PGMIXP=PGMIXP, &
                       & PGFLUXC=PGFLUXC, PGRSURF=PGRSURF, PERSISTENT=LLPERSISTENT)
CALL YLMF_PHYS%FOR%INIT (YDFIELDS%REGISTRY, YDCPG_OPTS=YLCPG_OPTS, LDMF_PHYS=LMPHYS.OR.LSIMPH, &
                       & PU=PFORCEU, PV=PFORCEV, PT=PFORCET, PQ=PFORCEQ, PERSISTENT=LLPERSISTENT)
CALL YLMF_PHYS%GRA%INIT (YDFIELDS%REGISTRY, YDCPG_OPTS=YLCPG_OPTS, LDMF_PHYS=LMPHYS.OR.LSIMPH, PG=PGRADIENT, PERSISTENT=LLPERSISTENT)
CALL YLMF_PHYS%RAD%INIT (YDFIELDS%REGISTRY, YDCPG_OPTS=YLCPG_OPTS, LDMF_PHYS=LMPHYS.OR.LSIMPH, &
                       & PEMTD=PEMTD, PEMTU=PEMTU, PTRSW=PTRSW, PRMOON=PRMOON, PERSISTENT=LLPERSISTENT)


IF (YDMODEL%YRML_PHY_MF%YRPHY%LMPHYS .OR. LSIMPH) THEN

  ! From aplpar.F90
  IF (.NOT. YDMODEL%YRML_PHY_MF%YRARPHY%LMPA) THEN
    YDMODEL%YRML_PHY_MF%YRPHY2%TSPHY = MAX (ZDTPHY,1.0_JPRB)
  ENDIF

  ! From acnebr.F90
  IF (YDMODEL%YRML_PHY_MF%YRPHY%LNEBR) THEN
    IF(YDMODEL%YRML_PHY_MF%YRPHY%LRAY) THEN
      IF(YDMODEL%YRML_PHY_MF%YRPHY%LRNUMX) THEN
        YDMODEL%YRML_PHY_RAD%YRERAD%NOVLP=1
      ELSE
        YDMODEL%YRML_PHY_RAD%YRERAD%NOVLP=3
      ENDIF
    ENDIF
    IF(YDMODEL%YRML_PHY_MF%YRPHY%LRAYFM) THEN
      IF(YDMODEL%YRML_PHY_RAD%YRERAD%NOVLP == 1.OR.YDMODEL%YRML_PHY_RAD%YRERAD%NOVLP == 2) THEN
        YDMODEL%YRML_PHY_MF%YRPHY%LRNUMX=.TRUE.
      ELSE
        YDMODEL%YRML_PHY_MF%YRPHY%LRNUMX=.FALSE.
      ENDIF
    ENDIF
    IF(YDMODEL%YRML_PHY_MF%YRPHY%LRAYFM15) THEN
      CALL ABOR1('RADIATION SCHEME FROM CYCLE 15 NO LONGER AVAILABLE')
    ENDIF
  ENDIF
ENDIF

IF (LHOOK) CALL DR_HOOK('CPG_DRV:INIT',1,ZHOOK_HANDLE_INIT)

CALL GSTATS(1025,0)

DO ILPART = 1, INPART

  IF (INPART == 1) THEN
    CLPART = 'XXX'
  ELSE
    CLPART = '000'
    CLPART (ILPART:ILPART) = 'X'
  ENDIF

  IF (INPART == 3 .AND. ILPART == 2 .AND.  YDMODEL%YRML_PHY_MF%YRSIMPHL%LSIMPH) THEN

    CALL MF_PHYS_OPENMP (YDGEOMETRY, YLCPG_BNDS, YLCPG_OPTS, YLCPG_MISC, YLCPG_GPAR, YLCPG_PHY0, YLCPG_PHY9,  &
      & YLMF_PHYS, YLCPG_DYN0, YLCPG_DYN9, YLMF_PHYS_SURF, YLCPG_SL1, YLCPG_SL2, YDVARS, YDMODEL, &
      & YDFIELDS, LLCONFX, ZDTPHY)

  ELSE

!$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) PRIVATE (JKGLO,IBL,ZTRAJEC_PHYS,ZTRAJEC_SLAG,ZHOOK_HANDLE_LOOP) &
!$OMP&  FIRSTPRIVATE(YDDDH) LASTPRIVATE(YDDDH), &
!$OMP&  FIRSTPRIVATE (YDVARS, YLMF_PHYS_SURF, YLCPG_DYN0, YLCPG_DYN9, YLCPG_PHY0, YLCPG_PHY9, YLMF_PHYS, &
!$OMP&                YLCPG_TND, YLCPG_MISC, YLCPG_TMP, YLCPG_BNDS, YLCPG_DDH, YLCPG_SL1, YLCPG_SL2, &
!$OMP&                YLCPG_GPAR)
DO JKGLO=1,KGPCOMP,NPROMA

  IBL=(JKGLO-1)/NPROMA+1

  IWSETTLOFF(:,IBL) = 0

  IF (LHOOK) CALL DR_HOOK('CPG_DRV:LOOP.'//CLPART,0,ZHOOK_HANDLE_LOOP)

  CALL YDVARS%CLONE_ARRAYS
  CALL YDVARS%UPDATE_VIEW (BLOCK_INDEX=IBL)
  CALL YLMF_PHYS_SURF%UPDATE_VIEW (BLOCK_INDEX=IBL)
  CALL YLCPG_DYN0%UPDATE_VIEW (BLOCK_INDEX=IBL)
  CALL YLCPG_DYN9%UPDATE_VIEW (BLOCK_INDEX=IBL)
  CALL YLCPG_PHY0%UPDATE_VIEW (BLOCK_INDEX=IBL)
  CALL YLCPG_PHY9%UPDATE_VIEW (BLOCK_INDEX=IBL)
  CALL YLMF_PHYS%UPDATE_VIEW (BLOCK_INDEX=IBL)
  CALL YLCPG_TND%UPDATE_VIEW (BLOCK_INDEX=IBL)
  CALL YLCPG_MISC%UPDATE_VIEW (BLOCK_INDEX=IBL)
  CALL YLCPG_TMP%UPDATE_VIEW (BLOCK_INDEX=IBL)
  CALL YLCPG_DDH%UPDATE_VIEW (IBL)
  CALL YLCPG_SL1%UPDATE_VIEW (IBL)
  CALL YLCPG_SL2%UPDATE_VIEW (IBL)
  CALL YLCPG_GPAR%UPDATE_VIEW (IBL)
  CALL YLCPG_BNDS%UPDATE (IBL)
  

  IF (LHOOK) CALL DR_HOOK('CPG_DRV:LOOP.'//CLPART,1,ZHOOK_HANDLE_LOOP)

  IF(PRESENT(PTRAJEC))THEN
    CALL SC2PRG(IBL,PTRAJEC%PHYS,ZTRAJEC_PHYS)
    CALL SC2PRG(IBL,PTRAJEC%SLAG,ZTRAJEC_SLAG)
  ELSE
    CALL SC2PRG(IBL,PTRAJEC_OOPS%PHYS,ZTRAJEC_PHYS)
    CALL SC2PRG(IBL,PTRAJEC_OOPS%SLAG,ZTRAJEC_SLAG)
  ENDIF

  CALL CPG(YDGEOMETRY,YLCPG_BNDS,YLCPG_OPTS,YLCPG_TMP,YLCPG_TND,YLCPG_SL1,YLCPG_SL2,YLCPG_MISC,&
   & YLCPG_GPAR,YLCPG_PHY0,YLCPG_PHY9,YLMF_PHYS,&
   & YLCPG_DDH,YLCPG_DYN0,YLCPG_DYN9,&
   & YLMF_PHYS_SURF,YDVARS,YDMODEL,YDFIELDS,&
   & LLCONFX,LD_DFISTEP,LLFSTEP,LLDIAB,LLSLPHY,LLUSEPB1,&
   & ZDT,ZDTPHY,ZTE,ZBETADT,YDSL,PGFLSLP(:,:,:,IBL),PSAVTEND(:,:,:,IBL),&
   & PGMVTNDHD_DDH(:,:,:,IBL),PGFLTNDHD_DDH(:,:,:,IBL),PGPSDT2D(:,:,IBL),PSD_PF(:,:,:,IBL),&
   & PGMV(:,:,:,IBL),PGMVS(:,:,IBL),PGFL(:,:,:,IBL),PGFLPC(:,:,:,IBL),PGFLPT(:,:,:,IBL),&
   & PSD_XA(:,:,:,IBL),&
   & PGMVTNDSI_DDH(:,:,:,IBL),&
   & IWSETTLOFF(:,IBL),PB1,PGMVT1(:,:,:,IBL),PGMVT1S(:,:,IBL),PGFLT1(:,:,:,IBL),PEXTRA(:,:,:,IBL),&
   & PGMVTNDSL_DDH(:,:,:,IBL),PGFLTNDSL_DDH(:,:,:,IBL),ZTRAJEC_PHYS,ZTRAJEC_SLAG,YDDDH, CDPART=CLPART)

  CALL YDVARS%RESET_ARRAYS()
ENDDO

!$OMP END PARALLEL DO

  ENDIF

ENDDO

CALL GSTATS(1025,1)

IF (LHOOK) CALL DR_HOOK('CPG_DRV:EXIT',0,ZHOOK_HANDLE_EXIT)

CALL YLCPG_DYN0%FINAL
CALL YLCPG_DYN9%FINAL
CALL YLCPG_PHY0%FINAL
CALL YLCPG_PHY9%FINAL
CALL YLMF_PHYS_SURF%FINAL
CALL YLMF_PHYS%FINAL
CALL YLCPG_TND%FINAL
CALL YLCPG_MISC%FINAL
CALL YLCPG_TMP%FINAL
CALL YLCPG_DDH%FINAL
CALL YLCPG_SL1%FINAL
CALL YLCPG_SL2%FINAL
CALL YLCPG_GPAR%FINAL

IF (LHOOK) CALL DR_HOOK('CPG_DRV:EXIT',1,ZHOOK_HANDLE_EXIT)

IF (LSETTLSVF.AND.NSTEP>NSTART.AND.LSETFSTAT) THEN
  ISETTLOFF=0
  DO JLEV=1,NFLEVSF
    DO IBL=1,NGPBLKS
      ISETTLOFF(JLEV)=ISETTLOFF(JLEV)+IWSETTLOFF(JLEV,IBL)
    ENDDO
  ENDDO
 
  IF (NPROC>1) THEN
    CALL MPL_ALLREDUCE( ISETTLOFF,'SUM',LDREPROD=.FALSE.,CDSTRING='CPG_DRV:')
  ENDIF

  IF (MYPROC == 1) THEN
    DO JLEV=1,NFLEVSF
      WRITE(NULOUT,*) '% of pts extrapolation is off at lev:',JLEV,'is:',100.*ISETTLOFF(JLEV)/NGPTOTG
    ENDDO
  ENDIF
ENDIF

! global characteristics for LMIXETTLS scheme
! temporarily ISETTLOFF is used
IF (LMIXETTLS.AND.NSTEP>NSTART) THEN
  IF (LRPLANE) THEN

    ING = NDGUXG * NDLON
    ! accumulate characteristics for all NPROMA packets
    ISETTLOFF=0
    DO JLEV=1,NFLEVG
      DO IBL=1,NGPBLKS
        ISETTLOFF(JLEV)=ISETTLOFF(JLEV)+IWSETTLOFF(JLEV,IBL)
      ENDDO
    ENDDO
 
    ! global sum over processors
    IF (NPROC>1) THEN
      CALL MPL_ALLREDUCE( ISETTLOFF,'SUM',LDREPROD=.FALSE.,CDSTRING='CPG_DRV:')
    ENDIF

    ! compute on all processors
    IF (NCURRENT_ITER == 0) THEN
      DO JLEV=1,NFLEVG
        IOFF    = JLEV
        ZPD_STAT= REAL(ISETTLOFF(IOFF),JPRB)/REAL(ING,JPRB) * 100.0_JPRB
      ENDDO
    ENDIF

    ! write only on proc 1
    IF (MYPROC == 1) THEN
      DO JLEV=1,NFLEVG
        IOFF    = JLEV
        ZPD_STAT= REAL(ISETTLOFF(IOFF),JPRB)/REAL(ING,JPRB) * 100.0_JPRB
        IF (LMIXETTLS_PRINT.AND.(NCURRENT_ITER==0)) THEN
          WRITE(NULOUT,'(A,2(I5,";"),F15.8)') 'CPG_DRV STATISTICS: ', NSTEP, JLEV, ZPD_STAT
        ENDIF
      ENDDO
    ENDIF

  ELSE
    CALL ABOR1('CPG_DRV: GLOBAL GEOMETRY NOT YET CODED FOR MIXED TTL SCHEME.')
  ENDIF
ENDIF

IF (LMUSCLFA) CALL LFAFER(NMUSCLFA)

!     ------------------------------------------------------------------
END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('CPG_DRV',1,ZHOOK_HANDLE)
END SUBROUTINE CPG_DRV

