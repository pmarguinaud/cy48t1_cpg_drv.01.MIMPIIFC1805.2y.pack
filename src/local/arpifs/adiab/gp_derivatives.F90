SUBROUTINE GP_DERIVATIVES(YDGEOMETRY,YDFIELDS,YGFL)

!**** *GP_DERIVATIVES* - COMPUTES GRID-POINT DERIVATIVES FOR GFL FIELDS

!     PURPOSE.  

!**   INTERFACE.
!     ----------
!        *CALL* *GP_DERIVATIVES(..)*

!        EXPLICIT ARGUMENTS
!        --------------------


!        IMPLICIT ARGUMENTS :   
!        --------------------   

!     METHOD.
!     -------
!        SEE DOCUMENTATION

!     EXTERNALS.     NONE.
!     ----------

!     REFERENCE.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     AUTHOR.
!     -------
!      Mats Hamrud AND Willem Deconinck  *ECMWF*
!      ORIGINAL : Nov 2015

!     MODIFICATIONS.
!     --------------
!     ------------------------------------------------------------------

USE YOM_YGFL      , ONLY : TYPE_GFLD
USE PARKIND1      , ONLY : JPIM, JPRB
USE YOMHOOK       , ONLY : LHOOK, DR_HOOK
USE YOMDYNA       , ONLY : LGRADGP
#ifdef WITH_ATLAS
USE YOM_ATLAS_IFS , ONLY : LATLAS_MESH
USE ATLAS_MODULE  , ONLY : ATLAS_FIELD, ATLAS_MESH_NODES, ATLAS_FUNCTIONSPACE_NODECOLUMNS, &
                         & ATLAS_REAL
#endif
USE FIELDS_MOD    , ONLY : FIELDS
USE TYPE_GEOMETRY , ONLY : GEOMETRY

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY), INTENT(IN)    :: YDGEOMETRY
TYPE(FIELDS),   INTENT(INOUT) :: YDFIELDS
TYPE(TYPE_GFLD),INTENT(IN)    :: YGFL

!     ------------------------------------------------------------------

REAL(KIND=JPRB) :: ZHOOK_HANDLE

#ifdef WITH_ATLAS

INTEGER(KIND=JPIM) :: JLEV, JGFL,IP,JL,IROF,IBL,IGPFDERS,INODE_SIZE,IOFF
INTEGER(KIND=JPIM),ALLOCATABLE :: IPA(:)
REAL(KIND=JPRB), POINTER :: ZVAR(:,:)
REAL(KIND=JPRB), POINTER :: ZGRAD(:,:,:)
LOGICAL   , POINTER :: LLIS_GHOST(:)                                  
TYPE(ATLAS_FIELD) :: VARFIELD
TYPE(ATLAS_FIELD) :: GRADFIELD
TYPE(ATLAS_FIELD) :: GHOSTFIELD
TYPE(ATLAS_MESH_NODES) :: NODES
TYPE(ATLAS_FUNCTIONSPACE_NODECOLUMNS) :: NODE_COLUMNS

!     ------------------------------------------------------------------
#include "fv_gradient.intfb.h"
#include "gpnorm3.intfb.h"
#endif
IF (LHOOK) CALL DR_HOOK('GP_DERIVATIVES',0,ZHOOK_HANDLE)

#ifdef WITH_ATLAS
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, &
 & YDATLAS=>YDGEOMETRY%YRATLAS, &
 & YDGMV=>YDFIELDS%YRGMV,YDGFL=>YDFIELDS%YRGFL)
ASSOCIATE(NPROMA=>YDDIM%NPROMA, NFLEVG=>YDDIMV%NFLEVG, &
 & NGPTOT=>YDGEM%NGPTOT ,  &
 & NUMFLDS=>YGFL%NUMFLDS, YCOMP=>YGFL%YCOMP, YQ=>YGFL%YQ, NDIM=>YGFL%NDIM,  PGFL=>YDGFL%GFL, &
 & YT0=>YDGMV%YT0, NDIMGMV=>YDGMV%NDIMGMV, PGMV=>YDGMV%GMV, PGMVS=>YDGMV%GMVS, &
 & MESH=>YDATLAS%MESH, NABLA=>YDATLAS%NABLA, FVM=>YDATLAS%FVM)
!     ------------------------------------------------------------------

IGPFDERS = 0
DO JGFL=1,NUMFLDS
  IF(YCOMP(JGFL)%LCDERS .AND. YCOMP(JGFL)%LGP) IGPFDERS = IGPFDERS+NFLEVG
ENDDO
IF(LGRADGP) IGPFDERS=IGPFDERS+NFLEVG+1

IF(IGPFDERS > 0 .AND. .NOT. LATLAS_MESH) CALL ABOR1('GP_DERIVATIVES: LATLAS_MESH=.F.')

IF(IGPFDERS > 0) THEN
  NODE_COLUMNS = FVM%NODE_COLUMNS()
  NODES        = MESH%NODES()

  INODE_SIZE = NODES%SIZE()
  GHOSTFIELD = NODES%GHOST()
  CALL GHOSTFIELD%DATA(LLIS_GHOST)
  ALLOCATE(IPA(INODE_SIZE))
  IP = 0
  DO JL=1,INODE_SIZE
    IF(.NOT. LLIS_GHOST(JL)) THEN
      IP = IP+1
      IPA(JL) = IP
    ENDIF
  ENDDO
  VARFIELD  = NODE_COLUMNS%CREATE_FIELD("var", ATLAS_REAL(JPRB),IGPFDERS)
  GRADFIELD = NODE_COLUMNS%CREATE_FIELD("grad",ATLAS_REAL(JPRB),IGPFDERS,[2])
  CALL VARFIELD%DATA(ZVAR)
  CALL GRADFIELD%DATA(ZGRAD)
  CALL GSTATS(1099,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JL,IP,IBL,IROF,JLEV,IOFF)
  DO JL=1,INODE_SIZE
    IOFF = 0
    IF(.NOT. LLIS_GHOST(JL)) THEN
      IP = IPA(JL)
      IBL = (IP-1)/NPROMA+1
      IROF = IP-(IBL-1)*NPROMA
      IF(LGRADGP) THEN
        DO JLEV=1,NFLEVG
          ZVAR(IOFF+JLEV,JL) = PGMV(IROF,JLEV,YT0%MT,IBL)
        ENDDO
        IOFF = IOFF+NFLEVG
        ZVAR(IOFF+1,JL) = PGMVS(IROF,YT0%MSP,IBL)
        IOFF = IOFF+1
      ENDIF
      DO JGFL=1,NUMFLDS
        IF(YCOMP(JGFL)%LCDERS .AND. YCOMP(JGFL)%LGP) THEN
          DO JLEV=1,NFLEVG
            ZVAR(IOFF+JLEV,JL) = PGFL(IROF,JLEV,YCOMP(JGFL)%MP,IBL)
          ENDDO
          IOFF = IOFF+NFLEVG
        ENDIF
      ENDDO
    ENDIF
  ENDDO
!$OMP END PARALLEL DO
  CALL GSTATS(1099,1)
  CALL GSTATS(538,0)
  CALL NODE_COLUMNS%HALO_EXCHANGE(VARFIELD)
  CALL GSTATS(538,1)
      
      ! Compute the gp_gradient
  CALL GSTATS(1098,0)
!      CALL NABLA%GRADIENT(VARFIELD,GRADFIELD)
  CALL FV_GRADIENT(YDGEOMETRY,ZVAR,ZGRAD)
  CALL GSTATS(1098,1)
 
  CALL GSTATS(1100,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JL,IP,IBL,IROF,JLEV,IOFF)
  DO JL=1,INODE_SIZE
    IOFF = 0
    IF(.NOT. LLIS_GHOST(JL)) THEN
      IP = IPA(JL)
      IBL = (IP-1)/NPROMA+1
      IROF = IP-(IBL-1)*NPROMA
      IF(LGRADGP) THEN
        DO JLEV=1,NFLEVG
          PGMV(IROF,JLEV,YT0%MTL,IBL) = ZGRAD(1,IOFF+JLEV,JL)
          PGMV(IROF,JLEV,YT0%MTM,IBL) = ZGRAD(2,IOFF+JLEV,JL)
        ENDDO
        IOFF = IOFF+NFLEVG
        PGMVS(IROF,YT0%MSPL,IBL) = ZGRAD(1,IOFF+1,JL)
        PGMVS(IROF,YT0%MSPM,IBL) = ZGRAD(2,IOFF+1,JL)
        IOFF = IOFF+1
      ENDIF
      DO JGFL=1,NUMFLDS
        IF(YCOMP(JGFL)%LCDERS .AND. YCOMP(JGFL)%LGP) THEN
          DO JLEV=1,NFLEVG
            PGFL(IROF,JLEV,YCOMP(JGFL)%MPL,IBL) = ZGRAD(1,IOFF+JLEV,JL)
            PGFL(IROF,JLEV,YCOMP(JGFL)%MPM,IBL) = ZGRAD(2,IOFF+JLEV,JL)
          ENDDO
          IOFF = IOFF+NFLEVG
        ENDIF
      ENDDO
    ENDIF
  ENDDO
!$OMP END PARALLEL DO
  CALL GSTATS(1100,1)
  DO JGFL=1,NUMFLDS
    IF(YCOMP(JGFL)%LCDERS .AND. YCOMP(JGFL)%LGP) THEN
      CALL GPNORM3(YDGEOMETRY,PGFL,NDIM,YCOMP(JGFL)%MPL,'E-W der')
      CALL GPNORM3(YDGEOMETRY,PGFL,NDIM,YCOMP(JGFL)%MPM,'N-S der')
    ENDIF
  ENDDO

  CALL VARFIELD%FINAL()
  CALL GRADFIELD%FINAL()
  IF(LGRADGP) THEN
    VARFIELD = NODE_COLUMNS%CREATE_FIELD("var",ATLAS_REAL(JPRB),NFLEVG)
    GRADFIELD = NODE_COLUMNS%CREATE_FIELD("grad",ATLAS_REAL(JPRB),NFLEVG,[2])
    CALL VARFIELD%DATA(ZVAR)
    CALL GRADFIELD%DATA(ZGRAD)
    DO JL=1,INODE_SIZE
      IF(.NOT. LLIS_GHOST(JL)) THEN
        IP = IPA(JL)
        IBL = (IP-1)/NPROMA+1
        IROF = IP-(IBL-1)*NPROMA
        
        DO JLEV=1,NFLEVG
          ZGRAD(1,JLEV,JL) = PGMV(IROF,JLEV,YT0%MU,IBL)
          ZGRAD(2,JLEV,JL) = PGMV(IROF,JLEV,YT0%MV,IBL)
        ENDDO
      ENDIF
    ENDDO
    CALL NODE_COLUMNS%HALO_EXCHANGE(GRADFIELD)
    CALL NABLA%DIVERGENCE(GRADFIELD,VARFIELD)
    DO JL=1,INODE_SIZE
      IF(.NOT. LLIS_GHOST(JL)) THEN
        IP = IPA(JL)
        IBL = (IP-1)/NPROMA+1
        IROF = IP-(IBL-1)*NPROMA
        
        DO JLEV=1,NFLEVG
          PGMV(IROF,JLEV,YT0%MDIV,IBL) = ZVAR(JLEV,JL)
        ENDDO
      ENDIF
    ENDDO
    CALL VARFIELD%FINAL()
    CALL GRADFIELD%FINAL()
  ENDIF
  CALL GHOSTFIELD%FINAL()
  CALL NODE_COLUMNS%FINAL()
  CALL NODES%FINAL()
ENDIF

!     ------------------------------------------------------------------

END ASSOCIATE
END ASSOCIATE
#endif

IF (LHOOK) CALL DR_HOOK('GP_DERIVATIVES',1,ZHOOK_HANDLE)
END SUBROUTINE GP_DERIVATIVES
