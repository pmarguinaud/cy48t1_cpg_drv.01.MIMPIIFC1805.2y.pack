SUBROUTINE LAPINEB(YDGEOMETRY,YDGMV,&
 ! --- INPUT ------------------------------------------------------------------
 & YDMODEL,KFLDSLB2,KST,KPROF,YDSL,KSTGLO,LDSLPHY,&
 & KIBL,KNOWENO,&
 & KL0,KLH0,PLSCAW,PRSCAW,KL0H,PLSCAWH,PRSCAWH,&
 & PUF,PVF,&
 & PB1,PQ,&
 ! --- INPUT/OUTPUT -----------------------------------------------------------
 & PSCO,PCCO,&
 & PB2,PGMVT1,PGMVT1S,PGFLT1,PGFLPC,PGMVTNDSL,PGFLTNDSL,PGMVTNDSI,&
 ! --- OUTPUT -----------------------------------------------------------------
 & PUP9,PVP9,PTP9,PGFLP9)

!**** *LAPINEB* - semi-LAgrangian scheme(Interpolation):
!                Interface subroutine for interpolations and lagrangian
!                trends. (Programme INterface d'Ensemble).

!     Purpose.
!     --------
!       Grid point calculations in dynamics.

!       Does the interpolations at the origin point O of the SL-trajectory.
!       Then adds the interpolated quantities of the RHS of equations to
!       yield a provisional value for X(t+dt) for each prognostic variable X.

!       Abbreviation "vwv" stands for "vertical wind variable".

!**   Interface.
!     ----------
!        *CALL* *LAPINEB(.....)

!        Explicit arguments :
!        --------------------
!        INPUT:
!          KFLDSLB2    - second dimension of PB2 (must be >= NFLDSLB2)
!          KST         - first element where computations are performed.
!          KPROF       - depth of work.
!          YDSL        - SL_STRUCT definition
!          KSTGLO      - global offset into nproma buffer.
!          LDSLPHY     - split physics in semi lagrangian mode.
!          KIBL        - index into YRCSGEOM/YRGSGEOM instances in YDGEOMETRY 
!          KL0         - index of the four western points
!                        of the 16 points interpolation grid.
!          KLH0        - second value of index of the four western points
!                        of the 16 points interpolation grid if needed.
!          PLSCAW      - linear weights (distances) for interpolations.
!          PRSCAW      - non-linear weights for interpolations.
!          KL0H        - half-level KL0
!          PLSCAWH     - linear weights (distances) for interpolations at half levels.
!          PRSCAWH     - non-linear weights for interpolations at half levels.
!          PUF,PVF     - U-comp and V-comp of wind at the medium point necessary
!                        to find the positions of the medium and origin points,
!                        in a local repere linked to computational sphere.
!                        Used in this routine for l2tlff=T.
!          PB1         - "SLBUF1" buffer for interpolations.
!          PQ          - moisture at "t".

!        INPUT/OUTPUT:
!          PSCO        - information about geographic position of interpol. point.
!          PCCO        - information about comput. space position of interpol. point.
!          PB2         - "SLBUF2" buffer.
!          PGMVT1      - t+dt GMV (upper air) variables.
!          PGMVT1S     - t+dt GMVS (surface) variables.
!          PGFLT1      - t+dt unified_treatment grid-point fields.
!          PGFLPC      - to store PC scheme quantities for GFL.
!          PGMVTNDSL   - cf. GMVTNDSL_DDH in YOMGPDDH
!          PGFLTNDSL   - cf. GFLTNDSL_DDH in YOMGPDDH
!          PGMVTNDSI   - cf. GMVTNDSI_DDH in YOMGPDDH

!        OUTPUT:
!          PUP9        - Interpolated quantity at O in U-wind eqn
!                        for split physics (if LDSLPHY=.T. only).
!          PVP9        - Interpolated quantity at O in V-wind eqn
!                        for split physics (if LDSLPHY=.T. only).
!          PTP9        - Interpolated quantity at O in T eqn
!                        for split physics (if LDSLPHY=.T. only).
!          PGFLP9      - Interpolated quantity at O in unified_treatment
!                        grid-point fields
!                        for split physics (if LDSLPHY=.T. only).

!        Implicit arguments :
!        --------------------

!     Method.
!     -------

!     Externals.
!     ----------
!      Called by CALL_SL.

!     Reference.
!     ----------
!        ARPEGE documentation about semi-Lagrangian scheme.

!     Author.
!     -------
!      K. YESSAD after the subroutine CPLGDY2 written by
!      Maurice IMBARD   METEO FRANCE/EERM/CRMD
!      Original : JUNE 1991.

! Modifications
! -------------
!   K. Yessad Nov 2009: use ZGMV9 and ZGMV9_SI.
!   K. Yessad (Nov 2009): prune lpc_old.
!   K. Yessad (Jan 2011): introduce INTDYN_MOD structures.
!   G. Mozdzynski (Jan 2011): OOPS cleaning, use of derived type SL_STRUCT
!   K. Yessad (Dec 2011): Use GPHPRE.
!   M. Diamantakis (Jun 2012): extra argument for quasi-monotone mass fixer
!   G. Mozdzynski (May 2012): further cleaning
!   P. Marguinaud (Jan 2013): Move initialisation of MGPGMV* in lapineb_setup.F90
!   M. Diamantakis (Feb 2013): Remove PCUB due to simplification of mass fixers
!   T. Wilhelmsson (Sept 2013) Geometry and setup refactoring.
!   K. Yessad (July 2014): Rename some variables.
!   K. Yessad (Dec 2016): Prune obsolete options.
!   K. Yessad (March 2017): simplify level numbering in interpolator.
!   K. Yessad (June 2017): Introduce NHQE model.
!   J. Vivoda and P. Smolikova (Sep 2017): new options for VFE-NH.
!   K. Yessad (Feb 2018): remove deep-layer formulations.
!   K. Yessad (Apr 2018): introduce key L_RDRY_VD (ensure consistent definition of "dver" everywhere).
!   M. Diamantakis (June 2018): Don't update GFL variable advected on Atlas grid 
!   J. Vivoda (July 2018): LSETTLS with LPC_CHEAP.
!   F. Vana  20-Feb-2019: Vertical quintic interpolation
!   F. Voitus (Aug 2019): NVDVAR=5.
! End Modifications
!     ------------------------------------------------------------------

USE TYPE_MODEL   , ONLY : MODEL
USE GEOMETRY_MOD , ONLY : GEOMETRY
USE YOMGMV       , ONLY : TGMV
USE PARKIND1     , ONLY : JPIM, JPRB
USE YOMCST       , ONLY : RPI, ROMEGA, RA, RD
USE YOMSTA       , ONLY : RTSUR
USE YOMCT0       , ONLY : LNHDYN, LRPLANE, LNHEE
USE YOMCVER      , ONLY : LVERTFE, LVFE_GW

USE YOMHOOK      , ONLY : LHOOK, DR_HOOK
USE YOMGPPCB     , ONLY : GPPCBUF
USE EINT_MOD     , ONLY : SL_STRUCT

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)    ,INTENT(IN)    :: YDGEOMETRY
TYPE(TGMV)        ,INTENT(INOUT) :: YDGMV
TYPE(MODEL)       ,INTENT(IN)    :: YDMODEL
INTEGER(KIND=JPIM),INTENT(IN)    :: KFLDSLB2
INTEGER(KIND=JPIM),INTENT(IN)    :: KST
INTEGER(KIND=JPIM),INTENT(IN)    :: KPROF
TYPE(SL_STRUCT)   ,INTENT(IN)    :: YDSL
INTEGER(KIND=JPIM),INTENT(IN)    :: KSTGLO
LOGICAL           ,INTENT(IN)    :: LDSLPHY
INTEGER(KIND=JPIM),INTENT(IN)    :: KIBL
INTEGER(KIND=JPIM),INTENT(IN)    :: KNOWENO(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
INTEGER(KIND=JPIM),INTENT(IN)    :: KL0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,0:3)
INTEGER(KIND=JPIM),INTENT(IN)    :: KLH0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,0:3)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLSCAW(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_DYN%YYTLSCAW%NDIM)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSCAW(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_DYN%YYTRSCAW%NDIM)
INTEGER(KIND=JPIM),INTENT(IN)    :: KL0H(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,0:3)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLSCAWH(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_DYN%YYTLSCAWH%NDIM)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSCAWH(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_DYN%YYTRSCAWH%NDIM)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PUF(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PVF(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PB1(YDSL%NASLB1,YDMODEL%YRML_DYN%YRPTRSLB1%NFLDSLB1)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PQ(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSCO(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_DYN%YYTSCO%NDIM)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCCO(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_DYN%YYTCCO%NDIM)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PB2(YDGEOMETRY%YRDIM%NPROMA,KFLDSLB2)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGMVT1(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGMV%YT1%NDIM)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGMVT1S(YDGEOMETRY%YRDIM%NPROMA,YDGMV%YT1%NDIMS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGFLT1(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NDIM1)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGFLPC(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NDIMPC)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGMVTNDSL(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YRDIMF%NFTHER+2)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGFLTNDSL(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NUMFLDS)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGMVTNDSI(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_DIAG%YRMDDH%NDIMSIGMV)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PUP9(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PVP9(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PTP9(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGFLP9(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NUMFLDS)
!     ------------------------------------------------------------------
INTEGER(KIND=JPIM) :: IHVIO, IVDVAR
INTEGER(KIND=JPIM) :: JLEV,  JROF,  JGFL

LOGICAL :: LL2TLFFO
LOGICAL :: LLCOMPUTE_OMVAK_O
LOGICAL :: LLUPDATE_NHX
LOGICAL :: LLDER
LOGICAL :: LLSLINLC2

! * interpolated quantities arrays.
REAL(KIND=JPRB) :: ZUT1(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG),ZVT1(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB) :: ZUZ9(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG),ZVZ9(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB) :: ZSPT1(YDGEOMETRY%YRDIM%NPROMA,0:YDGEOMETRY%YRDIMV%NFLEVG+1),&
 & ZSPTO(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG+1)
REAL(KIND=JPRB) :: ZDP9(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB) :: ZGFL9(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDMODEL%YRML_GCONF%YGFL%NUMFLDS)
REAL(KIND=JPRB) :: ZC9(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG),ZC9_SI(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB) :: ZC9_NL(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
! * interpolated quantities arrays for NH:
REAL(KIND=JPRB),ALLOCATABLE :: ZGMV9(:,:,:),ZGMV9_SI(:,:,:),ZGMV9_NL(:,:,:)
! * interpolated quantities for physics tendencies:
REAL(KIND=JPRB) ,ALLOCATABLE :: ZUP9(:,:), ZVP9(:,:)

! * grad(orog) used only for NH model with lgwadv=true or lrdbbc=true:
REAL(KIND=JPRB),ALLOCATABLE :: ZOROGL_SR(:)
REAL(KIND=JPRB),ALLOCATABLE :: ZOROGM_SR(:)
! * surface wind when lgwadv=true or lrdbbc=true (NH):
REAL(KIND=JPRB),ALLOCATABLE :: ZUST1(:)
REAL(KIND=JPRB),ALLOCATABLE :: ZVST1(:)
! * used only for NH model with lgwadv=true:
REAL(KIND=JPRB),ALLOCATABLE :: ZVWVT1(:,:),ZVWVT1S(:)
REAL(KIND=JPRB),ALLOCATABLE :: ZSVDT1(:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZNHYT1(:,:)
! * interpolated quantities arrays for diagnostic BBC in NH:
REAL(KIND=JPRB)  :: ZDBBC9(YDGEOMETRY%YRDIM%NPROMA)
REAL(KIND=JPRB)  :: ZDPHI9(YDGEOMETRY%YRDIM%NPROMA)
REAL(KIND=JPRB)  :: ZGWS9(YDGEOMETRY%YRDIM%NPROMA)
! * other quantities (declared in alphabetical order).
REAL(KIND=JPRB) :: ZGMDTX(YDGEOMETRY%YRDIM%NPROMA)
REAL(KIND=JPRB) :: ZGMDTY(YDGEOMETRY%YRDIM%NPROMA)
REAL(KIND=JPRB),POINTER :: ZGPPC(:,:)
REAL(KIND=JPRB) :: ZINEZV(YDGEOMETRY%YRDIM%NPROMA)
REAL(KIND=JPRB),ALLOCATABLE :: ZP2(:,:),ZQ2(:,:)
REAL(KIND=JPRB) :: ZVWEI(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG) ! weight for vertical integrations.
! * versions of RT
REAL(KIND=JPRB) :: ZR1(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)  ! Moist R at t+dt
REAL(KIND=JPRB) :: ZRT1(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG) ! Rd * T(t+dt) or R * T(t+dt)

REAL(KIND=JPRB) :: ZCOPHI
REAL(KIND=JPRB) :: ZDEPI
REAL(KIND=JPRB) :: ZDGUN
REAL(KIND=JPRB) :: ZDGUX
REAL(KIND=JPRB) :: ZDLUN
REAL(KIND=JPRB) :: ZDLUX
REAL(KIND=JPRB) :: ZDSTRET
REAL(KIND=JPRB) :: ZPHI
REAL(KIND=JPRB) :: ZPP
REAL(KIND=JPRB) :: ZPP1
REAL(KIND=JPRB) :: ZPP9
REAL(KIND=JPRB) :: ZQQ
REAL(KIND=JPRB) :: ZQQ1
REAL(KIND=JPRB) :: ZQQ9
REAL(KIND=JPRB) :: ZSINX
REAL(KIND=JPRB) :: ZTXO
REAL(KIND=JPRB) :: ZTYO
REAL(KIND=JPRB) :: ZCMSLP
REAL(KIND=JPRB) :: ZHOOK_HANDLE

!     ------------------------------------------------------------------

#include "abor1.intfb.h"
#include "elarche.intfb.h"
#include "gnhgw2svd.intfb.h"
#include "gpuvs.intfb.h"
#include "gprcp_pgfl.intfb.h"
#include "gnhy.intfb.h"
#include "lacone.intfb.h"
#include "larche.intfb.h"
#include "larcinb.intfb.h"
#include "larcinhb.intfb.h"
#include "verdisint.intfb.h"

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('LAPINEB',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, &
 &   YDCSGEOM=>YDGEOMETRY%YRCSGEOM(KIBL), YDGSGEOM=>YDGEOMETRY%YRGSGEOM(KIBL),  YDOROG=>YDGEOMETRY%YROROG(KIBL), &
 &  YDVAB=>YDGEOMETRY%YRVAB, YDVETA=>YDGEOMETRY%YRVETA, YDVFE=>YDGEOMETRY%YRVFE, YDEGSL=>YDGEOMETRY%YREGSL, &
 & YDEGEO=>YDGEOMETRY%YREGEO, YDDYN=>YDMODEL%YRML_DYN%YRDYN,YDPTRSLB1=>YDMODEL%YRML_DYN%YRPTRSLB1, &
 & YDPTRSLB2=>YDMODEL%YRML_DYN%YRPTRSLB2,YDMDDH=>YDMODEL%YRML_DIAG%YRMDDH,  &
 & YDRIP=>YDMODEL%YRML_GCONF%YRRIP,YGFL=>YDMODEL%YRML_GCONF%YGFL, &
 & YDEPHY=>YDMODEL%YRML_PHY_EC%YREPHY,YDDIMF=>YDMODEL%YRML_GCONF%YRDIMF, &
 & YDPTRGPPC=>YDMODEL%YRML_DYN%YRPTRGPPC,YDPHY=>YDMODEL%YRML_PHY_MF%YRPHY,YDTCCO=>YDMODEL%YRML_DYN%YYTCCO, &
 & YDTSCO=>YDMODEL%YRML_DYN%YYTSCO)

ASSOCIATE(NDIM1=>YGFL%NDIM1, NDIMPC=>YGFL%NDIMPC, NUMFLDS=>YGFL%NUMFLDS, &
 & YCOMP=>YGFL%YCOMP, YCVGQ=>YGFL%YCVGQ, YQ=>YGFL%YQ, &
 & NPROMA=>YDDIM%NPROMA, &
 & NFTHER=>YDDIMF%NFTHER, &
 & NFLEN=>YDDIMV%NFLEN, NFLEVG=>YDDIMV%NFLEVG, NFLSA=>YDDIMV%NFLSA, &
 & L2TLFF=>YDDYN%L2TLFF, LADVF=>YDDYN%LADVF, &
 & NCURRENT_ITER=>YDDYN%NCURRENT_ITER, NSITER=>YDDYN%NSITER, NVLAG=>YDDYN%NVLAG, &
 & RCMSLP0=>YDDYN%RCMSLP0, RW2TLFF=>YDDYN%RW2TLFF, &
 & EDELX=>YDEGEO%EDELX, EDELY=>YDEGEO%EDELY, &
 & LAGPHY=>YDEPHY%LAGPHY, LEPHYS=>YDEPHY%LEPHYS, &
 & NSTTYP=>YDGEM%NSTTYP, RC2M1=>YDGEM%RC2M1, RC2P1=>YDGEM%RC2P1, &
 & RLOCEN=>YDGEM%RLOCEN, RMUCEN=>YDGEM%RMUCEN, RSTRET=>YDGEM%RSTRET, &
 & YGP=>YDGMV%YGP, YT1=>YDGMV%YT1, &
 & NDIMSIGMV=>YDMDDH%NDIMSIGMV, &
 & MGPPCF_BBC=>YDPTRGPPC%MGPPCF_BBC, MGPPCF_CP=>YDPTRGPPC%MGPPCF_CP, &
 & MGPPCF_GFLP=>YDPTRGPPC%MGPPCF_GFLP, &
 & MGPPCF_NHX=>YDPTRGPPC%MGPPCF_NHX, MGPPCF_SP=>YDPTRGPPC%MGPPCF_SP, &
 & MGPPCF_SPD=>YDPTRGPPC%MGPPCF_SPD, MGPPCF_SVD=>YDPTRGPPC%MGPPCF_SVD, &
 & MGPPCF_T=>YDPTRGPPC%MGPPCF_T, MGPPCF_TP=>YDPTRGPPC%MGPPCF_TP, &
 & MGPPCF_U=>YDPTRGPPC%MGPPCF_U, MGPPCF_UP=>YDPTRGPPC%MGPPCF_UP, &
 & MGPPCF_V=>YDPTRGPPC%MGPPCF_V, MGPPCF_VP=>YDPTRGPPC%MGPPCF_VP, &
 & NFGPPC=>YDPTRGPPC%NFGPPC, &
 & NFLDSLB1=>YDPTRSLB1%NFLDSLB1, &
 & MSLB2DBBC1=>YDPTRSLB2%MSLB2DBBC1, MSLB2DPHI1=>YDPTRSLB2%MSLB2DPHI1, &
 & MSLB2GDW=>YDPTRSLB2%MSLB2GDW, MSLB2GWF=>YDPTRSLB2%MSLB2GWF, &
 & MSLB2GWS=>YDPTRSLB2%MSLB2GWS, MSLB2PDSI=>YDPTRSLB2%MSLB2PDSI, &
 & MSLB2SPSI=>YDPTRSLB2%MSLB2SPSI, MSLB2TSI=>YDPTRSLB2%MSLB2TSI, &
 & MSLB2USI=>YDPTRSLB2%MSLB2USI, &
 & MSLB2VDSI=>YDPTRSLB2%MSLB2VDSI, MSLB2VSI=>YDPTRSLB2%MSLB2VSI, &
 & RTDT=>YDRIP%RTDT, &
 & LMPHYS=>YDPHY%LMPHYS)
!     ------------------------------------------------------------------

!*       1.    PRELIMINARY ALLOCATIONS AND INITIALISATIONS:
!              -------------------------------------------

! ky: if LGWADV.AND.ND4SYS==2.AND.NCURRENT_ITER==NSITER, PGMVT1(.,YT1%MNHX)
!     is updated in CPGLAG with a diagnosed value of NHX, so no need to do here
LLUPDATE_NHX=YDMODEL%YRML_DYN%YRDYNA%LNHX.AND.(YDMODEL%YRML_DYN%YRDYNA%NVDVAR == 4 .OR. YDMODEL%YRML_DYN%YRDYNA%NVDVAR == 5).AND.(.NOT.YDMODEL%YRML_DYN%YRDYNA%LGWADV.OR.(YDMODEL%YRML_DYN%YRDYNA%ND4SYS==2.AND.NCURRENT_ITER<NSITER))

ZDEPI=2.0_JPRB*RPI

ZDSTRET=2.0_JPRB*RSTRET

ALLOCATE (ZGMV9(NPROMA,NFLEVG,YGP%NDIM))
ZGMV9(:,:,:)=0.0_JPRB

! Following arrays must be allocated because they are passed to subroutine(s)
ALLOCATE (ZGMV9_SI(NPROMA,NFLEVG,YGP%NDIM))
ALLOCATE (ZGMV9_NL(NPROMA,NFLEVG,YGP%NDIM))
ALLOCATE (ZUP9(NPROMA,NFLEVG))
ALLOCATE (ZVP9(NPROMA,NFLEVG))

IF(YDMODEL%YRML_DYN%YRDYNA%LSLINL) THEN
  ZGMV9_SI(:,:,:)=0.0_JPRB
ENDIF

IF(YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.YDMODEL%YRML_DYN%YRDYNA%LSETTLS) THEN
  ZGMV9_NL(:,:,:)=0.0_JPRB
ENDIF

IF( LDSLPHY ) THEN
  ZUP9(:,:)=0.0_JPRB
  ZVP9(:,:)=0.0_JPRB
ENDIF

IF (YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP) THEN
  ZGPPC => GPPCBUF(:,:,1+(KSTGLO-1)/YDGEOMETRY%YRDIM%NPROMA)
ENDIF

IF (LNHDYN.AND.YDMODEL%YRML_DYN%YRDYNA%LGWADV.AND.YDMODEL%YRML_DYN%YRDYNA%LSLINL.AND.YDMODEL%YRML_DYN%YRDYNA%NGWADVSI==2.AND.NCURRENT_ITER==0) THEN
  ALLOCATE (ZP2(NPROMA,NFLEVG))
  ALLOCATE (ZQ2(NPROMA,NFLEVG))
ENDIF

IHVIO=0
DO JGFL=1,NUMFLDS
  IF(YCOMP(JGFL)%CSLINT == 'LAIHVT      ' .OR.&
     & YCOMP(JGFL)%CSLINT == 'LAIHVTQM    ' .OR.&
     & YCOMP(JGFL)%CSLINT == 'LAIHVTQMH   ' ) THEN  
    IHVIO=1
  ENDIF
ENDDO

LL2TLFFO=L2TLFF.AND.(LMPHYS.OR.LEPHYS).AND.(.NOT.LAGPHY)

IF(LRPLANE) THEN
  ZDLUN=REAL(YDSL%NDLUNG,JPRB)
  ZDLUX=REAL(YDSL%NDLUXG,JPRB)
  ZDGUN=REAL(YDSL%NDGUNG,JPRB)
  ZDGUX=REAL(YDSL%NDGUXG,JPRB)
  DO JROF = KST, KPROF
    ZGMDTX (JROF)=0.5_JPRB*YDGSGEOM%GM(JROF)*RTDT/EDELX
    ZGMDTY (JROF)=0.5_JPRB*YDGSGEOM%GM(JROF)*RTDT/EDELY
    ZINEZV(JROF)=MAX(0.0_JPRB,SIGN(1.0_JPRB,(YDCSGEOM%RINDX(JROF)-ZDLUN)*(&
     & ZDLUX-YDCSGEOM%RINDX(JROF))))*&
     & MAX(0.0_JPRB,SIGN(1.0_JPRB,(YDCSGEOM%RINDY(JROF)-ZDGUN)*(ZDGUX-YDCSGEOM%RINDY(JROF))))
  ENDDO
  ! * Retrieve the origin point coordinates from LAPINEA
  !   for "2 Omega vectorial a k" recalculation.
  PCCO(KST:KPROF,1:NFLEVG,YDTCCO%M_RLON)=PSCO(KST:KPROF,1:NFLEVG,YDTSCO%M_SINLA)
  PCCO(KST:KPROF,1:NFLEVG,YDTCCO%M_RLAT)=PSCO(KST:KPROF,1:NFLEVG,YDTSCO%M_COPHI)
ENDIF

! * [vertical weight]_l = [delta B]_l
DO JLEV=1,NFLEVG
  ZVWEI(KST:KPROF,JLEV)=YDVAB%VDELB(JLEV)
ENDDO

!     ------------------------------------------------------------------

!*       2.    INTERPOLATIONS AT THE ORIGIN POINT AND UPDATE EQNS RHS
!              ------------------------------------------------------

!        2.1   INTERPOLATIONS AND/OR GET/SAVE INTERPOLATED VALUES.

!        2.1.1 INTERPOLATIONS.

IF ( .NOT. (YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.(NCURRENT_ITER > 0)) ) THEN

  ! * Full level quantities:

  CALL LARCINB(YDGEOMETRY,YDGMV,&
   ! --- INPUT ---------------------------------------------------------
   & YDMODEL%YRML_DIAG%YRLDDH,YDMDDH,YDMODEL%YRML_GCONF,YDMODEL%YRML_DYN,&
   & KST,KPROF,YDSL%NASLB1,IHVIO,LDSLPHY,LL2TLFFO,&
   & KL0,KLH0,PLSCAW,PRSCAW,PB1,KNOWENO, &
   ! --- INOUT ---------------------------------------------------------
   & PGMVTNDSL,PGFLTNDSL,PGMVTNDSI,&
   ! --- OUTPUT --------------------------------------------------------
   & ZGMV9,ZGMV9_SI,ZGMV9_NL,ZDP9,ZGFL9,ZC9,ZC9_SI,ZC9_NL,&
   & ZUZ9,ZVZ9,ZUP9,ZVP9,PTP9,PGFLP9,ZDBBC9,ZDPHI9,ZGWS9)

  ! * Half level quantities:
  IF (LNHDYN.AND.YDMODEL%YRML_DYN%YRDYNA%LGWADV.AND.(.NOT.LVFE_GW)) THEN
    ! * Remarks:
    !   - LARCINHB is called only:
    !     - in a finite difference vertical discretisation;
    !     - in a VFE discretisation if (gw) is at half levels and if the
    !       Laplacian term is discretised with FD.
    !     For the other cases of VFE, (gw) is at full levels so the ad-hoc
    !      interpolation should be done under LARCINB.
    CALL LARCINHB(YDGEOMETRY,YDMODEL%YRML_DYN,KST,KPROF,YDSL%NASLB1,KL0H,PLSCAWH,PRSCAWH, &
     & PB1,ZGMV9(1,1,YGP%MSVD),ZGMV9_NL(1,1,YGP%MSVD))
  ENDIF

ENDIF

!        2.1.2 SAVE INTERPOLATED VALUES IN GPPCBUF AND ZGPPC.

IF ( YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.(NCURRENT_ITER == 0) ) THEN
  
  ! buffer initialization with zero
  ZGPPC(:,:)=0.0_JPRB
  
  ! U,V:
  ! - includes rotation matrix.
  ! - if LADVF=T, does not yet include [2 Omega wedge vec(r)] at O
  !   (additional incrementation to be done in part 2.3.2).
  DO JLEV=1,NFLEVG
    !DIR$ IVDEP 
    DO JROF=KST,KPROF 
      ZPP=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)-PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
      ZQQ=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)+PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
      ZGPPC(JROF,MGPPCF_U+JLEV-1)=&
       & ZPP*ZGMV9(JROF,JLEV,YGP%MU)+ZQQ*ZGMV9(JROF,JLEV,YGP%MV)
      ZGPPC(JROF,MGPPCF_V+JLEV-1)=&
       & -ZQQ*ZGMV9(JROF,JLEV,YGP%MU)+ZPP*ZGMV9(JROF,JLEV,YGP%MV)
      IF( LDSLPHY ) THEN
        ZGPPC(JROF,MGPPCF_UP+JLEV-1)=ZPP*ZUP9(JROF,JLEV)+ZQQ*ZVP9(JROF,JLEV)
        ZGPPC(JROF,MGPPCF_VP+JLEV-1)=-ZQQ*ZUP9(JROF,JLEV)+ZPP*ZVP9(JROF,JLEV)
      ENDIF
    ENDDO
  ENDDO

  ! T:
  ZGPPC(KST:KPROF,MGPPCF_T:MGPPCF_T+NFLEVG-1)=ZGMV9(KST:KPROF,1:NFLEVG,YGP%MT)
  IF( LDSLPHY ) THEN
    ZGPPC(KST:KPROF,MGPPCF_TP:MGPPCF_TP+NFLEVG-1)=PTP9(KST:KPROF,1:NFLEVG)
  ENDIF

  ! NH variables:
  IF( LNHEE ) THEN
    ZGPPC(KST:KPROF,MGPPCF_SPD:MGPPCF_SPD+NFLEVG-1)=ZGMV9(KST:KPROF,1:NFLEVG,YGP%MSPD)
  ENDIF
  IF( LNHDYN ) THEN
    ZGPPC(KST:KPROF,MGPPCF_SVD:MGPPCF_SVD+NFLEVG-1)=ZGMV9(KST:KPROF,1:NFLEVG,YGP%MSVD)
    IF (LLUPDATE_NHX)THEN
      ZGPPC(KST:KPROF,MGPPCF_NHX:MGPPCF_NHX+NFLEVG-1)=ZGMV9(KST:KPROF,1:NFLEVG,YGP%MNHX)
    ENDIF
    IF( YDMODEL%YRML_DYN%YRDYNA%LRDBBC ) THEN
      ZGPPC(KST:KPROF,MGPPCF_BBC)=ZDBBC9(KST:KPROF)
      ZGPPC(KST:KPROF,MGPPCF_BBC+1)=ZDPHI9(KST:KPROF)
      ZGPPC(KST:KPROF,MGPPCF_BBC+2)=ZGWS9(KST:KPROF)
    ENDIF
  ENDIF

  ! Continuity equation:
  ZGPPC(KST:KPROF,MGPPCF_SP:MGPPCF_SP+NFLEVG-1)=ZDP9(KST:KPROF,1:NFLEVG)
  ZGPPC(KST:KPROF,MGPPCF_CP:MGPPCF_CP+NFLEVG-1)=ZC9(KST:KPROF,1:NFLEVG)

  ! GFL:
  IF( LDSLPHY ) THEN
    ! ky: this one must be saved in GFL(PC), not in ZGPPC (change to do later).
    DO JGFL=1,NUMFLDS
      ZGPPC(KST:KPROF,MGPPCF_GFLP+(JGFL-1)*NFLEVG:MGPPCF_GFLP+JGFL*NFLEVG-1)=&
       & PGFLP9(KST:KPROF,1:NFLEVG,JGFL)
    ENDDO
  ENDIF
  DO JGFL=1,NUMFLDS
    IF ((YCOMP(JGFL)%LADV).AND.(YCOMP(JGFL)%LPC)) THEN
      DO JLEV=1,NFLEVG
        DO JROF=KST,KPROF
          PGFLPC(JROF,JLEV,YCOMP(JGFL)%MPPC)=ZGFL9(JROF,JLEV,JGFL)
        ENDDO
      ENDDO
    ENDIF
  ENDDO

ENDIF

!        2.1.3 GET INTERPOLATED VALUES FROM GPPCBUF AND ZGPPC.

IF ( YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.(NCURRENT_ITER > 0) ) THEN

  ! U,V:
  ! - includes rotation matrix.
  ! - if LADVF=T, includes 2 Omega wedge vec(r) at O.
  ZGMV9(KST:KPROF,1:NFLEVG,YGP%MU)=ZGPPC(KST:KPROF,MGPPCF_U:MGPPCF_U+NFLEVG-1)
  ZGMV9(KST:KPROF,1:NFLEVG,YGP%MV)=ZGPPC(KST:KPROF,MGPPCF_V:MGPPCF_V+NFLEVG-1)
  IF( LDSLPHY ) THEN
    ZUP9(KST:KPROF,1:NFLEVG)=ZGPPC(KST:KPROF,MGPPCF_UP:MGPPCF_UP+NFLEVG-1)
    ZVP9(KST:KPROF,1:NFLEVG)=ZGPPC(KST:KPROF,MGPPCF_VP:MGPPCF_VP+NFLEVG-1)
  ENDIF

  ! T:
  ZGMV9(KST:KPROF,1:NFLEVG,YGP%MT)=ZGPPC(KST:KPROF,MGPPCF_T:MGPPCF_T+NFLEVG-1)
  IF( LDSLPHY ) THEN
    PTP9(KST:KPROF,1:NFLEVG)=ZGPPC(KST:KPROF,MGPPCF_TP:MGPPCF_TP+NFLEVG-1)
  ENDIF

  ! NH variables:
  IF( LNHEE ) THEN
    ZGMV9(KST:KPROF,1:NFLEVG,YGP%MSPD)=ZGPPC(KST:KPROF,MGPPCF_SPD:MGPPCF_SPD+NFLEVG-1)
  ENDIF
  IF( LNHDYN ) THEN
    ZGMV9(KST:KPROF,1:NFLEVG,YGP%MSVD)=ZGPPC(KST:KPROF,MGPPCF_SVD:MGPPCF_SVD+NFLEVG-1)
    IF (LLUPDATE_NHX)THEN
      ZGMV9(KST:KPROF,1:NFLEVG,YGP%MNHX)=ZGPPC(KST:KPROF,MGPPCF_NHX:MGPPCF_NHX+NFLEVG-1)
    ENDIF
    IF( YDMODEL%YRML_DYN%YRDYNA%LRDBBC ) THEN
      ZDBBC9(KST:KPROF)=ZGPPC(KST:KPROF,MGPPCF_BBC)
      ZDPHI9(KST:KPROF)=ZGPPC(KST:KPROF,MGPPCF_BBC+1)
      ZGWS9(KST:KPROF)=ZGPPC(KST:KPROF,MGPPCF_BBC+2)
    ENDIF
  ENDIF

  ! Continuity equation:
  ZDP9(KST:KPROF,1:NFLEVG)=ZGPPC(KST:KPROF,MGPPCF_SP:MGPPCF_SP+NFLEVG-1)
  ZC9(KST:KPROF,1:NFLEVG)=ZGPPC(KST:KPROF,MGPPCF_CP:MGPPCF_CP+NFLEVG-1)

  ! GFL:
  IF( LDSLPHY ) THEN
    DO JGFL=1,NUMFLDS
      PGFLP9(KST:KPROF,1:NFLEVG,JGFL)=&
       & ZGPPC(KST:KPROF,MGPPCF_GFLP+(JGFL-1)*NFLEVG:MGPPCF_GFLP+JGFL*NFLEVG-1)
    ENDDO
  ENDIF
  DO JGFL=1,NUMFLDS
    IF ((YCOMP(JGFL)%LADV).AND.(YCOMP(JGFL)%LPC)) THEN
      DO JLEV=1,NFLEVG
        DO JROF=KST,KPROF
          ZGFL9(JROF,JLEV,JGFL)=PGFLPC(JROF,JLEV,YCOMP(JGFL)%MPPC)
        ENDDO
      ENDDO
    ENDIF
  ENDDO

ENDIF

!*       2.2   ADD QUANTITIES INTERPOLATED AT THE ORIGIN POINT
!              TO ARRAYS P(X)T1 FOR CONTINUITY EQUATION.

!        2.2.0 ADD NL PART SPECIFIC TO SETTLS.

IF (YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.YDMODEL%YRML_DYN%YRDYNA%LSETTLS.AND.(NCURRENT_ITER==0)) THEN
  ZC9(KST:KPROF,1:NFLEVG)=ZC9(KST:KPROF,1:NFLEVG)+ZC9_NL(KST:KPROF,1:NFLEVG)
ENDIF

!        2.2.1 ADD INTERPOLATED TERMS.

IF (NVLAG == 2) THEN

  IF(LVERTFE) THEN
    CALL ABOR1(' LAPINEB 2.2.1: LVERTFE=.T. NOT CODED WITH NVLAG == 2')
  ELSE
    DO JLEV=1,NFLEVG
      PGMVT1S(KST:KPROF,YT1%MSP)=PGMVT1S(KST:KPROF,YT1%MSP)+&
       & ZVWEI(KST:KPROF,JLEV)*(ZDP9(KST:KPROF,JLEV)+ZC9(KST:KPROF,JLEV))
    ENDDO
  ENDIF

ELSEIF (NVLAG == 3) THEN

  IF(LVERTFE) THEN
    DO JLEV=1,NFLEVG
      ZSPT1(KST:KPROF,JLEV)=ZVWEI(KST:KPROF,JLEV)*YDVETA%VFE_RDETAH(JLEV)&
       & *(ZDP9(KST:KPROF,JLEV)+ZC9(KST:KPROF,JLEV))  
    ENDDO
    ZSPT1(KST:KPROF,0)=0.0_JPRB
    ZSPT1(KST:KPROF,NFLEVG+1)=0.0_JPRB
    CALL VERDISINT(YDVFE,'ITOP','11',NPROMA,KST,KPROF,NFLEVG,ZSPT1,ZSPTO)
    PGMVT1S(KST:KPROF,YT1%MSP)=PGMVT1S(KST:KPROF,YT1%MSP)&
     & +ZSPTO(KST:KPROF,NFLEVG+1)
  ELSE
    DO JLEV=1,NFLEVG
      PGMVT1S(KST:KPROF,YT1%MSP)=PGMVT1S(KST:KPROF,YT1%MSP)+&
      & ZVWEI(KST:KPROF,JLEV)*(ZDP9(KST:KPROF,JLEV)+ZC9(KST:KPROF,JLEV))  
    ENDDO
  ENDIF

  LLSLINLC2=YDMODEL%YRML_DYN%YRDYNA%LSLINLC2.AND.YDMODEL%YRML_DYN%YRDYNA%NGWADVSI==1.AND.(NCURRENT_ITER == 0)
  IF (LLSLINLC2.AND. .NOT.LVERTFE) THEN
    ! Add the linear term, FD vertically integrated, to PB2.
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        PB2(JROF,MSLB2SPSI)=PB2(JROF,MSLB2SPSI)&
         & +ZVWEI(JROF,JLEV)*ZC9_SI(JROF,JLEV)
      ENDDO
    ENDDO
  ELSEIF (LLSLINLC2.AND.LVERTFE) THEN
    ! Add the linear term, VFE vertically integrated, to PB2.
    DO JLEV=1,NFLEVG
      ZSPT1(KST:KPROF,JLEV)=ZVWEI(KST:KPROF,JLEV)*YDVETA%VFE_RDETAH(JLEV)&
       & *ZC9_SI(KST:KPROF,JLEV)
    ENDDO
    ZSPT1(KST:KPROF,0)=0.0_JPRB
    ZSPT1(KST:KPROF,NFLEVG+1)=0.0_JPRB
    CALL VERDISINT(YDVFE,'ITOP','11',NPROMA,KST,KPROF,NFLEVG,ZSPT1,ZSPTO)
    PB2(KST:KPROF,MSLB2SPSI)=PB2(KST:KPROF,MSLB2SPSI)+ZSPTO(KST:KPROF,NFLEVG+1)
  ENDIF

ENDIF

!*       2.3   ADD QUANTITIES INTERPOLATED AT THE ORIGIN
!              POINTS TO ARRAYS P(X)T1 FOR EQUATIONS OTHER THAN
!              CONTINUITY EQUATION.

!        2.3.1a ADD NL PART SPECIFIC TO SETTLS.

IF (YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.YDMODEL%YRML_DYN%YRDYNA%LSETTLS.AND.(NCURRENT_ITER==0)) THEN
  ZGMV9(KST:KPROF,1:NFLEVG,1:YGP%NDIM)=ZGMV9(KST:KPROF,1:NFLEVG,1:YGP%NDIM) &
   & +ZGMV9_NL(KST:KPROF,1:NFLEVG,1:YGP%NDIM)
ENDIF

!        2.3.1b ADD GENERAL CONTRIBUTIONS IN P[X]T1.

! * Momentum equation.
IF( YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.(NCURRENT_ITER > 0) ) THEN
  ! Rotation (p,q) has already been taken into account in (ZU..9,ZV..9).
  DO JLEV=1,NFLEVG
    DO JROF=KST,KPROF
      PGMVT1(JROF,JLEV,YT1%MU)=PGMVT1(JROF,JLEV,YT1%MU)+ZGMV9(JROF,JLEV,YGP%MU)
      PGMVT1(JROF,JLEV,YT1%MV)=PGMVT1(JROF,JLEV,YT1%MV)+ZGMV9(JROF,JLEV,YGP%MV)
    ENDDO
  ENDDO
  IF( LDSLPHY ) THEN
    PUP9(KST:KPROF,1:NFLEVG)=ZUP9(KST:KPROF,1:NFLEVG)
    PVP9(KST:KPROF,1:NFLEVG)=ZVP9(KST:KPROF,1:NFLEVG)
  ENDIF
ELSE
  DO JLEV=1,NFLEVG
    DO JROF=KST,KPROF
      ZPP=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)-PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
      ZQQ=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)+PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
      PGMVT1(JROF,JLEV,YT1%MU)=PGMVT1(JROF,JLEV,YT1%MU)&
       & +ZPP*ZGMV9(JROF,JLEV,YGP%MU)+ZQQ*ZGMV9(JROF,JLEV,YGP%MV)
      PGMVT1(JROF,JLEV,YT1%MV)=PGMVT1(JROF,JLEV,YT1%MV)&
       & -ZQQ*ZGMV9(JROF,JLEV,YGP%MU)+ZPP*ZGMV9(JROF,JLEV,YGP%MV)
      IF( LDSLPHY ) THEN
        PUP9(JROF,JLEV)=ZPP*ZUP9(JROF,JLEV)+ZQQ*ZVP9(JROF,JLEV)
        PVP9(JROF,JLEV)=-ZQQ*ZUP9(JROF,JLEV)+ZPP*ZVP9(JROF,JLEV)
      ENDIF
    ENDDO
  ENDDO
  IF (YDMODEL%YRML_DYN%YRDYNA%LSLINL.AND.YDMODEL%YRML_DYN%YRDYNA%NGWADVSI==1.AND.NCURRENT_ITER==0) THEN
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        ZPP=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)-PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
        ZQQ=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)+PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
        PB2(JROF,MSLB2USI-1+JLEV)=PB2(JROF,MSLB2USI-1+JLEV)&
         & +ZPP*ZGMV9_SI(JROF,JLEV,YGP%MU)+ZQQ*ZGMV9_SI(JROF,JLEV,YGP%MV)
        PB2(JROF,MSLB2VSI-1+JLEV)=PB2(JROF,MSLB2VSI-1+JLEV)&
         & -ZQQ*ZGMV9_SI(JROF,JLEV,YGP%MU)+ZPP*ZGMV9_SI(JROF,JLEV,YGP%MV)
      ENDDO
    ENDDO
  ELSEIF (YDMODEL%YRML_DYN%YRDYNA%LSLINL.AND.YDMODEL%YRML_DYN%YRDYNA%NGWADVSI==2.AND.NCURRENT_ITER==0) THEN
    ! Simply save the version of ZPP,ZQQ not modified by L2TLFF
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        ZP2(JROF,JLEV)=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)&
         & -PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
        ZQ2(JROF,JLEV)=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)&
         & +PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
      ENDDO
    ENDDO
  ENDIF
ENDIF

! * Temperature equation.
PGMVT1(KST:KPROF,1:NFLEVG,YT1%MT)=PGMVT1(KST:KPROF,1:NFLEVG,YT1%MT)&
 & +ZGMV9(KST:KPROF,1:NFLEVG,YGP%MT)  
IF (YDMODEL%YRML_DYN%YRDYNA%LSLINL.AND.YDMODEL%YRML_DYN%YRDYNA%NGWADVSI==1.AND.NCURRENT_ITER==0) THEN
  DO JLEV=1,NFLEVG
    DO JROF=KST,KPROF
      PB2(JROF,MSLB2TSI-1+JLEV)=PB2(JROF,MSLB2TSI-1+JLEV)+ZGMV9_SI(JROF,JLEV,YGP%MT)
    ENDDO
  ENDDO
ENDIF
 
! * GFL variables equations.
DO JGFL=1,NUMFLDS
  IF (YDMODEL%YRML_DYN%YRDYNA%LSLDIA .AND. (&
   & YCOMP(JGFL)%CNAME == 'DPDETA0         ') .AND. YCOMP(JGFL)%LGP) THEN
    ! SL dynamics diagnostics
    ZCMSLP=RCMSLP0/(RD*RTSUR)
    IF (LVERTFE) THEN
      DO JLEV=1,NFLEVG
        !DIR$ IVDEP
        DO JROF=KST,KPROF
          PGFLT1(JROF,JLEV,YCOMP(JGFL)%MP1)=YDVAB%VDELA(JLEV)&
           & + EXP(ZDP9(JROF,JLEV)-ZCMSLP*YDOROG%OROG(JROF))*YDVAB%VDELB(JLEV)
        ENDDO
      ENDDO
    ELSE
      DO JLEV=1,NFLEVG
        !DIR$ IVDEP
        DO JROF=KST,KPROF
          PGFLT1(JROF,JLEV,YCOMP(JGFL)%MP1)=(YDVAB%VAH(JLEV)-YDVAB%VAH(JLEV-1))&
           & + EXP(ZDP9(JROF,JLEV)-ZCMSLP*YDOROG%OROG(JROF))*YDVAB%VDELB(JLEV)
        ENDDO
      ENDDO
    ENDIF    
  ENDIF
  IF (YCOMP(JGFL)%LADV) THEN
    IF ((YCOMP(JGFL)%CNAME == 'CVGQ            ') .AND. YCOMP(JGFL)%LGP) THEN
      ! Computation of SL Moisture Convergence for MF physics
      DO JLEV=1,NFLEVG
        DO JROF=KST,KPROF
          PGFLT1(JROF,JLEV,YCOMP(JGFL)%MP1)=&
          & ZGFL9(JROF,JLEV,JGFL) - PQ(JROF,JLEV)
        ENDDO
      ENDDO
    ELSEIF (.NOT.YCOMP(JGFL)%LMGRID) THEN   
      PGFLT1(KST:KPROF,1:NFLEVG,YCOMP(JGFL)%MP1)=&
       & PGFLT1(KST:KPROF,1:NFLEVG,YCOMP(JGFL)%MP1)+&
       & ZGFL9(KST:KPROF,1:NFLEVG,JGFL)  
    ENDIF
  ENDIF
ENDDO

! * Computation of spectral Moisture Convergence for French physics
IF (YCVGQ%LSP) THEN
  PGFLT1(KST:KPROF,1:NFLEVG,YCVGQ%MP1)=PGFLT1(KST:KPROF,1:NFLEVG,YQ%MP1)
ENDIF   

! * Pressure departure variable equation.
IF(LNHEE) THEN
  PGMVT1(KST:KPROF,1:NFLEVG,YT1%MSPD)=PGMVT1(KST:KPROF,1:NFLEVG,YT1%MSPD)&
   & +ZGMV9(KST:KPROF,1:NFLEVG,YGP%MSPD)  
  IF (YDMODEL%YRML_DYN%YRDYNA%LSLINL.AND.YDMODEL%YRML_DYN%YRDYNA%NGWADVSI==1.AND.NCURRENT_ITER==0) THEN
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        PB2(JROF,MSLB2PDSI-1+JLEV)=PB2(JROF,MSLB2PDSI-1+JLEV)&
         & +ZGMV9_SI(JROF,JLEV,YGP%MSPD)
      ENDDO
    ENDDO
  ENDIF
ENDIF

! * Vertical divergence variable equation.
IF(LNHDYN) THEN
  ! PGMVT1(.,.,YT1%MSVD): half levels lbar=0 to nflevg-1
  !  if LGWADV.AND.(.NOT.LVFE_GW); full levels otherwise.
  PGMVT1(KST:KPROF,1:NFLEVG,YT1%MSVD)=PGMVT1(KST:KPROF,1:NFLEVG,YT1%MSVD)&
   & +ZGMV9(KST:KPROF,1:NFLEVG,YGP%MSVD)  
  IF (LLUPDATE_NHX) THEN
    PGMVT1(KST:KPROF,1:NFLEVG,YT1%MNHX)=PGMVT1(KST:KPROF,1:NFLEVG,YT1%MNHX)&
     & +ZGMV9(KST:KPROF,1:NFLEVG,YGP%MNHX)  
  ENDIF
  IF (YDMODEL%YRML_DYN%YRDYNA%LSLINL.AND.YDMODEL%YRML_DYN%YRDYNA%NGWADVSI==1.AND.NCURRENT_ITER==0) THEN
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        PB2(JROF,MSLB2VDSI-1+JLEV)=PB2(JROF,MSLB2VDSI-1+JLEV)&
         & +ZGMV9_SI(JROF,JLEV,YGP%MSVD)
      ENDDO
    ENDDO
  ENDIF
ENDIF

!        2.3.1d COMPUTE "moist R" and appropriate (RT) at t+dt.

! ZRT1 contains appropriate value of (RT), consistent with definition of "dver".
IF (YDMODEL%YRML_DYN%YRDYNA%L_RDRY_VD) THEN
  ZRT1(KST:KPROF,1:NFLEVG)=RD*PGMVT1(KST:KPROF,1:NFLEVG,YT1%MT)
ELSE
  CALL GPRCP_PGFL(NPROMA,KST,KPROF,NFLEVG,PGFL=PGFLT1,PR=ZR1,KGFLTYP=1)
  DO JLEV=1,NFLEVG
    DO JROF=KST,KPROF
      ZRT1(JROF,JLEV)=ZR1(JROF,JLEV)*PGMVT1(JROF,JLEV,YT1%MT)
    ENDDO
  ENDDO
ENDIF

!        2.3.2 SPECIAL TREATMENT OF CORIOLIS TERM:

! For the corrector step of LPC_CHEAP nothing has to be done here
!  because term [2 Omega wedge vec(r)] at O has already been taken
!  into account in the calculations done in part 2.1.3.

IF ( .NOT. (YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.(NCURRENT_ITER > 0)) ) THEN

  LLCOMPUTE_OMVAK_O=LADVF

  IF (LLCOMPUTE_OMVAK_O) THEN
    ! * Analytical computation of "2 Omega wedge a k" at "O":
    IF (LRPLANE) THEN
      ! * calculation of LACONE done already in ELARCHE -> results are in
      !   zlon, zlat tables.
      ZGMV9(KST:KPROF,1:NFLEVG,YGP%MU)=PCCO(KST:KPROF,1:NFLEVG,YDTCCO%M_RLON)
      ZGMV9(KST:KPROF,1:NFLEVG,YGP%MV)=PCCO(KST:KPROF,1:NFLEVG,YDTCCO%M_RLAT)
    ELSE
      CALL LACONE(NPROMA,KST,KPROF,NFLEVG,NSTTYP,&
       & ROMEGA,ZDSTRET,RC2M1,RC2P1,RMUCEN,RA,RPI,&
       & PCCO(1,1,YDTCCO%M_RLON),PCCO(1,1,YDTCCO%M_RLAT),&
       & ZGMV9(1,1,YGP%MU),ZGMV9(1,1,YGP%MV))  
    ENDIF
  ENDIF

  IF (LLCOMPUTE_OMVAK_O) THEN
    ! * Add the content of "pu9,pv9" to "(U,V)(t+dt)":
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        ZPP=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)-PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
        ZQQ=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)+PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
        PGMVT1(JROF,JLEV,YT1%MU)=PGMVT1(JROF,JLEV,YT1%MU)&
         & +ZPP*ZGMV9(JROF,JLEV,YGP%MU)+ZQQ*ZGMV9(JROF,JLEV,YGP%MV)
        PGMVT1(JROF,JLEV,YT1%MV)=PGMVT1(JROF,JLEV,YT1%MV)&
         & -ZQQ*ZGMV9(JROF,JLEV,YGP%MU)+ZPP*ZGMV9(JROF,JLEV,YGP%MV)
      ENDDO
    ENDDO
  ENDIF

  IF ( LLCOMPUTE_OMVAK_O .AND. (.NOT.L2TLFF)&
   & .AND. YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.(NCURRENT_ITER == 0) ) THEN
    ! ZGPPC(wind) must be incremented with term [2 Omega wedge vec(r)] at O.
    !  If L2TLFF=T, the incrementation is not done here but in part 2.3.4
    !  in order to take account of the recomputed version of O.
    DO JLEV=1,NFLEVG
      !DIR$ IVDEP 
      DO JROF=KST,KPROF 
        ZPP=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)-PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
        ZQQ=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)+PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
        ZGPPC(JROF,MGPPCF_U+JLEV-1)=ZGPPC(JROF,MGPPCF_U+JLEV-1)&
         & +ZPP*ZGMV9(JROF,JLEV,YGP%MU)+ZQQ*ZGMV9(JROF,JLEV,YGP%MV)
        ZGPPC(JROF,MGPPCF_V+JLEV-1)=ZGPPC(JROF,MGPPCF_V+JLEV-1)&
         & -ZQQ*ZGMV9(JROF,JLEV,YGP%MU)+ZPP*ZGMV9(JROF,JLEV,YGP%MV)
      ENDDO
    ENDDO
  ENDIF

ENDIF

!        2.3.4 SPECIAL TREATMENT OF CORIOLIS TERM:
!              CASE "L2TLFF=T".

! * Refined calculation of the origin point.
!   Refined treatment of Coriolis term in 2TL scheme (or in 3TL SLI scheme).
!   Works for the following configurations:
!    - SL3TL or SL2TL.
!    - LADVF=.T.
!    - NWLAG=3.
!   If LPC_CHEAP=T recalculation of O is done in the predictor step only.

IF ( L2TLFF .AND. .NOT.(YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.(NCURRENT_ITER > 0)) ) THEN

  IF (LRPLANE) THEN

    ! * compute new origin point:
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        ! * old rotation and vector deplacement:
        ZPP=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)-PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
        ZQQ=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)+PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
        ! * new estimate of trajectory wind:
        !   at this stage (pgmvt1(U,V)) contains wind;
        !   (puf,pvf) and (zuz9,zvz9) contain wind.
        ZUT1(JROF,JLEV)=(1.0_JPRB-RW2TLFF)*PUF(JROF,JLEV)&
         & +RW2TLFF*0.5_JPRB*(PGMVT1(JROF,JLEV,YT1%MU) + ZUZ9(JROF,JLEV))
        ZVT1(JROF,JLEV)=(1.0_JPRB-RW2TLFF)*PVF(JROF,JLEV)&
         & +RW2TLFF*0.5_JPRB*(PGMVT1(JROF,JLEV,YT1%MV) + ZVZ9(JROF,JLEV))
        ! * subtract old estimate of advected Coriolis term:
        PGMVT1(JROF,JLEV,YT1%MU)=PGMVT1(JROF,JLEV,YT1%MU)&
         & -ZPP*ZGMV9(JROF,JLEV,YGP%MU)-ZQQ*ZGMV9(JROF,JLEV,YGP%MV)  
        PGMVT1(JROF,JLEV,YT1%MV)=PGMVT1(JROF,JLEV,YT1%MV)&
         & +ZQQ*ZGMV9(JROF,JLEV,YGP%MU)-ZPP*ZGMV9(JROF,JLEV,YGP%MV)  
        ! * compute the new origin point ON:
        ZTXO=YDCSGEOM%RINDX(JROF)-2.0_JPRB*ZUT1(JROF,JLEV)*ZGMDTX(JROF)
        ZTYO=YDCSGEOM%RINDY(JROF)-2.0_JPRB*ZVT1(JROF,JLEV)*ZGMDTY(JROF)
        PCCO(JROF,JLEV,YDTCCO%M_RLON)=ZTXO*ZINEZV(JROF)+YDCSGEOM%RINDX(JROF)*(1.0_JPRB-ZINEZV(JROF))
        PCCO(JROF,JLEV,YDTCCO%M_RLAT)=ZTYO*ZINEZV(JROF)+YDCSGEOM%RINDY(JROF)*(1.0_JPRB-ZINEZV(JROF))
        ZTXO=MIN(MAX(ZTXO,ZDLUN),ZDLUX)
        ZTYO=MIN(MAX(ZTYO,ZDGUN),ZDGUX)
        PSCO(JROF,JLEV,YDTSCO%M_COSCO)=ZTXO*ZINEZV(JROF)+YDCSGEOM%RINDX(JROF)*(1.0_JPRB-ZINEZV(JROF))
        PSCO(JROF,JLEV,YDTSCO%M_SINCO)=ZTYO*ZINEZV(JROF)+YDCSGEOM%RINDY(JROF)*(1.0_JPRB-ZINEZV(JROF))
      ENDDO
    ENDDO
    ! * compute rotation matrix and Coriolis term "2 Omega wedge a k"
    !   at the new origin point ON.
    CALL ELARCHE(YDMODEL%YRML_DYN,NPROMA,KST,KPROF,NFLEVG,YDSL,YDEGSL,YDEGEO,YDGSGEOM,PSCO,PCCO)
    ZGMV9(KST:KPROF,1:NFLEVG,YGP%MU)=PCCO(KST:KPROF,1:NFLEVG,YDTCCO%M_RLON)
    ZGMV9(KST:KPROF,1:NFLEVG,YGP%MV)=PCCO(KST:KPROF,1:NFLEVG,YDTCCO%M_RLAT)
    ! * add new estimate of advected Coriolis term:
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        ZPP=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)-PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
        ZQQ=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)+PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
        PGMVT1(JROF,JLEV,YT1%MU)=PGMVT1(JROF,JLEV,YT1%MU)&
         & +ZPP*ZGMV9(JROF,JLEV,YGP%MU)+ZQQ*ZGMV9(JROF,JLEV,YGP%MV)  
        PGMVT1(JROF,JLEV,YT1%MV)=PGMVT1(JROF,JLEV,YT1%MV)&
         & -ZQQ*ZGMV9(JROF,JLEV,YGP%MU)+ZPP*ZGMV9(JROF,JLEV,YGP%MV)  
      ENDDO
    ENDDO

  ELSE

    ! * compute new origin point:
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        ! * old rotation and vector deplacement:
        ZPP=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)-PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
        ZQQ=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)+PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
        ZPP9=PCCO(JROF,JLEV,YDTCCO%M_RQX)
        ZQQ9=PCCO(JROF,JLEV,YDTCCO%M_RQY)
        ZPP1=YDGSGEOM%GNORDM(JROF)
        ZQQ1=-YDGSGEOM%GNORDL(JROF)
        ! * new estimate of trajectory wind:
        !   at this stage (pgmvt1(U,V)) contains wind;
        !   (puf,pvf) and (zuz9,zvz9) contain wind.
        ZUT1(JROF,JLEV)=RW2TLFF*0.5_JPRB*(&
         & ZPP1*PGMVT1(JROF,JLEV,YT1%MU)+ZQQ1*PGMVT1(JROF,JLEV,YT1%MV)&
         & +ZPP9*ZUZ9(JROF,JLEV)+ZQQ9*ZVZ9(JROF,JLEV))&
         & +(1.0_JPRB-RW2TLFF)*(ZPP1*PUF(JROF,JLEV)+ZQQ1*PVF(JROF,JLEV))  
        ZVT1(JROF,JLEV)=RW2TLFF*0.5_JPRB*(&
         & -ZQQ1*PGMVT1(JROF,JLEV,YT1%MU)+ZPP1*PGMVT1(JROF,JLEV,YT1%MV)&
         & -ZQQ9*ZUZ9(JROF,JLEV)+ZPP9*ZVZ9(JROF,JLEV))&
         & +(1.0_JPRB-RW2TLFF)*(-ZQQ1*PUF(JROF,JLEV)+ZPP1*PVF(JROF,JLEV))  
        ! * subtract old estimate of advected Coriolis term:
        PGMVT1(JROF,JLEV,YT1%MU)=PGMVT1(JROF,JLEV,YT1%MU)&
         & -ZPP*ZGMV9(JROF,JLEV,YGP%MU)-ZQQ*ZGMV9(JROF,JLEV,YGP%MV)  
        PGMVT1(JROF,JLEV,YT1%MV)=PGMVT1(JROF,JLEV,YT1%MV)&
         & +ZQQ*ZGMV9(JROF,JLEV,YGP%MU)-ZPP*ZGMV9(JROF,JLEV,YGP%MV)  
        ! * compute the new origin point ON:
        ZPHI=0.5_JPRB*RTDT*SQRT(ZUT1(JROF,JLEV)*ZUT1(JROF,JLEV)&
         & +ZVT1(JROF,JLEV)*ZVT1(JROF,JLEV))/RA  
        ZCOPHI=1.0_JPRB-0.5_JPRB*ZPHI*ZPHI
        ZSINX=ZCOPHI*RTDT*(1.0_JPRB-ZPHI*ZPHI/6.0_JPRB)/RA
        PSCO(JROF,JLEV,YDTSCO%M_SINLA)=YDGSGEOM%GEMU(JROF)*(2.0_JPRB*ZCOPHI*ZCOPHI-1.0_JPRB)&
         & -ZVT1(JROF,JLEV)*YDGSGEOM%GSQM2(JROF)*ZSINX  
        PSCO(JROF,JLEV,YDTSCO%M_COSCO)=YDGSGEOM%GSQM2(JROF)*(2.0_JPRB*ZCOPHI*ZCOPHI-1.0_JPRB)&
         & +ZVT1(JROF,JLEV)*YDGSGEOM%GEMU(JROF)*ZSINX  
        PSCO(JROF,JLEV,YDTSCO%M_SINCO)=-ZUT1(JROF,JLEV)*ZSINX
        PSCO(JROF,JLEV,YDTSCO%M_COPHI)=2.0_JPRB*ZCOPHI*ZCOPHI-1.0_JPRB
      ENDDO
    ENDDO
    ! * compute rotation matrix and Coriolis term "2 Omega wedge a k"
    !   at the new origin point ON.
    CALL LARCHE(YDMODEL%YRML_DYN%YYTCCO,YDMODEL%YRML_DYN%YYTSCO,NPROMA,KST,KPROF,NFLEVG,NSTTYP,ZDSTRET,&
     & RC2M1,RC2P1,RPI,ZDEPI,RLOCEN,RMUCEN,YDGSGEOM,YDCSGEOM,PSCO,1,PCCO)
    CALL LACONE(NPROMA,KST,KPROF,NFLEVG,NSTTYP,&
     & ROMEGA,ZDSTRET,RC2M1,RC2P1,RMUCEN,RA,RPI,&
     & PCCO(1,1,YDTCCO%M_RLON),PCCO(1,1,YDTCCO%M_RLAT),&
     & ZGMV9(1,1,YGP%MU),ZGMV9(1,1,YGP%MV))  
    ! * add new estimate of advected Coriolis term:
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        ZPP=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)-PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
        ZQQ=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)+PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
        PGMVT1(JROF,JLEV,YT1%MU)=PGMVT1(JROF,JLEV,YT1%MU)&
         & +ZPP*ZGMV9(JROF,JLEV,YGP%MU)+ZQQ*ZGMV9(JROF,JLEV,YGP%MV)  
        PGMVT1(JROF,JLEV,YT1%MV)=PGMVT1(JROF,JLEV,YT1%MV)&
         & -ZQQ*ZGMV9(JROF,JLEV,YGP%MU)+ZPP*ZGMV9(JROF,JLEV,YGP%MV)  
      ENDDO
    ENDDO

  ENDIF

  IF ( YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.(NCURRENT_ITER == 0) ) THEN
    ! ZGPPC(wind) must be incremented with term [2 Omega wedge vec(r)] at O.
    DO JLEV=1,NFLEVG
      !DIR$ IVDEP 
      DO JROF=KST,KPROF 
        ZPP=PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDM(JROF)-PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDL(JROF)
        ZQQ=PCCO(JROF,JLEV,YDTCCO%M_RQY)*YDGSGEOM%GNORDM(JROF)+PCCO(JROF,JLEV,YDTCCO%M_RQX)*YDGSGEOM%GNORDL(JROF)
        ZGPPC(JROF,MGPPCF_U+JLEV-1)=ZGPPC(JROF,MGPPCF_U+JLEV-1)&
         & +ZPP*ZGMV9(JROF,JLEV,YGP%MU)+ZQQ*ZGMV9(JROF,JLEV,YGP%MV)
        ZGPPC(JROF,MGPPCF_V+JLEV-1)=ZGPPC(JROF,MGPPCF_V+JLEV-1)&
         & -ZQQ*ZGMV9(JROF,JLEV,YGP%MU)+ZPP*ZGMV9(JROF,JLEV,YGP%MV)
      ENDDO
    ENDDO
  ENDIF

ENDIF

!        2.3.5 CONVERT "gw" TOWARDS "d-hat" + diagnostic BBC in NH.

IF(YDMODEL%YRML_DYN%YRDYNA%LGWADV.OR.YDMODEL%YRML_DYN%YRDYNA%LRDBBC) THEN
  ! * allocate arrays for storing the surface wind, and compute them.
  ALLOCATE(ZUST1(NPROMA))
  ALLOCATE(ZVST1(NPROMA))
  LLDER=.FALSE.
  CALL GPUVS(NFLEVG,NPROMA,KST,KPROF,LLDER,&
   & PGMVT1(1,1,YT1%MU),PGMVT1(1,1,YT1%MV),ZUST1,ZVST1)

  ! * allocate arrays for storing grad(orog)=M*vnabla'(orog).
  ALLOCATE(ZOROGL_SR(NPROMA)) 
  ALLOCATE(ZOROGM_SR(NPROMA)) 
  ZOROGL_SR(KST:KPROF)=YDGSGEOM%GM(KST:KPROF)*YDOROG%OROGL(KST:KPROF)
  ZOROGM_SR(KST:KPROF)=YDGSGEOM%GM(KST:KPROF)*YDOROG%OROGM(KST:KPROF)
ENDIF

IF(YDMODEL%YRML_DYN%YRDYNA%LGWADV) THEN

  ! * Convert explicit guess of (gw) towards d3.
  !   (for d4, X-term is added in CPGLAG via the SI term).
  IF (YDMODEL%YRML_DYN%YRDYNA%NVDVAR==4 .OR. YDMODEL%YRML_DYN%YRDYNA%NVDVAR==5) THEN
    IVDVAR=3
  ELSE
    IVDVAR=YDMODEL%YRML_DYN%YRDYNA%NVDVAR
  ENDIF

  ALLOCATE (ZSVDT1(NPROMA,NFLEVG))
  IF (YDMODEL%YRML_DYN%YRDYNA%NVDVAR==5) ALLOCATE (ZNHYT1(NPROMA,0:NFLEVG))

  ! * Update ZVWVT1:
  !   "gw(surf) is assumed to be equal to vecV(l=L)*gradorog
  IF (LVERTFE.AND.LVFE_GW) THEN
    ALLOCATE (ZVWVT1(NPROMA,1:NFLEVG))
    ALLOCATE (ZVWVT1S(NPROMA))
    ZVWVT1(KST:KPROF,1:NFLEVG)=PGMVT1(KST:KPROF,1:NFLEVG,YT1%MSVD)
    IF (YDMODEL%YRML_DYN%YRDYNA%NVDVAR==3 .OR. YDMODEL%YRML_DYN%YRDYNA%NVDVAR==4) THEN
      ZVWVT1S(KST:KPROF)=ZUST1(KST:KPROF)*ZOROGL_SR(KST:KPROF)&
                        & +ZVST1(KST:KPROF)*ZOROGM_SR(KST:KPROF)
    ELSEIF (YDMODEL%YRML_DYN%YRDYNA%NVDVAR==5) THEN
      ZVWVT1S(KST:KPROF)=0.0_JPRB
    ENDIF

    ! * RDERI is not the exact inverse of RINTE, so it is not advised at all
    !   to apply RDERI to (gw)(t+dt): the choice done here is to apply
    !   RDERI to ((gw)(t+dt)-(gw)(t)), and to use quantities saved in buffer
    !   SLBUF2 ((gw)(t), (gw_surf)(t) and (-g dw)(t)).
    CALL GNHGW2SVD(YDGEOMETRY,KST,KPROF,IVDVAR,&
     & PGMVT1S(1,YT1%MSP),ZRT1,PGMVT1(1,1,YT1%MSPD),ZSVDT1,&
     & PGWF=ZVWVT1,PGWS=ZVWVT1S,PGWRF=PB2(1,MSLB2GWF),&
     & PGWRS=PB2(1,MSLB2GWS),PGDWR=PB2(1,MSLB2GDW))
  ELSE
    ALLOCATE (ZVWVT1(NPROMA,0:NFLEVG))
    ZVWVT1(KST:KPROF,0:NFLEVG-1)=PGMVT1(KST:KPROF,1:NFLEVG,YT1%MSVD)
    IF (YDMODEL%YRML_DYN%YRDYNA%NVDVAR==3 .OR. YDMODEL%YRML_DYN%YRDYNA%NVDVAR==4) THEN
      ZVWVT1(KST:KPROF,NFLEVG)=ZUST1(KST:KPROF)*ZOROGL_SR(KST:KPROF)&
       & +ZVST1(KST:KPROF)*ZOROGM_SR(KST:KPROF)
    ELSEIF (YDMODEL%YRML_DYN%YRDYNA%NVDVAR==5) THEN
      CALL GNHY(YDGEOMETRY,NPROMA,KST,KPROF,ZOROGL_SR,ZOROGM_SR,&
       & PGMVT1S(1,YT1%MSP),PGMVT1(1,1,YT1%MU),PGMVT1(1,1,YT1%MV),ZNHYT1)
      ZVWVT1(KST:KPROF,0:NFLEVG-1)=ZVWVT1(KST:KPROF,0:NFLEVG-1) &
       & +ZNHYT1(KST:KPROF,0:NFLEVG-1)
      ZVWVT1(KST:KPROF,NFLEVG)=0.0_JPRB
    ENDIF

    CALL GNHGW2SVD(YDGEOMETRY,KST,KPROF,IVDVAR,&
     & PGMVT1S(1,YT1%MSP),ZRT1,PGMVT1(1,1,YT1%MSPD),ZSVDT1,&
     & PGWH=ZVWVT1)  
  ENDIF

  ! * Transfer ZSVDT1 into PGMVT1(.,.,YT1%MSVD).
  PGMVT1(KST:KPROF,1:NFLEVG,YT1%MSVD)=ZSVDT1(KST:KPROF,1:NFLEVG)

  ! * deallocate arrays (zvwvt1,zvwvt1s,zsvdt1,znhyt1).
  DEALLOCATE(ZVWVT1)
  DEALLOCATE(ZSVDT1)
  IF (ALLOCATED (ZVWVT1S)) DEALLOCATE(ZVWVT1S)
  IF (ALLOCATED (ZNHYT1)) DEALLOCATE(ZNHYT1)

ENDIF

IF (YDMODEL%YRML_DYN%YRDYNA%LRDBBC.AND.(YDMODEL%YRML_DYN%YRDYNA%NVDVAR==3 .OR. YDMODEL%YRML_DYN%YRDYNA%NVDVAR==4)) THEN
  ! * Diagnostic BBC in NH:
  DO JROF=KST,KPROF 
    PGMVT1(JROF,NFLEVG,YT1%MSVD) = PGMVT1(JROF,NFLEVG,YT1%MSVD)&
     & - 0.5_JPRB*(ZDPHI9(JROF)+PB2(JROF,MSLB2DPHI1))&
     & * (ZUST1(JROF)*ZOROGL_SR(JROF)+ZVST1(JROF)*ZOROGM_SR(JROF)&
     & - ZGWS9(JROF))-(ZDBBC9(JROF)+PB2(JROF,MSLB2DBBC1))
  ENDDO
  ! Remark: for NVDVAR=5 nothing to do, because increment added to PGMVT1 is zero.
ENDIF

IF(YDMODEL%YRML_DYN%YRDYNA%LGWADV.OR.YDMODEL%YRML_DYN%YRDYNA%LRDBBC) THEN
  ! * deallocate arrays (zorogl_sr,zorogm_sr,zust1,zvst1).
  IF (ALLOCATED(ZOROGL_SR)) DEALLOCATE(ZOROGL_SR)
  IF (ALLOCATED(ZOROGM_SR)) DEALLOCATE(ZOROGM_SR)
  IF (ALLOCATED(ZUST1)) DEALLOCATE(ZUST1)
  IF (ALLOCATED(ZVST1)) DEALLOCATE(ZVST1)
ENDIF

!        2.3.6 Add linear contributions interpolated at O if NGWADVSI=2
!              (some specific cases of NH + LGWADV only).

! In this case the linear contributions interpolated at O are added to
! the equations RHS after the conversion (gw) -> d4, but before the
! lagged physics and the specific treatment of term NHX done in CPGLAG.
! This is done only at the predictor step (only case where the terms added are non-zero).
! Not coded for the obsolescent option NVLAG=2.

IF (LNHDYN.AND.YDMODEL%YRML_DYN%YRDYNA%LGWADV.AND.YDMODEL%YRML_DYN%YRDYNA%NGWADVSI==2.AND.NCURRENT_ITER==0) THEN

  ! * Continuity equation:
  IF (NVLAG==3.AND.YDMODEL%YRML_DYN%YRDYNA%LSLINLC2) THEN
    IF (LVERTFE) THEN
      ! Add the linear term, FE vertically integrated, to PB2.
      DO JLEV=1,NFLEVG
        ZSPT1(KST:KPROF,JLEV)=ZVWEI(KST:KPROF,JLEV)*YDVETA%VFE_RDETAH(JLEV)*ZC9_SI(KST:KPROF,JLEV)
      ENDDO
      ZSPT1(KST:KPROF,0)=0.0_JPRB
      ZSPT1(KST:KPROF,NFLEVG+1)=0.0_JPRB
      CALL VERDISINT(YDVFE,'ITOP','11',NPROMA,KST,KPROF,NFLEVG,ZSPT1,ZSPTO)
      PGMVT1S(KST:KPROF,YT1%MSP)=PGMVT1S(KST:KPROF,YT1%MSP)+ZSPTO(KST:KPROF,NFLEVG+1)
    ELSE
      ! Add the linear term, FD vertically integrated, to PB2.
      DO JLEV=1,NFLEVG
        DO JROF=KST,KPROF
          PGMVT1S(JROF,YT1%MSP)=PGMVT1S(JROF,YT1%MSP)+ZVWEI(JROF,JLEV)*ZC9_SI(JROF,JLEV)
        ENDDO
      ENDDO
    ENDIF
  ENDIF

  ! * Momentum equation (should use the versions of ZPP,ZQQ not modified by L2TLFF):
  IF (YDMODEL%YRML_DYN%YRDYNA%LSLINL) THEN
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        ZPP=ZP2(JROF,JLEV)
        ZQQ=ZQ2(JROF,JLEV)
        PGMVT1(JROF,JLEV,YT1%MU)=PGMVT1(JROF,JLEV,YT1%MU)&
         & +ZPP*ZGMV9_SI(JROF,JLEV,YGP%MU)+ZQQ*ZGMV9_SI(JROF,JLEV,YGP%MV)
        PGMVT1(JROF,JLEV,YT1%MV)=PGMVT1(JROF,JLEV,YT1%MV)&
         & -ZQQ*ZGMV9_SI(JROF,JLEV,YGP%MU)+ZPP*ZGMV9_SI(JROF,JLEV,YGP%MV)
      ENDDO
    ENDDO
  ENDIF

  ! * Temperature and vertical divergence equation:
  IF (YDMODEL%YRML_DYN%YRDYNA%LSLINL) THEN
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        PGMVT1(JROF,JLEV,YT1%MT)=PGMVT1(JROF,JLEV,YT1%MT)+ZGMV9_SI(JROF,JLEV,YGP%MT)
        PGMVT1(JROF,JLEV,YT1%MSVD)=PGMVT1(JROF,JLEV,YT1%MSVD)+ZGMV9_SI(JROF,JLEV,YGP%MSVD)
      ENDDO
    ENDDO
  ENDIF

  ! * Pressure departure equation for NHEE model:
  IF (YDMODEL%YRML_DYN%YRDYNA%LSLINL.AND.LNHEE) THEN
    DO JLEV=1,NFLEVG
      DO JROF=KST,KPROF
        PGMVT1(JROF,JLEV,YT1%MSPD)=PGMVT1(JROF,JLEV,YT1%MSPD)+ZGMV9_SI(JROF,JLEV,YGP%MSPD)
      ENDDO
    ENDDO
  ENDIF

ENDIF

!     ------------------------------------------------------------------

!*       4.    DEALLOCATIONS
!              -------------

IF( ALLOCATED(ZUP9) ) DEALLOCATE(ZUP9)
IF( ALLOCATED(ZVP9) ) DEALLOCATE(ZVP9)
IF (ALLOCATED (ZGMV9)) DEALLOCATE (ZGMV9)
IF (ALLOCATED (ZGMV9_SI)) DEALLOCATE (ZGMV9_SI)
IF( ALLOCATED(ZP2) ) DEALLOCATE(ZP2)
IF( ALLOCATED(ZQ2) ) DEALLOCATE(ZQ2)

!     ------------------------------------------------------------------

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('LAPINEB',1,ZHOOK_HANDLE)
END SUBROUTINE LAPINEB
