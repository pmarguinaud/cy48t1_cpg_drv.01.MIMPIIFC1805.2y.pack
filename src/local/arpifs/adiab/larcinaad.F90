#ifdef RS6K
@PROCESS NOCHECK
#endif
SUBROUTINE LARCINAAD(YDGEOMETRY,YDML_DYN,KDIM,KSTGLO,KST,KPROF,YDSL,&
 & KSTABUF,LDSLHD,LDSLHDQUAD,LDSLHD_OLD,KTIP,KROT,LDPLANE,LDOCK_UP,PLSDEPI,&
 & KIBL,KDEP,KNOWENO,&
 & PSCO,PLEV,PSCO5,PLEV5,&
 & PKAPPA,PKAPPA5,PKAPPAT,PKAPPAT5,&
 & PURL0,PVRL0,PZRL0,PWRL0,PURL05,PVRL05,PZRL05,PWRL05,&
 & KVSEPC,KVSEPL,KLOCK,&
 & PINC,KINC,KDIM1,KDIM2,&
 & PCCO,PUF0,PVF0,PZF0,PWF0,PCCO5,&
 & KL0,PLSCAW,PRSCAW,PLSCAW5,PRSCAW5,LDREP)  

!**** *LARCINAAD - semi-LAgrangian scheme:   (adjoint version - Part A)
!                 Research of the Coordinates (of the medium or origin
!                 point) and INterpolations.

!     Purpose.
!     --------
!       Computes the longitude and latitude of the interpolation
!       point from its cartesian coordinates.
!       Then computes the vector displacement matrix
!                        I po pq I
!                        I       I
!                        I-pq po I
!       from the interpolation point to the grid point.
!       At last determines the interpolation grid:
!       - computation of the latitude and the longitude of the
!         point situated at the upper left corner of the 16 points
!         square, and of the interpolation point.
!       - interpolations.

!       First part of from 'old' LARCINAD


!**   Interface.
!     ----------
!        *CALL* *LARCINAAD(......)

!        Explicit arguments :
!        --------------------

!          KDIM    - Number of independent updates.
!          KSTGLO  - global offset into nproma buffer.
!          KST     - first element of arrays where computations are performed.
!          KPROF   - depth of work.
!          YDSL    - SL_STRUCT definition.
!          KSTABUF - for a latitude IGL, KSTABUF(IGL) is the
!                    address of the element corresponding to
!                    (ILON=1,IGL) in the NPROMA arrays.
!          LDSLHD  - key activating SLHD weights precomputation
!          LDSLHDQUAD - key activating quadratic weights precomputation
!          LDSLHD_OLD - use old SLHD interpolator
!          KTIP    - KTIP=1: interpolations for wind to find trajectory.
!                    KTIP=3: (E)LASCAWAD for origin point.
!          KROT    - KROT=1: computation of the elements po and pq
!                    of the wind displacement matrix.
!                    KROT=0: no computation.
!          LDPLANE - switch: .T. = plane geometry; .F. = spherical geometry.
!          LDREP   - optional argument indicating the 00 winds are interpolated rather than 0.
!          LDOCK_UP- ???
!          PLSDEPI - (Number of points by latitude) / (2 * PI) .
!          KIBL    - index into YRGSGEOM/YRCSGEOM instances in YDGEOMETRY
!          KDEP    - dependency indicator for the southernost or northermost latitudes (LAM only)
!          KNOWENO - vertical boundary indicator for the WENO interpolation.
!          PSCO    - information about geographic position of interpol. point.
!          PLEV    - vertical coordinate of the interpolation point.
!          PSCO5   - cf. PSCO (trajectory)
!          PLEV5   - cf. PLEV (trajectory)
!          PKAPPA  - kappa function ("coefficient of SLHD") based on the
!                    rescaled horizontal deformation of the flow evaluated
!                    at instant "t" for the final point F
!          PKAPPA5 - cf. PKAPPA (trajectory)
!          PKAPPAT/PKAPPAT5 - KAPPA and its trajectory for T
!          PURL0   - U-component of the wind.
!          PVRL0   - V-component of the wind.
!          PZRL0   - Z-component of the wind.
!          PWRL0   - "etadot"-component of the wind.
!          PURL05  - cf. PURL0 (trajectory)
!          PVRL05  - cf. PVRL0 (trajectory)
!          PZRL05  - cf. PZRL0 (trajectory)
!          PWRL05  - cf. PWRL0 (trajectory)
!          KVSEPC  - vertical separation for use in update loop (cubic).
!          KVSEPL  - vertical separation for use in update loop (linear).
!          KLOCK   - semaphore function (used for OpenMP synchronization)
!          KDIM1,KDIM2 - dimensions of KINC, PINC
!          KINC    - addresses of interpolation increments in global buffer
!          PINC    - interpolation increments to global buffer (vector only)
!          PCCO    - information about comput. space position of interpol. point.
!          PUF0    - Interpolated U-wind for SL trajectory research.
!          PVF0    - Interpolated V-wind for SL trajectory research.
!          PZF0    - Interpolated Z-wind for SL trajectory research.
!          PWF0    - Interpolated "etadot"-wind for SL trajectory research.
!          PCCO5   - cf. PCCO (trajectory)
!          KL0     - index of the four western points
!                    of the 16 points interpolation grid.
!          PLSCAW  - linear weights (distances) for interpolations.
!          PRSCAW  - non-linear weights for interpolations.
!          PLSCAW5 - linear weights (distances) for interpolations (trajectory).
!          PRSCAW5 - non-linear weights for interpolations (trajectory).

!        Implicit arguments :
!        --------------------

!     Method.
!     -------
!        See documentation

!     Externals.
!     ----------

!     Reference.
!     ----------

!     Author.
!     -------
!      C. Temperton (ECMWF)
!      Original: 99/10/07

!     Modifications.
!     --------------
!      Modified 01-08-30 by K. YESSAD: pruning and some other cleanings.
!      Modified 01-02-27 by C. Temperton: LVECADIN option.
!      Modified 02-07-09 by C. Temperton: added check on IVSEP
!      Modified 03-04-14 by D. Salmond FIX for event logic
!      M.Hamrud      01-Oct-2003 CY28 Cleaning
!      Modified 05-07-09 by C. Temperton: streamlining.
!      D.Salmond     08-Feb-2005 New version LARCINAAD
!      Modified 08-Jan-2007 by F. Vana
!                           - LDPLANE=.T. (skipping adjoint in E-zone)
!                           - NEC-SX optimization
!      Modified 17-Jul-2007 by F. Vana: cleaning + further vect. optimization
!      G.Mozdzynski  21-Feb-2008 Use of locks made dynamic for performance
!      Modified 14-Aug-2008 by F. Vana: Weights driven interpolation, removing
!                             useless KDEP, NEC optim. (following LARCINBAD)
!      K. Yessad Nov 2008: rationalisation of dummy argument interfaces
!      F. Vana :     11-Dec-2008 OpenMP for vector platforms
!      K. Yessad (Aug 2009): always use root (QX,QY) for (p,q) variables names
!      K. Yessad (Aug 2009): use RIPI, RSLD
!      K. Yessad (Nov 2009): routine renaming (LAI..TLAD -> LAI..AD).
!      K. Yessad (Jan 2011): introduce INTDYN_MOD structures.
!      G.Mozdzynski (Jan 2011): OOPS cleaning, use of derived type SL_STRUCT
!      G.Mozdzynski (Feb 2011): OOPS cleaning, use of derived types TGSGEOM, TCSGEOM and TCSGLEG
!      G. Mozdzynski (May 2012): further cleaning
!      F. Vana  13-Feb-2014  kappaT for heat variables
!      T. Wilhelmsson and K. Yessad (Oct 2013) Geometry and setup refactoring.
!      B. Bochenek (Apr 2015): Phasing: update
!      F. Vana  October-2017 : Change order of interpolation to comply with the reverse order in the TL code.
!      F. Vana    21-Nov-2017: Options LSLDP_CURV and LHOISLT
!      F. Vana    July 2018: RK4 scheme for trajectory research.
!      F. Vana October 2018: Extended LSLDP_CURV & better OpenMP support.
!      F. Vana  26-Feb-2019: Vertical quintic interpolation for RHS.
!      H Petithomme (Dec 2020): add vectorization directives
!     ------------------------------------------------------------------

USE MODEL_DYNAMICS_MOD , ONLY : MODEL_DYNAMICS_TYPE
USE GEOMETRY_MOD       , ONLY : GEOMETRY
USE PARKIND1           , ONLY : JPIM, JPRB
USE YOMHOOK            , ONLY : LHOOK, DR_HOOK
USE YOMCST             , ONLY : RPI

USE YOMVAR             , ONLY : LVECADIN, LSLADREP
USE ALGORITHM_STATE_MOD, ONLY : GET_NSIM4D
USE YOMLUN             , ONLY : NULERR
USE YOMMP0             , ONLY : NPROC
USE EINT_MOD           , ONLY : SL_STRUCT
USE OML_MOD            , ONLY : OML_INCR_EVENT, OML_OMP, OML_WAIT_EVENT, OML_INCR_COUNTER

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)    ,INTENT(IN)    :: YDGEOMETRY
TYPE(MODEL_DYNAMICS_TYPE),TARGET ,INTENT(IN):: YDML_DYN
INTEGER(KIND=JPIM),INTENT(IN)    :: KDIM
INTEGER(KIND=JPIM),INTENT(IN)    :: KSTGLO
INTEGER(KIND=JPIM),INTENT(IN)    :: KST
INTEGER(KIND=JPIM),INTENT(IN)    :: KPROF
TYPE(SL_STRUCT)   ,INTENT(INOUT) :: YDSL
INTEGER(KIND=JPIM),INTENT(IN)    :: KSTABUF(YDSL%NDGSAH:YDSL%NDGENH)
LOGICAL           ,INTENT(IN)    :: LDSLHD
LOGICAL           ,INTENT(IN)    :: LDSLHDQUAD
LOGICAL           ,INTENT(IN)    :: LDSLHD_OLD
INTEGER(KIND=JPIM),INTENT(IN)    :: KTIP
INTEGER(KIND=JPIM),INTENT(IN)    :: KROT
LOGICAL           ,INTENT(IN)    :: LDPLANE
LOGICAL           ,INTENT(IN)    :: LDOCK_UP
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLSDEPI(YDSL%NDGSAH:YDSL%NDGENH)
INTEGER(KIND=JPIM),INTENT(IN)    :: KIBL
INTEGER(KIND=JPIM),INTENT(IN)    :: KDEP(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
INTEGER(KIND=JPIM),INTENT(IN)    :: KNOWENO(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSCO(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTSCO%NDIM)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLEV(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PSCO5(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTSCO%NDIM)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLEV5(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PKAPPA(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PKAPPA5(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PKAPPAT(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PKAPPAT5(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PURL0(YDSL%NASLB1,YDGEOMETRY%YRDIMV%NFLSA:YDGEOMETRY%YRDIMV%NFLEN)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVRL0(YDSL%NASLB1,YDGEOMETRY%YRDIMV%NFLSA:YDGEOMETRY%YRDIMV%NFLEN)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZRL0(YDSL%NASLB1,YDGEOMETRY%YRDIMV%NFLSA:YDGEOMETRY%YRDIMV%NFLEN)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PWRL0(YDSL%NASLB1,YDGEOMETRY%YRDIMV%NFLSA:YDGEOMETRY%YRDIMV%NFLEN)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PURL05(YDSL%NASLB1,YDGEOMETRY%YRDIMV%NFLSA:YDGEOMETRY%YRDIMV%NFLEN)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PVRL05(YDSL%NASLB1,YDGEOMETRY%YRDIMV%NFLSA:YDGEOMETRY%YRDIMV%NFLEN)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PZRL05(YDSL%NASLB1,YDGEOMETRY%YRDIMV%NFLSA:YDGEOMETRY%YRDIMV%NFLEN)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PWRL05(YDSL%NASLB1,YDGEOMETRY%YRDIMV%NFLSA:YDGEOMETRY%YRDIMV%NFLEN)
INTEGER(KIND=JPIM),INTENT(IN)    :: KVSEPC
INTEGER(KIND=JPIM),INTENT(IN)    :: KVSEPL
INTEGER(KIND=JPIM),INTENT(INOUT) :: KLOCK(:)
INTEGER(KIND=JPIM),INTENT(IN)    :: KDIM1
INTEGER(KIND=JPIM),INTENT(IN)    :: KDIM2
INTEGER(KIND=JPIM),INTENT(INOUT) :: KINC(KDIM1,KDIM2)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PINC(KDIM1,KDIM2)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCCO(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTCCO%NDIM)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PUF0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVF0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PZF0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PWF0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCCO5(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTCCO%NDIM)
INTEGER(KIND=JPIM),INTENT(IN)    :: KL0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,0:3)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLSCAW(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTLSCAW%NDIM)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PRSCAW(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTRSCAW%NDIM)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLSCAW5(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTLSCAW%NDIM)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSCAW5(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTRSCAW%NDIM)
LOGICAL, OPTIONAL ,INTENT(IN)    :: LDREP

!     ------------------------------------------------------------------

INTEGER(KIND=JPIM) :: ISSIGN(YDML_DYN%YRPTRSLB1%NFLDSLB1)

INTEGER(KIND=JPIM) :: IHOR, ISEP, IWENO, &
 & IWIS, JLEV, JROF, INCA, JFLD, IOFF, JSTAR, ILOCK, IMAXLOCK

INTEGER(KIND=JPIM),ALLOCATABLE :: IMAP(:,:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZSIGN(:,:,:,:)

LOGICAL :: LLADV5, LLREP

INTEGER(KIND=JPIM), POINTER :: ISLB1U, ISLB1V, ISLB1Z, ISLB1W

REAL(KIND=JPRB) :: ZHOOK_HANDLE
REAL(KIND=JPRB) :: ZDSTRET, ZDEPI, ZPIS2

!     ------------------------------------------------------------------

#include "abor1.intfb.h"
#include "laitli_init.intfb.h"
#include "laitliad.intfb.h"
#include "laitri_init.intfb.h"
#include "laitriad.intfb.h"
#include "laitri_weno_init.intfb.h"
#include "laitri_weno_ad.intfb.h"
#include "elarchead.intfb.h"
#include "elascawad.intfb.h"
#include "larchead.intfb.h"
#include "lascawad.intfb.h"

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('LARCINAAD',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV, &
 & YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP,  YDHSLMER=>YDGEOMETRY%YRHSLMER, YDCSGLEG=>YDGEOMETRY%YRCSGLEG, &
 & YDVAB=>YDGEOMETRY%YRVAB, YDVETA=>YDGEOMETRY%YRVETA,  YDVFE=>YDGEOMETRY%YRVFE, YDVSLETA=>YDGEOMETRY%YRVSLETA,  &
 & YDSTA=>YDGEOMETRY%YRSTA, YDLAP=>YDGEOMETRY%YRLAP, YDVSPLIP=>YDGEOMETRY%YRVSPLIP,  &
 & YDCSGEOM=>YDGEOMETRY%YRCSGEOM(KIBL), &
 & YDGSGEOM=>YDGEOMETRY%YRGSGEOM(KIBL),  YDSPGEOM=>YDGEOMETRY%YSPGEOM, YDPTRSLB1=>YDML_DYN%YRPTRSLB1,  &
 & YDSLREP=>YDML_DYN%YRSLREP,YDTCCO=>YDML_DYN%YYTCCO,YDTSCO=>YDML_DYN%YYTSCO,YDTLSCAW=>YDML_DYN%YYTLSCAW,&
 & YDTRSCAW=>YDML_DYN%YYTRSCAW,YDDYN=>YDML_DYN%YRDYN)

ASSOCIATE(NPROMA=>YDDIM%NPROMA, &
 & NFLEN=>YDDIMV%NFLEN, NFLEVG=>YDDIMV%NFLEVG, NFLSA=>YDDIMV%NFLSA, &
 & NSTTYP=>YDGEM%NSTTYP, R4JP=>YDGEM%R4JP, RC2M1=>YDGEM%RC2M1, &
 & RC2P1=>YDGEM%RC2P1, RLOCEN=>YDGEM%RLOCEN, RMUCEN=>YDGEM%RMUCEN, &
 & RSTRET=>YDGEM%RSTRET, LSLDP_CURV=>YDDYN%LSLDP_CURV, &
 & RIPI=>YDHSLMER%RIPI, RSLD=>YDHSLMER%RSLD, RSLDW=>YDHSLMER%RSLDW, GAMMA_WENO=>YDVSLETA%GAMMA_WENO, &
 & MSLB1UR0=>YDPTRSLB1%MSLB1UR0, MSLB1VR0=>YDPTRSLB1%MSLB1VR0, &
 & MSLB1ZR0=>YDPTRSLB1%MSLB1ZR0, MSLB1WR0=>YDPTRSLB1%MSLB1WR0, &
 & MSLB1UR00=>YDPTRSLB1%MSLB1UR00, MSLB1VR00=>YDPTRSLB1%MSLB1VR00, &
 & MSLB1ZR00=>YDPTRSLB1%MSLB1ZR00, MSLB1WR00=>YDPTRSLB1%MSLB1WR00, &
 & NFLDSLB1=>YDPTRSLB1%NFLDSLB1, RPARSL1=>YDPTRSLB1%RPARSL1, &
 & NADCORE=>YDSLREP%NADCORE, &
 & NRLEVX=>YDVSLETA%NRLEVX, NVAUTF=>YDVSLETA%NVAUTF, VCUICO=>YDVSLETA%VCUICO, &
 & VRLEVX=>YDVSLETA%VRLEVX, VSLD=>YDVSLETA%VSLD, VSLDW=>YDVSLETA%VSLDW)
!     ------------------------------------------------------------------

!*       1.    PRELIMINARY INITIALISATIONS.
!              ----------------------------

IF (PRESENT(LDREP)) THEN
  LLREP=LDREP
ELSE
  LLREP=.false.
ENDIF

! Set SL pointers 
IF (LLREP) THEN
  ISLB1U => MSLB1UR00
  ISLB1V => MSLB1VR00
  ISLB1Z => MSLB1ZR00
  ISLB1W => MSLB1WR00
ELSE
  ISLB1U => MSLB1UR0
  ISLB1V => MSLB1VR0
  ISLB1Z => MSLB1ZR0
  ISLB1W => MSLB1WR0
ENDIF

ZDSTRET=2.0_JPRB*RSTRET
ZDEPI=2.0_JPRB*RPI
ZPIS2=0.5_JPRB*RPI

IHOR=0    !!! for revised application of LAIDDIAD

IWENO=1

DO JFLD=1,NFLDSLB1
  IF(     RPARSL1(JFLD) ==  1.0_JPRB )THEN
    ISSIGN(JFLD)=1
  ELSEIF( RPARSL1(JFLD) == -1.0_JPRB )THEN
    ISSIGN(JFLD)=2
  ELSE
    CALL ABOR1("LARCINAAD: RPARSL1 invalid sign")
  ENDIF
ENDDO

!     * Input variable IWIS for LASCAW.
!     * Computation of ISEP
IF (KTIP == 1) THEN
  ! * trajectory research.
  IF (YDML_DYN%YRDYNA%LHOISLT) THEN
    IWIS=102
    ISEP=KVSEPC
    IF (YDML_DYN%YRDYNA%LSLTVWENO) THEN
      IWENO=3
      ISEP=KVSEPC+2
    ENDIF
  ELSE
    IWIS=101
    ISEP=KVSEPL
  ENDIF
ELSEIF (KTIP == 3) THEN
  ! * origin point interpolations.
  IF (YDML_DYN%YRDYNA%LRHSVWENO) THEN
    IWIS=106
    IWENO=3
    ISEP=KVSEPC+2
  ELSE
    IWIS=103
    ISEP=KVSEPC
  ENDIF
ELSE
  IWIS=-999
  CALL ABOR1('LARCINAAD: WRONG VALUE FOR IWIS')
ENDIF

!     ------------------------------------------------------------------

!*       3.    INTERPOLATIONS OF WIND FOR TRAJECTORY RESEARCH.
!              -----------------------------------------------

IF (KTIP == 1) THEN

  LLADV5=.false. ! not applicable for the trajectory research
  INCA=1
  ILOCK=0
  IMAXLOCK= SIZE(KLOCK)

  ! ZERO COEFF ARRAYS:
  !CDIR COLLAPSE
  PLSCAW(:,:,:)=0.0_JPRB
  !CDIR COLLAPSE
  PRSCAW(:,:,:)=0.0_JPRB

  IF (YDML_DYN%YRDYNA%LSLTVWENO) THEN


    !* High order interpolation with WENO along vertical
    IF( LSLADREP )THEN
      ALLOCATE(ZSIGN(NPROMA,56,NFLEVG,2))
      ALLOCATE(IMAP (NPROMA,56,NFLEVG))
      CALL LAITRI_WENO_INIT(YDML_DYN%YRSLREP,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,KL0,KNOWENO,IMAP,ZSIGN)
    ELSE
      ALLOCATE(ZSIGN(1,1,1,2))
      ALLOCATE(IMAP (1,1,1))
    ENDIF
    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    CALL LAITRI_WENO_AD(YDDYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG, & 
     & NFLSA,NFLEN,ISLB1W,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1W)),KDEP,LVECADIN,LDPLANE,&
     & PLSCAW(1,1,YDTLSCAW%M_WDLAT),PRSCAW(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PRSCAW5(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLO),PRSCAW5(1,1,YDTRSCAW%M_WCLO(1)), &
     & KL0,KNOWENO,PRSCAW(1,1,YDTRSCAW%M_CW),PRSCAW5(1,1,YDTRSCAW%M_CW), &
     & PRSCAW(1,1,YDTRSCAW%M_WVINTW),PRSCAW5(1,1,YDTRSCAW%M_WVINTW), &
     & KINC(INCA,1),PINC(INCA,1),KDIM,PWRL0,PWRL05,PWF0)  
    PWF0(KST:KPROF,1:NFLEVG)=0._JPRB
    INCA=INCA+56
    IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

    IF (LSLDP_CURV) THEN
      IF (OML_OMP().AND..NOT.LVECADIN ) THEN
        CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
        CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
      ENDIF
      CALL LAITRI_WENO_AD(YDDYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG, & 
       & NFLSA,NFLEN,ISLB1Z,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1Z)),KDEP,LVECADIN,LDPLANE,&
       & PLSCAW(1,1,YDTLSCAW%M_WDLAT),PRSCAW(1,1,YDTRSCAW%M_WCLA(1)), &
       & PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)), &
       & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PRSCAW5(1,1,YDTRSCAW%M_WCLA(1)), &
       & PLSCAW5(1,1,YDTLSCAW%M_WDLO),PRSCAW5(1,1,YDTRSCAW%M_WCLO(1)), &
       & KL0,KNOWENO,PRSCAW(1,1,YDTRSCAW%M_CW),PRSCAW5(1,1,YDTRSCAW%M_CW), &
       & PRSCAW(1,1,YDTRSCAW%M_WVINTW),PRSCAW5(1,1,YDTRSCAW%M_WVINTW), &
       & KINC(INCA,1),PINC(INCA,1),KDIM,PZRL0,PZRL05,PZF0)  
      PZF0(KST:KPROF,1:NFLEVG)=0._JPRB
      INCA=INCA+56
      IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))
    ENDIF

    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    CALL LAITRI_WENO_AD(YDDYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG, & 
     & NFLSA,NFLEN,ISLB1V,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1V)),KDEP,LVECADIN,LDPLANE,&
     & PLSCAW(1,1,YDTLSCAW%M_WDLAT),PRSCAW(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PRSCAW5(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLO),PRSCAW5(1,1,YDTRSCAW%M_WCLO(1)), &
     & KL0,KNOWENO,PRSCAW(1,1,YDTRSCAW%M_CW),PRSCAW5(1,1,YDTRSCAW%M_CW), &
     & PRSCAW(1,1,YDTRSCAW%M_WVINTW),PRSCAW5(1,1,YDTRSCAW%M_WVINTW), &
     & KINC(INCA,1),PINC(INCA,1),KDIM,PVRL0,PVRL05,PVF0)  
    PVF0(KST:KPROF,1:NFLEVG)=0._JPRB
    INCA=INCA+56
    IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    CALL LAITRI_WENO_AD(YDDYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG, & 
     & NFLSA,NFLEN,ISLB1U,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1U)),KDEP,LVECADIN,LDPLANE,&
     & PLSCAW(1,1,YDTLSCAW%M_WDLAT),PRSCAW(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PRSCAW5(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLO),PRSCAW5(1,1,YDTRSCAW%M_WCLO(1)), &
     & KL0,KNOWENO,PRSCAW(1,1,YDTRSCAW%M_CW),PRSCAW5(1,1,YDTRSCAW%M_CW), &
     & PRSCAW(1,1,YDTRSCAW%M_WVINTW),PRSCAW5(1,1,YDTRSCAW%M_WVINTW), &
     & KINC(INCA,1),PINC(INCA,1),KDIM,PURL0,PURL05,PUF0)  
    PUF0(KST:KPROF,1:NFLEVG)=0._JPRB
    INCA=INCA+56
    IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))


    IF (LVECADIN) THEN

      INCA=INCA-1

      IF(KDIM  /=  INCA) THEN
        WRITE(NULERR,*) "KDIM,INCA=",KDIM,INCA
        CALL ABOR1('LARCINAAD: KDIM /= INCA')
      ENDIF
  
    ENDIF

    IF( .NOT.LSLADREP .AND. GET_NSIM4D() == 0 .AND. YDSL%LSLONDEM .AND. NPROC > 1)THEN
  
      ! The trick applied to LAM models doesn't 100% comply with this.
      DO JLEV=1,NFLEVG
!OCL NOVREC
!DIR$ IVDEP
!CDIR NODEP
        DO JROF=KST,KPROF
          !IOFF=MOD(KL0(JROF,JLEV,1)+1-YDSL%NASLB1+MAX(0,KNOWENO(JROF,JLEV))*YDSL%NASLB1,YDSL%NASLB1)+1
          !YDSL%MASK_SL1(IOFF)=1
          !IOFF=MOD(KL0(JROF,JLEV,2)+1-YDSL%NASLB1+MAX(0,KNOWENO(JROF,JLEV))*YDSL%NASLB1,YDSL%NASLB1)+1
          !YDSL%MASK_SL1(IOFF)=1
          !IOFF=MOD(KL0(JROF,JLEV,0)-1,YDSL%NASLB1)+1
          !YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,0),YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,0)+1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          !IOFF=MOD(KL0(JROF,JLEV,0)+2,YDSL%NASLB1)+1
          !YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,1)-1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,1),YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,1)+1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,1)+2,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,2)-1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,2),YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,2)+1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,2)+2,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          !IOFF=MOD(KL0(JROF,JLEV,3)-1,YDSL%NASLB1)+1
          !YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,3),YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,3)+1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          !IOFF=MOD(KL0(JROF,JLEV,3)+2,YDSL%NASLB1)+1
          !YDSL%MASK_SL1(IOFF)=1
          !IOFF=MOD(KL0(JROF,JLEV,1)+1+4*YDSL%NASLB1+MIN(0,KNOWENO(JROF,JLEV))*YDSL%NASLB1,YDSL%NASLB1)+1
          !YDSL%MASK_SL1(IOFF)=1
          !IOFF=MOD(KL0(JROF,JLEV,2)+1+4*YDSL%NASLB1+MIN(0,KNOWENO(JROF,JLEV))*YDSL%NASLB1,YDSL%NASLB1)+1
          !YDSL%MASK_SL1(IOFF)=1

        ENDDO
      ENDDO

    ENDIF

    IF( LSLADREP .AND. GET_NSIM4D() == 0 .AND. NPROC > 1  )THEN
      DO JLEV=1,NFLEVG
        DO JSTAR=1,56
!OCL NOVREC
!DIR$ IVDEP
!CDIR NODEP
          DO JROF=KST,KPROF
            IOFF=MOD(IMAP(JROF,JSTAR,JLEV)-1,YDSL%NASLB1)+1
            IF( YDSL%LSLCORE(IOFF) )THEN
              ! NSLCORE POINT HAS BEEN UPDATED
              YDSL%MASK_SLTOT(NADCORE(KSTGLO+JROF-1))=1
            ENDIF
          ENDDO
        ENDDO
      ENDDO
    ENDIF

  ELSEIF (YDML_DYN%YRDYNA%LHOISLT) THEN
    !*  High order interpolation on 32 point stencil
    IF( LSLADREP )THEN
      ALLOCATE(ZSIGN(NPROMA,32,NFLEVG,2))
      ALLOCATE(IMAP (NPROMA,32,NFLEVG))
      CALL LAITRI_INIT(YDML_DYN%YRSLREP,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,KL0,IMAP,ZSIGN)
    ELSE
      ALLOCATE(ZSIGN(1,1,1,2))
      ALLOCATE(IMAP (1,1,1))
    ENDIF

    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    CALL LAITRIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG, & 
     & NFLSA,NFLEN,ISLB1W,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1W)),KDEP,LVECADIN,LLADV5,LDPLANE,&
     & PLSCAW(1,1,YDTLSCAW%M_WDLAT),PRSCAW(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PRSCAW5(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLO),PRSCAW5(1,1,YDTRSCAW%M_WCLO(1)), &
     & KL0,PRSCAW(1,1,YDTRSCAW%M_WVINTW),PRSCAW5(1,1,YDTRSCAW%M_WVINTW), &
     & KINC(INCA,1),PINC(INCA,1),KDIM,PWRL0,PWRL05,PWF0)  
    PWF0(KST:KPROF,1:NFLEVG)=0._JPRB
    INCA=INCA+32
    IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

    IF (LSLDP_CURV) THEN
      IF (OML_OMP().AND..NOT.LVECADIN ) THEN
        CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
        CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
      ENDIF
      CALL LAITRIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG, & 
       & NFLSA,NFLEN,ISLB1Z,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1Z)),KDEP,LVECADIN,LLADV5,LDPLANE,&
       & PLSCAW(1,1,YDTLSCAW%M_WDLAT),PRSCAW(1,1,YDTRSCAW%M_WCLA(1)), &
       & PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)), &
       & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PRSCAW5(1,1,YDTRSCAW%M_WCLA(1)), &
       & PLSCAW5(1,1,YDTLSCAW%M_WDLO),PRSCAW5(1,1,YDTRSCAW%M_WCLO(1)), &
       & KL0,PRSCAW(1,1,YDTRSCAW%M_WVINTW),PRSCAW5(1,1,YDTRSCAW%M_WVINTW), &
       & KINC(INCA,1),PINC(INCA,1),KDIM,PZRL0,PZRL05,PZF0)  
      PZF0(KST:KPROF,1:NFLEVG)=0._JPRB
      INCA=INCA+32
      IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))
    ENDIF

    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    CALL LAITRIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG, & 
     & NFLSA,NFLEN,ISLB1V,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1V)),KDEP,LVECADIN,LLADV5,LDPLANE,&
     & PLSCAW(1,1,YDTLSCAW%M_WDLAT),PRSCAW(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PRSCAW5(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLO),PRSCAW5(1,1,YDTRSCAW%M_WCLO(1)), &
     & KL0,PRSCAW(1,1,YDTRSCAW%M_WVINTW),PRSCAW5(1,1,YDTRSCAW%M_WVINTW), &
     & KINC(INCA,1),PINC(INCA,1),KDIM,PVRL0,PVRL05,PVF0)  
    PVF0(KST:KPROF,1:NFLEVG)=0._JPRB
    INCA=INCA+32
    IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    CALL LAITRIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG, & 
     & NFLSA,NFLEN,ISLB1U,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1U)),KDEP,LVECADIN,LLADV5,LDPLANE,&
     & PLSCAW(1,1,YDTLSCAW%M_WDLAT),PRSCAW(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PRSCAW5(1,1,YDTRSCAW%M_WCLA(1)), &
     & PLSCAW5(1,1,YDTLSCAW%M_WDLO),PRSCAW5(1,1,YDTRSCAW%M_WCLO(1)), &
     & KL0,PRSCAW(1,1,YDTRSCAW%M_WVINTW),PRSCAW5(1,1,YDTRSCAW%M_WVINTW), &
     & KINC(INCA,1),PINC(INCA,1),KDIM,PURL0,PURL05,PUF0)  
    PUF0(KST:KPROF,1:NFLEVG)=0._JPRB
    INCA=INCA+32
    IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

    IF (LVECADIN) THEN

      INCA=INCA-1

      IF(KDIM  /=  INCA) THEN
        WRITE(NULERR,*) "KDIM,INCA=",KDIM,INCA
        CALL ABOR1('LARCINAAD: KDIM /= INCA')
      ENDIF
  
    ENDIF

    IF( .NOT.LSLADREP .AND. GET_NSIM4D() == 0 .AND. YDSL%LSLONDEM .AND. NPROC > 1)THEN
  
      ! The trick applied to LAM models doesn't 100% comply with this. 
      ! The points outside this mask are anyway not updated by any real information.
      DO JLEV=1,NFLEVG
!OCL NOVREC
!DIR$ IVDEP
!CDIR NODEP
        DO JROF=KST,KPROF
          IOFF=MOD(KL0(JROF,JLEV,0),YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,0)+1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,1)-1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,1),YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,1)+1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,1)+2,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,2)-1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,2),YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,2)+1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,2)+2,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,3),YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,3)+1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
        ENDDO
      ENDDO


    ENDIF

    IF( LSLADREP .AND. GET_NSIM4D() == 0 .AND. NPROC > 1  )THEN
      DO JLEV=1,NFLEVG
        DO JSTAR=1,32
!OCL NOVREC
!DIR$ IVDEP
!CDIR NODEP
          DO JROF=KST,KPROF
            IOFF=MOD(IMAP(JROF,JSTAR,JLEV)-1,YDSL%NASLB1)+1
            IF( YDSL%LSLCORE(IOFF) )THEN
              ! NSLCORE POINT HAS BEEN UPDATED
              YDSL%MASK_SLTOT(NADCORE(KSTGLO+JROF-1))=1
            ENDIF
          ENDDO
        ENDDO
      ENDDO
    ENDIF
  
  ELSE
    !* Trilinear interpolations.
    IF( LSLADREP )THEN
      ALLOCATE(ZSIGN(NPROMA,8 ,NFLEVG,2))
      ALLOCATE(IMAP (NPROMA,8 ,NFLEVG))
      CALL LAITLI_INIT(YDML_DYN%YRSLREP,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,KL0,IMAP,ZSIGN)
    ELSE
      ALLOCATE(ZSIGN(1,1,1,2))
      ALLOCATE(IMAP (1,1,1))
    ENDIF

    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    CALL LAITLIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
     & NFLEN,ISLB1W,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1W)),&
     & LVECADIN,PLSCAW(1,1,YDTLSCAW%M_WDLAT),PLSCAW(1,1,YDTLSCAW%M_WDLO+1),KL0(1,1,1),PLSCAW(1,1,YDTLSCAW%M_WDVER),&
     & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PLSCAW5(1,1,YDTLSCAW%M_WDLO+1),PLSCAW5(1,1,YDTLSCAW%M_WDVER),&
     & KINC(INCA,1),PINC(INCA,1),KDIM,PWRL0,PWRL05,PWF0)  
    PWF0(KST:KPROF,1:NFLEVG)=0._JPRB
    INCA=INCA+8
    IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

    IF (LSLDP_CURV) THEN
      IF (OML_OMP().AND..NOT.LVECADIN ) THEN
        CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
        CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
      ENDIF
      CALL LAITLIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
       & NFLEN,ISLB1Z,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1Z)),&
       & LVECADIN,PLSCAW(1,1,YDTLSCAW%M_WDLAT),PLSCAW(1,1,YDTLSCAW%M_WDLO+1),KL0(1,1,1),PLSCAW(1,1,YDTLSCAW%M_WDVER),&
       & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PLSCAW5(1,1,YDTLSCAW%M_WDLO+1),PLSCAW5(1,1,YDTLSCAW%M_WDVER),&
       & KINC(INCA,1),PINC(INCA,1),KDIM,PZRL0,PZRL05,PZF0)  
      PZF0(KST:KPROF,1:NFLEVG)=0._JPRB
      INCA=INCA+8
      IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))
    ENDIF

    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    CALL LAITLIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
     & NFLEN,ISLB1V,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1V)),&
     & LVECADIN,PLSCAW(1,1,YDTLSCAW%M_WDLAT),PLSCAW(1,1,YDTLSCAW%M_WDLO+1),KL0(1,1,1),PLSCAW(1,1,YDTLSCAW%M_WDVER),&
     & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PLSCAW5(1,1,YDTLSCAW%M_WDLO+1),PLSCAW5(1,1,YDTLSCAW%M_WDVER),&
     & KINC(INCA,1),PINC(INCA,1),KDIM,PVRL0,PVRL05,PVF0)  
    PVF0(KST:KPROF,1:NFLEVG)=0._JPRB
    INCA=INCA+8
    IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    CALL LAITLIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
     & NFLEN,ISLB1U,ISEP,IMAP,ZSIGN(1,1,1,ISSIGN(ISLB1U)),&
     & LVECADIN,PLSCAW(1,1,YDTLSCAW%M_WDLAT),PLSCAW(1,1,YDTLSCAW%M_WDLO+1),KL0(1,1,1),PLSCAW(1,1,YDTLSCAW%M_WDVER),&
     & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PLSCAW5(1,1,YDTLSCAW%M_WDLO+1),PLSCAW5(1,1,YDTLSCAW%M_WDVER),&
     & KINC(INCA,1),PINC(INCA,1),KDIM,PURL0,PURL05,PUF0)  
    PUF0(KST:KPROF,1:NFLEVG)=0._JPRB
    INCA=INCA+8
    IF (OML_OMP().AND..NOT.LVECADIN.AND.LDOCK_UP) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))


    IF (LVECADIN) THEN

      INCA=INCA-1

      IF(KDIM  /=  INCA) THEN
        WRITE(NULERR,*) "KDIM,INCA=",KDIM,INCA
        CALL ABOR1('LARCINAAD: KDIM /= INCA')
      ENDIF
  
    ENDIF

    IF( .NOT.LSLADREP .AND. GET_NSIM4D() == 0 .AND. YDSL%LSLONDEM .AND. NPROC > 1)THEN
  
      DO JLEV=1,NFLEVG
!OCL NOVREC
!DIR$ IVDEP
!CDIR NODEP
        DO JROF=KST,KPROF
          IOFF=MOD(KL0(JROF,JLEV,1),YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,1)+1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,2),YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
          IOFF=MOD(KL0(JROF,JLEV,2)+1,YDSL%NASLB1)+1
          YDSL%MASK_SL1(IOFF)=1
        ENDDO
      ENDDO

    ENDIF

    IF( LSLADREP .AND. GET_NSIM4D() == 0 .AND. NPROC > 1  )THEN
      DO JLEV=1,NFLEVG
        DO JSTAR=1,8
!OCL NOVREC
!DIR$ IVDEP
!CDIR NODEP
          DO JROF=KST,KPROF
            IOFF=MOD(IMAP(JROF,JSTAR,JLEV)-1,YDSL%NASLB1)+1
            IF( YDSL%LSLCORE(IOFF) )THEN
              ! NSLCORE POINT HAS BEEN UPDATED
              YDSL%MASK_SLTOT(NADCORE(KSTGLO+JROF-1))=1
            ENDIF
          ENDDO
        ENDDO
      ENDDO
    ENDIF

  ENDIF ! linear interpolation

ENDIF

!     ------------------------------------------------------------------

!*       2.    COMPUTATION OF LAT LON OF THE INTERPOLATION POINT.
!              IF KROT=1 COMPUTATION OF THE WIND DISPLACEMENT MATRIX
!              FROM THE INTERPOLATION POINT TO THE FINAL POINT.
!              ( T FOR LATITUDE THETA, L FOR LONGITUDE LAMBDA).
!              PCCO(.,.,YDTCCO%M_RQX) = ( 1 / (1+cos(PHI)) )
!                  *( cos(TG)*cos(T) + (1+sin(TG)*sin(T))*cos(L-LG) )
!              PCCO(.,.,YDTCCO%M_RQY) = (-1 / (1+cos(PHI)) )
!                  *( sin(TG)+sin(T) ) * sin(L-LG)
!     ------------------------------------------------------------------

IF (LDPLANE) THEN

  CALL ELASCAWAD(YDDYN,YDSL,NPROMA,KST,KPROF,NFLEVG,&
   & NFLSA,IWIS,IHOR,&
   & LDSLHD,LDSLHDQUAD,LDSLHD_OLD,&
   & PSCO(1,1,YDTSCO%M_COSCO),PSCO(1,1,YDTSCO%M_SINCO),PLEV,PKAPPA,PKAPPAT,&
   & PSCO5(1,1,YDTSCO%M_COSCO),PSCO5(1,1,YDTSCO%M_SINCO),PLEV5,PKAPPA5,PKAPPAT5,&
   & YDVETA%VETAF,NVAUTF,VCUICO,VSLD,VSLDW,NRLEVX,VRLEVX,&
   & PLSCAW(1,1,YDTLSCAW%M_WDLAT),PRSCAW(1,1,YDTRSCAW%M_WCLA(1)),PRSCAW(1,1,YDTRSCAW%M_WCLASLD(1)),&
   & PRSCAW(1,1,YDTRSCAW%M_WCLASLT),&
   & PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)),PRSCAW(1,1,YDTRSCAW%M_WCLOSLD(1)),&
   & PRSCAW(1,1,YDTRSCAW%M_WCLOSLT),&
   & PLSCAW(1,1,YDTLSCAW%M_WDVER),PRSCAW(1,1,YDTRSCAW%M_WVINTW),PRSCAW(1,1,YDTRSCAW%M_WVINTWSLD),&
   & PRSCAW(1,1,YDTRSCAW%M_WVINTWSLT))

  IF (KROT == 1) THEN
    CALL ELARCHEAD(YDML_DYN,NPROMA,KST,KPROF,NFLEVG,YDSL,YDGEOMETRY%YREGSL,YDGEOMETRY%YREGEO,YDGSGEOM,PSCO,PCCO,PSCO5,PCCO5)
  ENDIF

ELSE

  CALL LASCAWAD(YDSL,NPROMA,KST,KPROF,NFLEVG,&
   & NFLSA,IWIS,IHOR,IWENO,&
   & LDSLHD,LDSLHDQUAD,LDSLHD_OLD,YDDYN%LSLHDHEAT,&
   & R4JP,ZPIS2,PLSDEPI,YDCSGLEG%RLATI(YDSL%NDGSAH:),&
   & RIPI(YDSL%NDGSAH:YDSL%NDGENH,1:3),RSLD(YDSL%NDGSAH:YDSL%NDGENH,1:3),RSLDW(1,1,YDSL%NDGSAH),&
   & GAMMA_WENO,&
   & PCCO(1,1,YDTCCO%M_RLON),PCCO(1,1,YDTCCO%M_RLAT),PLEV,PKAPPA,PKAPPAT,&
   & PCCO5(1,1,YDTCCO%M_RLON),PCCO5(1,1,YDTCCO%M_RLAT),PLEV5,PKAPPA5,PKAPPAT5,&
   & PLSCAW5(1,1,YDTLSCAW%M_WDVER),&
   & YDVETA%VETAF,NVAUTF,VCUICO,VSLD,VSLDW,NRLEVX,VRLEVX,&
   & PLSCAW(1,1,YDTLSCAW%M_WDLAT),PRSCAW(1,1,YDTRSCAW%M_WCLA(1)),PRSCAW(1,1,YDTRSCAW%M_WCLASLD(1)),&
   & PRSCAW(1,1,YDTRSCAW%M_WCLASLT),&
   & PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)),PRSCAW(1,1,YDTRSCAW%M_WCLOSLD(1)),&
   & PRSCAW(1,1,YDTRSCAW%M_WCLOSLT),PRSCAW(1,1,YDTRSCAW%M_CW),&
   & PLSCAW(1,1,YDTLSCAW%M_WDVER),PRSCAW(1,1,YDTRSCAW%M_WVINTW),PRSCAW(1,1,YDTRSCAW%M_WVINTWSLD),&
   & PRSCAW(1,1,YDTRSCAW%M_WVINTWSLT))

  CALL LARCHEAD(YDML_DYN%YYTCCO,YDML_DYN%YYTSCO,NPROMA,KST,KPROF,NFLEVG,&
   & NSTTYP,ZDSTRET,RC2M1,RC2P1,RPI,ZDEPI,&
   & RLOCEN,RMUCEN,YDGSGEOM,YDCSGEOM,&
   & PSCO,PSCO5,KROT,PCCO)

ENDIF

IF(ALLOCATED(ZSIGN)) DEALLOCATE(ZSIGN)
IF(ALLOCATED(IMAP )) DEALLOCATE(IMAP )

!     ------------------------------------------------------------------

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('LARCINAAD',1,ZHOOK_HANDLE)
END SUBROUTINE LARCINAAD
