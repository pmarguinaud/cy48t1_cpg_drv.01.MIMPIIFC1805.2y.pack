!OPTION! -pvctl noouterunroll -pvctl noouterstrip
SUBROUTINE LARCINBAD(YDGEOMETRY,YDGMV,YGFL,YDML_DYN,KSTGLO,KST,KPROF,YDSL,LD2TLFF1,KDIM,KDEP,KLOCK,KL0,KLH0,&
 & PLSCAW,PRSCAW,PB1,PB15,KNOWENO,&
 & PINC,KINC,KDIM1,KDIM2,&
 & PGMVF,PDP,PGFLF,PCF,PUFZ,PVFZ,PLSCAW5,PRSCAW5)

!**** *LARCINBAD - semi-LAgrangian scheme:   (adjoint version - Part B)

!     Purpose.
!     --------
!       - adjoints of interpolations at origin point.

!       Second part of from 'old' LAPINEAD

!**   Interface.
!     ----------
!        *CALL* *LARCINBAD(......)

!        Explicit arguments :
!        --------------------

!          KSTGLO  - global offset into nproma buffer.
!          KST     - first element where computations are performed.
!          KPROF   - depth of work.
!          YDSL    - SL_STRUCT definition
!          LD2TLFF1- .T./.F.: Refined treatement of (2*Omega Vec r) at
!                    the origin point when there is t-dt (or t in SL2TL)
!                    physics / Other cases.
!          KDIM    - Number of independent updates
!          KDEP    - indication of the interpolation stencil latitudial
!                    dependences (used for LVECADIN=.T. option in ALADIN)
!          KLOCK   - ??? (used for OpenMP purposes).
!          KL0     - index of the four western points
!                    of the 16 points interpolation grid.
!          KLH0    - second value of index of the four western points
!                    of the 16 points interpolation grid if needed.
!          PLSCAW  - linear weights (distances) for interpolations.
!          PRSCAW  - non-linear weights for interpolations.
!          PB1     - "SLBUF1" buffer for interpolations.
!          PB15    - "SLBUF1" buffer for interpolations (trajectory).
!          KNOWENO - boundary condition treatment for WENO
!          PGMVF   - Interpolated quantity at O for GMV.
!          PDP     - Interpolated 2D term at O for continuity equation.
!          PGFLF   - Interpolated quantity at O for GFL
!          PCF     - Interpolated 3D quantity at O in the continuity equation.
!          PUFZ and PVFZ for SL2TL scheme:
!          PUFZ    - Interpolated U-wind at O for L2TLFF=.T. option.
!          PVFZ    - Interpolated V-wind at O for L2TLFF=.T. option.
!          KDIM1,KDIM2 - dimensions of KINC, PINC
!          KINC    - addresses of interpolation increments in global buffer
!          PINC    - interpolation increments to global buffer (vector only)

!        TRAJECTORY INPUT:
!          PLSCAW5 - linear weights (distances) for interpolations (trajectory).
!          PRSCAW5 - non-linear weights for interpolations (trajectory).

!        Implicit arguments :
!        --------------------

!     Method.
!     -------
!        See documentation

!     Externals.
!     ----------

!        Called by LAPINEBAD
!        Calls: see below.

!     Reference.
!     ----------

!     Author.
!     -------
!        D. Salmond (ECMWF)

!     Modifications.
!     --------------
!      Original: 05/02/05
!      D.Salmond   08-Feb-2005 New LARCINBAD
!      C.Temperton 05/03/03: Re-use previous results of LARCHE
!      C.Temperton 05/03/07: Re-use previous results of LASCAW
!      F. Vana 06/12/12: - LRPLANE=.T. (special treatment for LVECADIN=.T.)
!                        - NEC-SX optimization
!      Modified 19-Mar-2007 K. Yessad: reorder according to LARCINB.
!      F. Vana 17-Jul-2007 - cleaning
!      E.Holm      07/06/27: Option to advect without wind increments (LADV5)
!      NEC      11-Dec-2007 Optimizations
!      G.Mozdzynski 21-Feb-2008: Use of locks made dynamic for performance
!      F. Vana 13-Aug-2008 - weights driven interpolation, unification
!                            of LAM and spherical interpolation for vect.
!      K. Yessad Nov 2008: rationalisation of dummy argument interfaces
!      F. Vana : 11-Dec-2008 OpenMP for vector platforms
!      E. Sevault, R. El Khatib & NEC  06-May-2009 : SX9 portability fix : add
!            ",VOB" to VOVERTAKE directives (gather operations handled 
!            differently on SX8 and SX9)
!      E. Sevault 18-May-2009 : SX9 compiler workaround : optimisations 
!            "outerunroll" and "outerstrip" manually switched off to prevent
!            unexpected numerical variations. Note that this workaround may
!            be irrelevent when the source code of this subroutine is deeply
!            re-written.
!      K. Yessad (Nov 2009): routine renaming (LAI..TLAD -> LAI..AD).
!      K. Yessad Nov 2009: rationalisation of dummy argument interfaces: PGMVF
!      K. Yessad (Jan 2011): introduce INTDYN_MOD structures.
!      G.Mozdzynski (Jan 2011): OOPS cleaning, use of derived type SL_STRUCT
!      F. Vana  13-Feb-2014  distinguish between heat and momentum SLHD
!      T. Wilhelmsson and K. Yessad (Oct 2013) Geometry and setup refactoring.
!      M. Diamantakis (Feb 2016): Introduce call to LAITRE_GFL_AD for GFL vars 
!      F. Vana  23-Jan-2018: Change the order of interpolation to match the TL
!                            code (in reverse order).
!      F. Vana   October 2018: better OpenMP support
!      F. Vana 25-Feb-2019: Vertical quintic interpolation
!     ------------------------------------------------------------------

USE MODEL_DYNAMICS_MOD , ONLY : MODEL_DYNAMICS_TYPE
USE GEOMETRY_MOD       , ONLY : GEOMETRY
USE YOMGMV             , ONLY : TGMV
USE PARKIND1           , ONLY : JPIM, JPRB
USE YOMHOOK            , ONLY : LHOOK,DR_HOOK
USE YOM_YGFL           , ONLY : TYPE_GFLD
USE YOMDYNA            , ONLY : YRDYNA
USE YOMVAR             , ONLY : LVECADIN, LSLADREP
USE ALGORITHM_STATE_MOD  , ONLY : GET_NSIM4D
USE YOMLUN             , ONLY : NULERR
USE YOMCT0             , ONLY : LRPLANE
USE YOMMP0             , ONLY : NPROC
USE OML_MOD            , ONLY : OML_INCR_EVENT, OML_OMP, OML_WAIT_EVENT, OML_INCR_COUNTER
USE EINT_MOD           , ONLY : SL_STRUCT

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)    ,INTENT(IN)    :: YDGEOMETRY
TYPE(TGMV)        ,INTENT(INOUT) :: YDGMV
TYPE(MODEL_DYNAMICS_TYPE),INTENT(IN):: YDML_DYN
TYPE(TYPE_GFLD)   ,INTENT(IN)    :: YGFL
INTEGER(KIND=JPIM),INTENT(IN)    :: KSTGLO 
INTEGER(KIND=JPIM),INTENT(IN)    :: KST 
INTEGER(KIND=JPIM),INTENT(IN)    :: KPROF 
TYPE(SL_STRUCT)   ,INTENT(INOUT) :: YDSL
LOGICAL           ,INTENT(IN)    :: LD2TLFF1 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDIM 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDEP(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
INTEGER(KIND=JPIM),INTENT(INOUT) :: KLOCK(:)
INTEGER(KIND=JPIM),INTENT(IN)    :: KL0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,0:3)
INTEGER(KIND=JPIM),INTENT(IN)    :: KLH0(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,0:3)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLSCAW(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTLSCAW%NDIM)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PRSCAW(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTRSCAW%NDIM)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PB1(YDSL%NASLB1,YDML_DYN%YRPTRSLB1%NFLDSLB1)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PB15(YDSL%NASLB1,YDML_DYN%YRPTRSLB15%NFLDSLB15)
INTEGER(KIND=JPIM),INTENT(IN)    :: KNOWENO(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
INTEGER(KIND=JPIM),INTENT(OUT)   :: KINC(KDIM1,KDIM2)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PINC(KDIM1,KDIM2)
INTEGER(KIND=JPIM),INTENT(IN)    :: KDIM1 
INTEGER(KIND=JPIM),INTENT(IN)    :: KDIM2 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGMVF(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGMV%YGP%NDIM)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PDP(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGFLF(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YGFL%NUMFLDS) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCF(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PUFZ(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG) 
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVFZ(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLSCAW5(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTLSCAW%NDIM)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRSCAW5(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDML_DYN%YYTRSCAW%NDIM)
!     ------------------------------------------------------------------
INTEGER(KIND=JPIM) :: ISIGN(YDML_DYN%YRPTRSLB1%NFLDSLB1)

INTEGER(KIND=JPIM) :: ISEP,&
 & JLEV, JROF, INCA, JFLD, JGFL, IOFF, JSTAR, IPOI, ILOCK, IMAXLOCK

LOGICAL         :: LLADV5, LLSLHD_P, LLMOM

REAL(KIND=JPRB),ALLOCATABLE :: ZSIGN8 (:,:,:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZSIGN12(:,:,:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZSIGN32(:,:,:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZSIGN56(:,:,:,:)

INTEGER(KIND=JPIM),ALLOCATABLE :: IMAP8 (:,:,:)
INTEGER(KIND=JPIM),ALLOCATABLE :: IMAP12(:,:,:)
INTEGER(KIND=JPIM),ALLOCATABLE :: IMAP32(:,:,:)
INTEGER(KIND=JPIM),ALLOCATABLE :: IMAP56(:,:,:)
REAL(KIND=JPRB) :: ZHOOK_HANDLE
INTEGER(KIND=JPIM) :: IERR

!     ------------------------------------------------------------------

#include "abor1.intfb.h"
#include "laiddi_init.intfb.h"
#include "laiddiad.intfb.h"
#include "laitli_init.intfb.h"
#include "laitliad.intfb.h"
#include "laitri_init.intfb.h"
#include "laitri_weno_init.intfb.h"
#include "laitre_gmv_ad.intfb.h"
#include "laitre_gfl_ad.intfb.h"

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('LARCINBAD',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP, &
  & YDDYN=>YDML_DYN%YRDYN,YDPTRSLB1=>YDML_DYN%YRPTRSLB1,YDPTRSLB15=>YDML_DYN%YRPTRSLB15,YDSLREP=>YDML_DYN%YRSLREP, &
  & YDTLSCAW=>YDML_DYN%YYTLSCAW,YDTRSCAW=>YDML_DYN%YYTRSCAW)
ASSOCIATE(NUMFLDS=>YGFL%NUMFLDS, YCOMP=>YGFL%YCOMP, &
 & NPROMA=>YDDIM%NPROMA, &
 & NFLEN=>YDDIMV%NFLEN, NFLEVG=>YDDIMV%NFLEVG, NFLSA=>YDDIMV%NFLSA, &
 & NTLAG=>YDDYN%NTLAG, NVLAG=>YDDYN%NVLAG, NVSEPC=>YDDYN%NVSEPC, &
 & NWLAG=>YDDYN%NWLAG, LSLHDHEAT=>YDDYN%LSLHDHEAT, &
 & LVWENO_W=>YDDYN%LVWENO_W,LVWENO_T=>YDDYN%LVWENO_T,LVWENO_SP=>YDDYN%LVWENO_SP, &
 & WENO_ALPHA_W=>YDDYN%WENO_ALPHA_W,WENO_ALPHA_T=>YDDYN%WENO_ALPHA_T, &
 & WENO_ALPHA_SP=>YDDYN%WENO_ALPHA_SP, &
 & YGP=>YDGMV%YGP, &
 & MSLB1C0=>YDPTRSLB1%MSLB1C0, MSLB1C9=>YDPTRSLB1%MSLB1C9, &
 & MSLB1GFL9=>YDPTRSLB1%MSLB1GFL9, MSLB1T0=>YDPTRSLB1%MSLB1T0, &
 & MSLB1T9=>YDPTRSLB1%MSLB1T9, MSLB1U0=>YDPTRSLB1%MSLB1U0, &
 & MSLB1U9=>YDPTRSLB1%MSLB1U9, MSLB1UR9=>YDPTRSLB1%MSLB1UR9, &
 & MSLB1V0=>YDPTRSLB1%MSLB1V0, MSLB1V9=>YDPTRSLB1%MSLB1V9, &
 & MSLB1VR9=>YDPTRSLB1%MSLB1VR9, NFLDSLB1=>YDPTRSLB1%NFLDSLB1, &
 & RPARSL1=>YDPTRSLB1%RPARSL1, &
 & MSLB1C05=>YDPTRSLB15%MSLB1C05, MSLB1C95=>YDPTRSLB15%MSLB1C95, &
 & MSLB1GFL95=>YDPTRSLB15%MSLB1GFL95, MSLB1T05=>YDPTRSLB15%MSLB1T05, &
 & MSLB1T95=>YDPTRSLB15%MSLB1T95, MSLB1U05=>YDPTRSLB15%MSLB1U05, &
 & MSLB1U95=>YDPTRSLB15%MSLB1U95, MSLB1UR95=>YDPTRSLB15%MSLB1UR95, &
 & MSLB1V05=>YDPTRSLB15%MSLB1V05, MSLB1V95=>YDPTRSLB15%MSLB1V95, &
 & MSLB1VR95=>YDPTRSLB15%MSLB1VR95, NFLDSLB15=>YDPTRSLB15%NFLDSLB15, &
 & NADCORE=>YDSLREP%NADCORE)
!     ------------------------------------------------------------------

!*       1.    PRELIMINARY INITIALISATIONS.
!              ----------------------------

IERR=0
DO JFLD=1,NFLDSLB1
  IF( ABS(RPARSL1(JFLD)) ==  1.0_JPRB )THEN
    ISIGN(JFLD)=INT(1.5_JPRB - 0.5_JPRB * RPARSL1(JFLD))
  ELSE
    IERR=IERR+1
  ENDIF
ENDDO
IF (IERR > 0) CALL ABOR1('LARCINBAD: RPARSL1 INVALID SIGN')

! * Computation of ISEP
ISEP=NVSEPC               ! cubic interpolations
IF (YRDYNA%LRHSVWENO) THEN       ! quintic interpolations
  ISEP=NVSEPC+2
ENDIF

IF( LSLADREP )THEN
  ALLOCATE(ZSIGN8 (NPROMA,8 ,NFLEVG,2))
  ALLOCATE(IMAP8  (NPROMA,8 ,NFLEVG))
  ALLOCATE(ZSIGN12(NPROMA,12,NFLEVG,2))
  ALLOCATE(IMAP12 (NPROMA,12,NFLEVG))
  ALLOCATE(ZSIGN32(NPROMA,32,NFLEVG,2))
  ALLOCATE(IMAP32 (NPROMA,32,NFLEVG))
  CALL LAIDDI_INIT(YDSLREP,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,KLH0,IMAP12,ZSIGN12)
  CALL LAITLI_INIT(YDSLREP,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,KL0,IMAP8,ZSIGN8)
  CALL LAITRI_INIT(YDSLREP,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,KL0,IMAP32,ZSIGN32)
  IF (YRDYNA%LRHSVWENO) THEN
    ALLOCATE(ZSIGN56(NPROMA,56,NFLEVG,2))
    ALLOCATE(IMAP56 (NPROMA,56,NFLEVG))
    CALL LAITRI_WENO_INIT(YDSLREP,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,KL0,&
       &                  KNOWENO,IMAP56,ZSIGN56)
  ELSE
    ALLOCATE(ZSIGN56(1,1,1,2))
    ALLOCATE(IMAP56 (1,1,1))
  ENDIF
ELSE
  ALLOCATE(ZSIGN8 (1,1,1,2))
  ALLOCATE(IMAP8  (1,1,1))
  ALLOCATE(ZSIGN12(1,1,1,2))
  ALLOCATE(IMAP12 (1,1,1))
  ALLOCATE(ZSIGN32(1,1,1,2))
  ALLOCATE(IMAP32 (1,1,1))
  ALLOCATE(ZSIGN56(1,1,1,2))
  ALLOCATE(IMAP56 (1,1,1))
ENDIF

INCA=1
ILOCK=0
IMAXLOCK=SIZE(KLOCK)

!     ------------------------------------------------------------------

!*       4.    ORIGIN POINT INTERPOLATIONS FOR GMVS VARIABLES.
!              -----------------------------------------------

LLMOM=.FALSE. .OR.(.NOT.LSLHDHEAT)

! The interpolations are tri-dimensional and 2D ones.

! * Continuity equation:

! --- 2D part of the RHS requiring a "high order" interpolation:
! ky: MSLB1SP9 and MSLB1SP95 used in the TL code, but MSLB1C0 and MSLB1C05
!     used in the AD code => to be checked.
IF (OML_OMP().AND..NOT.LVECADIN ) THEN
  CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
  CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
ENDIF
CALL LAIDDIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,NFLEN,&
 & MSLB1C0,ISEP,IMAP12,ZSIGN12(1,1,1,ISIGN(MSLB1C0)),&
 & KDEP,LVECADIN,LRPLANE,PRSCAW(1,1,YDTRSCAW%M_WCLA(1)),PLSCAW(1,1,YDTLSCAW%M_WDLO),PRSCAW(1,1,YDTRSCAW%M_WCLO(1)),&
 & PRSCAW5(1,1,YDTRSCAW%M_WCLA(1)),PLSCAW5(1,1,YDTLSCAW%M_WDLO),PRSCAW5(1,1,YDTRSCAW%M_WCLO(1)),&
 & KLH0,KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1C0),PB15(1,MSLB1C05),PDP)  
INCA=INCA+12
IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

! --- 3D part of the RHS requiring a "high order" interpolation:

IF (OML_OMP().AND..NOT.LVECADIN ) THEN
  CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
  CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
ENDIF

! --- 3D part of the RHS requiring a trilinear interpolation:
IF(NVLAG == 3) THEN
  CALL LAITLIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,NFLEN,&
   & MSLB1C9,ISEP,IMAP8,ZSIGN8(1,1,1,ISIGN(MSLB1C9)),&
   & LVECADIN,PLSCAW(1,1,YDTLSCAW%M_WDLAT),PLSCAW(1,1,YDTLSCAW%M_WDLO+1),KL0(1,1,1),PLSCAW(1,1,YDTLSCAW%M_WDVER),&
   & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PLSCAW5(1,1,YDTLSCAW%M_WDLO+1),PLSCAW5(1,1,YDTLSCAW%M_WDVER),&
   & KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1C9),PB15(1,MSLB1C95),PCF)  
  INCA=INCA+8
ENDIF

IF(NVLAG == 2) THEN
  LLADV5=.FALSE.
  LLSLHD_P=.FALSE. ! SLHD should not be applied to cont. equation
  CALL LAITRE_GMV_AD(YDML_DYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
   & NFLEN,MSLB1C9,ISEP,IMAP56,IMAP32,&
   & ZSIGN56(1,1,1,ISIGN(MSLB1C9)),ZSIGN32(1,1,1,ISIGN(MSLB1C9)),&
   & KDEP,LVECADIN,LRPLANE,LLSLHD_P,LVWENO_SP,WENO_ALPHA_SP,LLMOM,LLADV5,KNOWENO,&
   & KL0,PLSCAW,PRSCAW,PLSCAW5,PRSCAW5,&
   & KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1C9),PB15(1,MSLB1C95),PCF)
  IF (LVWENO_SP) THEN
    INCA=INCA+56
  ELSE
    INCA=INCA+32
  ENDIF
ENDIF

IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

!     ------------------------------------------------------------------

!*       3.    ORIGIN POINT INTERPOLATIONS FOR GFL VARIABLES.
!              ----------------------------------------------

! * The interpolations are tri-dimensional ones.

DO JGFL=1,NUMFLDS
  IF(YCOMP(JGFL)%LADV) THEN
    IF (TRIM(YCOMP(JGFL)%CNAME) == 'TKE' ) THEN
      LLMOM=.TRUE.  ! the only momentum GFL variable so far
    ELSE
      LLMOM=.FALSE. .OR.(.NOT.LSLHDHEAT)
    ENDIF
    IPOI=(YCOMP(JGFL)%MP_SL1-1)*(NFLEVG+2)
    LLADV5=YCOMP(JGFL)%LADV5
    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    CALL LAITRE_GFL_AD(YDML_DYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
     & NFLEN,MSLB1GFL9+IPOI,ISEP,IMAP56,IMAP32,IMAP8,&
     & ZSIGN56(1,1,1,ISIGN(MSLB1GFL9+IPOI)),&
     & ZSIGN32(1,1,1,ISIGN(MSLB1GFL9+IPOI)),ZSIGN8(1,1,1,ISIGN(MSLB1GFL9+IPOI)),&
     & KDEP,LVECADIN,LRPLANE,YCOMP(JGFL)%CSLINT,YCOMP(JGFL)%WENO_ALPHA,LLMOM,LLADV5,&
     & KNOWENO,KL0,PLSCAW,PRSCAW,PLSCAW5,PRSCAW5,&
     & KINC(INCA,1),PINC(INCA,1),KDIM,&
     & PB1(1,MSLB1GFL9+(YCOMP(JGFL)%MP_SL1-1)*(NFLEN-NFLSA+1)),&
     & PB15(1,MSLB1GFL95+(YCOMP(JGFL)%MP_SL1-1)*(NFLEN-NFLSA+1)),&
     & PGFLF(1,1,JGFL))
    IF (YCOMP(JGFL)%CSLINT=='LAITRWENO   ') THEN
      INCA=INCA+56
    ELSE
      INCA=INCA+32
    ENDIF
    IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))
  ENDIF
ENDDO

!     ------------------------------------------------------------------

!*       2.    ORIGIN POINT INTERPOLATIONS FOR GMV VARIABLES.
!              ----------------------------------------------

! * Temperature equation:

LLMOM=.FALSE. .OR.(.NOT.LSLHDHEAT)

IF(NTLAG == 3) THEN
  ! --- part of the RHS requiring a trilinear interpolation:
  IF (OML_OMP().AND..NOT.LVECADIN ) THEN
    CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
    CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
  ENDIF
  CALL LAITLIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,NFLEN,&
   & MSLB1T0,ISEP,IMAP8,ZSIGN8(1,1,1,ISIGN(MSLB1T0)),&
   & LVECADIN,PLSCAW(1,1,YDTLSCAW%M_WDLAT),PLSCAW(1,1,YDTLSCAW%M_WDLO+1),KL0(1,1,1),PLSCAW(1,1,YDTLSCAW%M_WDVER),&
   & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PLSCAW5(1,1,YDTLSCAW%M_WDLO+1),PLSCAW5(1,1,YDTLSCAW%M_WDVER),&
   & KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1T0),PB15(1,MSLB1T05),PGMVF(1,1,YGP%MT))  
  INCA=INCA+8
  IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))
ENDIF

! --- part of the RHS requiring a "high order" interpolation:
IF (OML_OMP().AND..NOT.LVECADIN ) THEN
  CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
  CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
ENDIF
LLADV5=.FALSE.
CALL LAITRE_GMV_AD(YDML_DYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
 & NFLEN,MSLB1T9,ISEP,IMAP56,IMAP32,&
 & ZSIGN56(1,1,1,ISIGN(MSLB1T9)),ZSIGN32(1,1,1,ISIGN(MSLB1T9)),&
 & KDEP,LVECADIN,LRPLANE,YRDYNA%LSLHD_T,LVWENO_T,WENO_ALPHA_T,LLMOM,LLADV5,KNOWENO,&
 & KL0,PLSCAW,PRSCAW,PLSCAW5,PRSCAW5,&
 & KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1T9),PB15(1,MSLB1T95),PGMVF(1,1,YGP%MT))
 IF (LVWENO_T) THEN
   INCA=INCA+56
 ELSE
   INCA=INCA+32
 ENDIF
IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))


! * V-Momentum equation:

LLMOM=.TRUE.

IF(NWLAG == 3) THEN

  ! --- part of the RHS requiring a trilinear interpolation:
  IF (OML_OMP().AND..NOT.LVECADIN ) THEN
    CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
    CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
  ENDIF
  CALL LAITLIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,NFLEN,&
   & MSLB1V0,ISEP,IMAP8,ZSIGN8(1,1,1,ISIGN(MSLB1V0)),&
   & LVECADIN,PLSCAW(1,1,YDTLSCAW%M_WDLAT),PLSCAW(1,1,YDTLSCAW%M_WDLO+1),KL0(1,1,1),PLSCAW(1,1,YDTLSCAW%M_WDVER),&
   & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PLSCAW5(1,1,YDTLSCAW%M_WDLO+1),PLSCAW5(1,1,YDTLSCAW%M_WDVER),&
   & KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1V0),PB15(1,MSLB1V05),PGMVF(1,1,YGP%MV))  
  INCA=INCA+8
  IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

  ! --- save V in some cases:
  IF (LD2TLFF1) THEN
    ! Interpolate V at the origin point and use PVFZ
    ! to store the interpolated quantities.
    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    LLADV5=.FALSE.
    CALL LAITRE_GMV_AD(YDML_DYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
     & NFLEN,MSLB1VR9,ISEP,IMAP56,IMAP32,&
     & ZSIGN56(1,1,1,ISIGN(MSLB1VR9)),ZSIGN32(1,1,1,ISIGN(MSLB1VR9)),&
     & KDEP,LVECADIN,LRPLANE,YRDYNA%LSLHD_W,LVWENO_W,WENO_ALPHA_W,LLMOM,LLADV5,KNOWENO,&
     & KL0,PLSCAW,PRSCAW,PLSCAW5,PRSCAW5,&
     & KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1VR9),PB15(1,MSLB1VR95),PVFZ)
    IF (LVWENO_W) THEN
      INCA=INCA+56
    ELSE
      INCA=INCA+32
    ENDIF
    IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))
  ELSE
    ! Save PGMVF(.,.,YGP%MV) in case of refined treatment of
    ! Coriolis term and lagged physics in 2TL scheme:
    PGMVF(KST:KPROF,1:NFLEVG,YGP%MV)=&
     & PGMVF(KST:KPROF,1:NFLEVG,YGP%MV)+PVFZ(KST:KPROF,1:NFLEVG)  
  ENDIF

ENDIF

! --- part of the RHS requiring a "high order" interpolation:
IF (OML_OMP().AND..NOT.LVECADIN ) THEN
  CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
  CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
ENDIF
LLADV5=.FALSE.
CALL LAITRE_GMV_AD(YDML_DYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
 & NFLEN,MSLB1V9,ISEP,IMAP56,IMAP32, &
 & ZSIGN56(1,1,1,ISIGN(MSLB1V9)),ZSIGN32(1,1,1,ISIGN(MSLB1V9)),&
 & KDEP,LVECADIN,LRPLANE,YRDYNA%LSLHD_W,LVWENO_W,WENO_ALPHA_W,LLMOM,LLADV5,KNOWENO,&
 & KL0,PLSCAW,PRSCAW,PLSCAW5,PRSCAW5,&
 & KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1V9),PB15(1,MSLB1V95),PGMVF(1,1,YGP%MV))
IF (LVWENO_W) THEN
  INCA=INCA+56
ELSE
  INCA=INCA+32
ENDIF
IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

! * U-Momentum equation:

IF(NWLAG == 3) THEN

  ! --- part of the RHS requiring a trilinear interpolation:
  IF (OML_OMP().AND..NOT.LVECADIN ) THEN
    CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
    CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
  ENDIF
  CALL LAITLIAD(YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,NFLEN,&
   & MSLB1U0,ISEP,IMAP8,ZSIGN8(1,1,1,ISIGN(MSLB1U0)),&
   & LVECADIN,PLSCAW(1,1,YDTLSCAW%M_WDLAT),PLSCAW(1,1,YDTLSCAW%M_WDLO+1),KL0(1,1,1),PLSCAW(1,1,YDTLSCAW%M_WDVER),&
   & PLSCAW5(1,1,YDTLSCAW%M_WDLAT),PLSCAW5(1,1,YDTLSCAW%M_WDLO+1),PLSCAW5(1,1,YDTLSCAW%M_WDVER),&
   & KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1U0),PB15(1,MSLB1U05),PGMVF(1,1,YGP%MU))  
  INCA=INCA+8
  IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))

  ! --- save U in some cases:
  IF (LD2TLFF1) THEN
    ! Interpolate U at the origin point and use PUFZ
    ! to store the interpolated quantities.
    IF (OML_OMP().AND..NOT.LVECADIN ) THEN
      CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
      CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
    ENDIF
    LLADV5=.FALSE.
    CALL LAITRE_GMV_AD(YDML_DYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
     & NFLEN,MSLB1UR9,ISEP,IMAP56,IMAP32,&
     & ZSIGN56(1,1,1,ISIGN(MSLB1UR9)),ZSIGN32(1,1,1,ISIGN(MSLB1UR9)),&
     & KDEP,LVECADIN,LRPLANE,YRDYNA%LSLHD_W,LVWENO_W,WENO_ALPHA_W,LLMOM,LLADV5,KNOWENO,&
     & KL0,PLSCAW,PRSCAW,PLSCAW5,PRSCAW5,&
     & KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1UR9),PB15(1,MSLB1UR95),PUFZ)
    IF (LVWENO_W) THEN
      INCA=INCA+56
    ELSE
      INCA=INCA+32
    ENDIF
    IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))
  ELSE
    ! Save PGMVF(.,.,YGP%MU) in case of refined treatment of
    ! Coriolis term and lagged physics in 2TL scheme:
    PGMVF(KST:KPROF,1:NFLEVG,YGP%MU)=&
     & PGMVF(KST:KPROF,1:NFLEVG,YGP%MU)+PUFZ(KST:KPROF,1:NFLEVG)  
  ENDIF

ENDIF

! --- part of the RHS requiring a "high order" interpolation:
IF (OML_OMP().AND..NOT.LVECADIN ) THEN
  CALL OML_INCR_COUNTER(ILOCK,IMAXLOCK)
  CALL OML_WAIT_EVENT(KSTGLO,KLOCK(ILOCK))
ENDIF
LLADV5=.FALSE.
CALL LAITRE_GMV_AD(YDML_DYN,YDSL%NASLB1,NPROMA,KST,KPROF,NFLEVG,NFLSA,&
 & NFLEN,MSLB1U9,ISEP,IMAP56,IMAP32,&
 & ZSIGN56(1,1,1,ISIGN(MSLB1U9)),ZSIGN32(1,1,1,ISIGN(MSLB1U9)),&
 & KDEP,LVECADIN,LRPLANE,YRDYNA%LSLHD_W,LVWENO_W,WENO_ALPHA_W,LLMOM,LLADV5,KNOWENO,&
 & KL0,PLSCAW,PRSCAW,PLSCAW5,PRSCAW5,&
 & KINC(INCA,1),PINC(INCA,1),KDIM,PB1(1,MSLB1U9),PB15(1,MSLB1U95),PGMVF(1,1,YGP%MU))
IF (LVWENO_W) THEN
  INCA=INCA+56
ELSE
  INCA=INCA+32
ENDIF
IF (OML_OMP().AND..NOT.LVECADIN ) CALL OML_INCR_EVENT(KPROF,KLOCK(ILOCK))


!     ------------------------------------------------------------------

!*       5.    ADDITIONAL TASKS.
!              -----------------

IF (LVECADIN) THEN

  INCA=INCA-1

  IF(KDIM  /=  INCA) THEN
    WRITE(NULERR,*) "KDIM,INCA=",KDIM,INCA
    DO JGFL=1,NUMFLDS
      WRITE(NULERR,*) "JGFL,YCOMP=",JGFL,YCOMP(JGFL)%LADV
    ENDDO
    CALL ABOR1('LARCINBAD: KDIM /= INCA')
  ENDIF
  
ENDIF

IF( .NOT.LSLADREP .AND. GET_NSIM4D() == 0 .AND. YDSL%LSLONDEM .AND. NPROC > 1)THEN
  
  DO JLEV=1,NFLEVG
!OCL NOVREC
    DO JROF=KST,KPROF
      !IOFF=MOD(KL0(JROF,JLEV,1)+1-YDSL%NASLB1+MAX(0,KNOWENO(JROF,JLEV))*YDSL%NASLB1,YDSL%NASLB1)+1
      !YDSL%MASK_SL1(IOFF)=1
      !IOFF=MOD(KL0(JROF,JLEV,2)+1-YDSL%NASLB1+MAX(0,KNOWENO(JROF,JLEV))*YDSL%NASLB1,YDSL%NASLB1)+1
      !YDSL%MASK_SL1(IOFF)=1
      !IOFF=MOD(KL0(JROF,JLEV,0)-1,YDSL%NASLB1)+1
      !YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,0),YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,0)+1,YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      !IOFF=MOD(KL0(JROF,JLEV,0)+2,YDSL%NASLB1)+1
      !YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,1)-1,YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,1),YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,1)+1,YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,1)+2,YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,2)-1,YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,2),YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,2)+1,YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,2)+2,YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      !IOFF=MOD(KL0(JROF,JLEV,3)-1,YDSL%NASLB1)+1
      !YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,3),YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      IOFF=MOD(KL0(JROF,JLEV,3)+1,YDSL%NASLB1)+1
      YDSL%MASK_SL1(IOFF)=1
      !IOFF=MOD(KL0(JROF,JLEV,3)+2,YDSL%NASLB1)+1
      !YDSL%MASK_SL1(IOFF)=1
      !IOFF=MOD(KL0(JROF,JLEV,1)+1+4*YDSL%NASLB1+MIN(0,KNOWENO(JROF,JLEV))*YDSL%NASLB1,YDSL%NASLB1)+1
      !YDSL%MASK_SL1(IOFF)=1
      !IOFF=MOD(KL0(JROF,JLEV,2)+1+4*YDSL%NASLB1+MIN(0,KNOWENO(JROF,JLEV))*YDSL%NASLB1,YDSL%NASLB1)+1
      !YDSL%MASK_SL1(IOFF)=1
    ENDDO
  ENDDO

ENDIF

IF( LSLADREP .AND. GET_NSIM4D() == 0 .AND. NPROC > 1  )THEN
  DO JLEV=1,NFLEVG
    DO JSTAR=1,32
!OCL NOVREC
      DO JROF=KST,KPROF
        IOFF=MOD(IMAP32(JROF,JSTAR,JLEV)-1,YDSL%NASLB1)+1
        IF( YDSL%LSLCORE(IOFF) )THEN
          ! NSLCORE POINT HAS BEEN UPDATED
          YDSL%MASK_SLTOT(NADCORE(KSTGLO+JROF-1))=1
        ENDIF
      ENDDO
    ENDDO
  ENDDO
ENDIF

!     ------------------------------------------------------------------

!*       6.    DESALLOCATIONS.
!              ---------------

IF(ALLOCATED(ZSIGN8 )) DEALLOCATE(ZSIGN8 )
IF(ALLOCATED(ZSIGN12)) DEALLOCATE(ZSIGN12)
IF(ALLOCATED(ZSIGN32)) DEALLOCATE(ZSIGN32)
IF(ALLOCATED(ZSIGN56)) DEALLOCATE(ZSIGN56)
IF(ALLOCATED(IMAP8  )) DEALLOCATE(IMAP8  )
IF(ALLOCATED(IMAP12 )) DEALLOCATE(IMAP12 )
IF(ALLOCATED(IMAP32 )) DEALLOCATE(IMAP32 )
IF(ALLOCATED(IMAP56 )) DEALLOCATE(IMAP56 )

!     ------------------------------------------------------------------

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('LARCINBAD',1,ZHOOK_HANDLE)
END SUBROUTINE LARCINBAD
