#ifdef RS6K
@PROCESS NOCHECK
#endif
SUBROUTINE CA_SCAN2M(YDGEOMETRY,YDFIELDS,YDMODEL,YDODB)

!****-------------------------------------------------------------------
!**** *CA_SCAN2M* - Grid-point space computations
!****-------------------------------------------------------------------
!     Purpose.   Computations in grid-point space CANARI  CDCONF(6:6)=1
!     --------   

!**   Interface.
!     ----------
!        *CALL* *CA_SCAN2M (..)

!        Explicit arguments :  
!        --------------------  

!     Author.   D. Puech  MF

!-----------------------------------------------------------------------------

USE GEOMETRY_MOD       , ONLY : GEOMETRY
USE FIELDS_MOD         , ONLY : FIELDS
USE TYPE_MODEL         , ONLY : MODEL
USE SURFACE_FIELDS_MIX , ONLY : TSURF
USE PARKIND1           , ONLY : JPIM, JPRB, JPRD
USE YOMHOOK            , ONLY : LHOOK, DR_HOOK
USE QAGPSF             , ONLY : RSGPHI, RSGHUM
USE QALORI             , ONLY : QCAGUE
USE QASSET             , ONLY : ESIG
USE QANADA             , ONLY : MUTILW

USE MPL_MODULE         , ONLY : MPL_SEND, MPL_RECV
USE YOMTAG             , ONLY : MTAGGSUM
USE YOMMP0             , ONLY : MYPROC, NPROC, NPRCIDS 
USE YOMLUN             , ONLY : NULOUT
USE DBASE_MOD          , ONLY : DBASE
USE IFS_DBASE_VIEW_MOD, ONLY: IFS_DBASE_VIEW
USE LL_MOD,    ONLY : LL

!     ------------------------------------------------------------------

IMPLICIT NONE

CLASS(DBASE),        INTENT(INOUT) :: YDODB   ! Observation database object
TYPE(IFS_DBASE_VIEW)      :: ROBHDR, ROBODY
TYPE(LL)              :: WHERE_CONDS

TYPE(GEOMETRY)      ,INTENT(IN)    :: YDGEOMETRY
TYPE(FIELDS)        ,INTENT(INOUT) :: YDFIELDS
TYPE(MODEL)         ,INTENT(INOUT) :: YDMODEL
!     ------------------------------------------------------------------

REAL(KIND=JPRB),ALLOCATABLE :: ZUT(:,:),ZVT(:,:),ZTT(:,:),ZQT(:,:),ZLT(:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZIT(:,:),ZRT(:,:),ZST(:,:),ZGT(:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZSP_SB(:,:,:),ZSP_SG(:,:),ZSP_RR(:,:),ZSP_CI(:,:),ZSP_X2(:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZSD_VF(:,:),ZSD_VV(:,:),ZSD_VX(:,:)
REAL(KIND=JPRB),DIMENSION(:),ALLOCATABLE :: ZPS,ZRCORI,ZGEMU,ZMORO,ZMLSM
REAL(KIND=JPRB),DIMENSION(:),ALLOCATABLE :: ZGM,ZGELAT,ZGELAM,ZGNORDL,ZGNORDM
REAL(KIND=JPRB),DIMENSION(:,:),ALLOCATABLE :: ZCAGUE,ZESIG,ZSGPHI,ZSGHUM

INTEGER(KIND=JPIM) :: IBL, IEND, INBPT, IND, IOFF, IST, ITASK, JKGLO, JROF
INTEGER(KIND=JPIM) :: IRET, IRETB, IROC, JROC, IERR, INBWAG, JBODY, IBIT
INTEGER(KIND=JPIM), ALLOCATABLE :: IBUFR(:)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

!     ------------------------------------------------------------------

#include "user_clock.h"

#include "abor1.intfb.h"
#include "capotx.intfb.h"

#include "qabitu.func.h"

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('CA_SCAN2M',0,ZHOOK_HANDLE)

ASSOCIATE (YDCST => YDMODEL%YRCST)
ASSOCIATE(YDGFL=>YDFIELDS%YRGFL,YDGMV=>YDFIELDS%YRGMV, YDSURF=>YDFIELDS%YRSURF, &
 & YDDIM=>YDGEOMETRY%YRDIM,  YDDIMV=>YDGEOMETRY%YRDIMV, YDGEM=>YDGEOMETRY%YRGEM, &
 & YDGSGEOM=>YDGEOMETRY%YRGSGEOM, YDGSGEOM_NB=>YDGEOMETRY%YRGSGEOM_NB, YDRIP=>YDMODEL%YRML_GCONF%YRRIP, &
 & YGFL=>YDMODEL%YRML_GCONF%YGFL)

ASSOCIATE( YG=>YGFL%YG, YI=>YGFL%YI, YL=>YGFL%YL, YQ=>YGFL%YQ, YR=>YGFL%YR, YS=>YGFL%YS, &
 & NPROMA=>YDDIM%NPROMA, NFLEVG=>YDDIMV%NFLEVG, NGPTOT=>YDGEM%NGPTOT, &
 & GFL=>YDGFL%GFL, GMV=>YDGMV%GMV, GMVS=>YDGMV%GMVS, YT0=>YDGMV%YT0, &
 & SD_VF=>YDSURF%SD_VF, SD_VV=>YDSURF%SD_VV, SD_VX=>YDSURF%SD_VX, &
 & SP_CI=>YDSURF%SP_CI, SP_RR=>YDSURF%SP_RR, &
 & SP_SB=>YDSURF%SP_SB, SP_SG=>YDSURF%SP_SG, SP_X2=>YDSURF%SP_X2, &
 & YSD_VF=>YDSURF%YSD_VF, YSD_VFD=>YDSURF%YSD_VFD, &
 & YSD_VVD=>YDSURF%YSD_VVD, YSD_VX=>YDSURF%YSD_VX, YSD_VXD=>YDSURF%YSD_VXD, &
 & YSP_CI=>YDSURF%YSP_CI, YSP_CID=>YDSURF%YSP_CID, &
 & YSP_RRD=>YDSURF%YSP_RRD, YSP_SBD=>YDSURF%YSP_SBD, &
 & YSP_SGD=>YDSURF%YSP_SGD, YSP_X2D=>YDSURF%YSP_X2D )


!*       7.2  GRID POINT CALCULATIONS FOR CANARI   voir CA_SCAN2M

ITASK=1 ! NTASKS_CANARI ?

CALL WHERE_CONDS%APPEND('replicate_PE', -1._JPRD) ! global
IRET = YDODB%SELECT('canada_robhdr',  ROBHDR,  PARAMS_LL=WHERE_CONDS)
IRETB = YDODB%SELECT('canada_robody',  ROBODY,  PARAMS_LL=WHERE_CONDS)
CALL ROBHDR%SETUP_COL_POINTERS()
CALL ROBODY%SETUP_COL_POINTERS()
CALL ROBODY%SETUP_REPORT_INDICES()
INBWAG = IRETB
ALLOCATE(MUTILW(INBWAG))
MUTILW = 0

!$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) PRIVATE(JKGLO,IST,IEND,IBL,IND,IOFF,JROF,INBPT)&
!$OMP&PRIVATE(ZUT,ZVT,ZTT,ZQT,ZLT,ZIT,ZRT,ZST,ZGT,ZPS,ZSP_SB,ZSP_SG,ZSP_RR,ZSP_CI,ZSP_X2)&
!$OMP&PRIVATE(ZSD_VF,ZSD_VV,ZSD_VX,ZRCORI,ZGM,ZGELAT,ZGELAM,ZMORO,ZMLSM,ZGNORDL,ZGNORDM)&
!$OMP&PRIVATE(ZGEMU,ZCAGUE,ZESIG,ZSGPHI,ZSGHUM)

DO JKGLO=1,NGPTOT,NPROMA
  IBL=(JKGLO-1)/NPROMA+1
  IST=1
  IEND=MIN(NPROMA,NGPTOT-JKGLO+1)

  ALLOCATE(ZUT(NPROMA,NFLEVG))
  ALLOCATE(ZVT(NPROMA,NFLEVG))
  ALLOCATE(ZTT(NPROMA,NFLEVG))
  ALLOCATE(ZQT(NPROMA,NFLEVG))
  ALLOCATE(ZLT(NPROMA,NFLEVG))
  ALLOCATE(ZIT(NPROMA,NFLEVG))
  ALLOCATE(ZRT(NPROMA,NFLEVG))
  ALLOCATE(ZST(NPROMA,NFLEVG))
  ALLOCATE(ZGT(NPROMA,NFLEVG))
  ALLOCATE(ZPS(NPROMA))
  ALLOCATE(ZSP_SB(NPROMA,YSP_SBD%NLEVS,YSP_SBD%NDIM))
  ALLOCATE(ZSP_SG(NPROMA,YSP_SGD%NDIM))
  ALLOCATE(ZSP_RR(NPROMA,YSP_RRD%NDIM))
  ALLOCATE(ZSP_CI(NPROMA,YSP_CID%NDIM))
  ALLOCATE(ZSP_X2(NPROMA,YSP_X2D%NDIM))
  ALLOCATE(ZSD_VF(NPROMA,YSD_VFD%NDIM))
  ALLOCATE(ZSD_VV(NPROMA,YSD_VVD%NDIM))
  ALLOCATE(ZSD_VX(NPROMA,YSD_VXD%NDIM))
  ALLOCATE(ZRCORI(NPROMA))
  ALLOCATE(ZGM(NPROMA))
  ALLOCATE(ZGELAT(NPROMA))
  ALLOCATE(ZGELAM(NPROMA))
  ALLOCATE(ZMORO(NPROMA))
  ALLOCATE(ZMLSM(NPROMA))
  ALLOCATE(ZGNORDL(NPROMA))
  ALLOCATE(ZGNORDM(NPROMA))
  ALLOCATE(ZGEMU(NPROMA))
  ALLOCATE(ZCAGUE(2,NPROMA))
  ALLOCATE(ZESIG(2*NFLEVG+5,NPROMA))
  ALLOCATE(ZSGPHI(NFLEVG,NPROMA))
  ALLOCATE(ZSGHUM(NFLEVG,NPROMA))

! packing analysis points according to the required domain mask
  IND=0
  IOFF=JKGLO-1
  DO JROF = 1 , IEND
    IOFF=IOFF+1
    IF (SP_CI(JROF,YSP_CI%YCI(3)%MP0,IBL) > 0.5_JPRB) THEN
      IND=IND+1
      ZUT(IND,1:NFLEVG)=GMV(JROF,:,YT0%MU,IBL)
      ZVT(IND,1:NFLEVG)=GMV(JROF,:,YT0%MV,IBL)
      ZTT(IND,1:NFLEVG)=GMV(JROF,:,YT0%MT,IBL)
      ZQT(IND,1:NFLEVG)=GFL(JROF,1:NFLEVG,YQ%MP,IBL)
      IF (YL%LACTIVE) THEN
          ZLT(IND,1:NFLEVG)=GFL(JROF,1:NFLEVG,YL%MP,IBL)
      ELSE
          ZLT(IND,1:NFLEVG)=0.0_JPRB
      ENDIF        
      IF (YI%LACTIVE) THEN
         ZIT(IND,1:NFLEVG)=GFL(JROF,1:NFLEVG,YI%MP,IBL)
      ELSE
         ZIT(IND,1:NFLEVG)=0.0_JPRB
      ENDIF      
      IF (YR%LACTIVE) THEN
         ZRT(IND,1:NFLEVG)=GFL(JROF,1:NFLEVG,YR%MP,IBL)
      ELSE
         ZRT(IND,1:NFLEVG)=0.0_JPRB
      ENDIF
      IF (YS%LACTIVE) THEN
         ZST(IND,1:NFLEVG)=GFL(JROF,1:NFLEVG,YS%MP,IBL)
      ELSE
         ZST(IND,1:NFLEVG)=0.0_JPRB
      ENDIF
      IF (YG%LACTIVE) THEN
         ZGT(IND,1:NFLEVG)=GFL(JROF,1:NFLEVG,YG%MP,IBL)
      ELSE
         ZGT(IND,1:NFLEVG)=0.0_JPRB
      ENDIF
      ZPS(IND)=GMVS(JROF,YT0%MSP,IBL)
      ZSP_SB(IND,:,:) = SP_SB(JROF,:,:,IBL)
      IF (SIZE(SP_SG,DIM=2)==1) THEN
        ZSP_SG(IND,:) = SP_SG(JROF,1,:,IBL)
      ELSE
        CALL ABOR1('REK: I DONT KNOW HOW TO FIX THIS')
      ENDIF
!      ZSP_SG(IND,:) = SP_SG(JROF,:,IBL)
      ZSP_RR(IND,:) = SP_RR(JROF,:,IBL)
      ZSP_CI(IND,:) = SP_CI(JROF,:,IBL)
      ZSP_X2(IND,:) = SP_X2(JROF,:,IBL)
      ZSD_VF(IND,:) = SD_VF(JROF,:,IBL)
      ZSD_VV(IND,:) = SD_VV(JROF,:,IBL)
      ZSD_VX(IND,:) = SD_VX(JROF,:,IBL)
      ZGM(IND)=YDGSGEOM(IBL)%GM(JROF)
      ZGELAT(IND)=YDGSGEOM(IBL)%GELAT(JROF)
      ZGELAM(IND)=YDGSGEOM(IBL)%GELAM(JROF)
      ZMORO(IND)= SD_VX(JROF,YSD_VX%YORO%MP,IBL)/YDCST%RG
      ZMLSM(IND)= SD_VF(JROF,YSD_VF%YLSM%MP,IBL)
      ZGNORDL(IND)=YDGSGEOM_NB%GNORDL(IOFF)
      ZGNORDM(IND)=YDGSGEOM_NB%GNORDM(IOFF)
      ZGEMU(IND)=YDGSGEOM(IBL)%GEMU(JROF)
      ZRCORI(IND)=YDGSGEOM(IBL)%RCORI(JROF)
      ZCAGUE(:,IND)=QCAGUE(:,IOFF)
      ZESIG(:,IND)=ESIG(:,IOFF)
      ZSGPHI(:,IND)=RSGPHI(:,IOFF)
      ZSGHUM(:,IND)=RSGHUM(:,IOFF)
    ENDIF
  ENDDO
  INBPT=IND
  IF (INBPT > 0) THEN
! analysis
    CALL CAPOTX(YDCST,ROBHDR,ROBODY,YDGEOMETRY,YDSURF,YDMODEL%YRML_PHY_G%YRDPHY,YDRIP,YDMODEL%YRML_PHY_MF, &
     & ITASK,INBPT,ZUT,ZVT,ZTT,ZQT,ZLT,ZIT,ZRT,ZST,ZGT,ZPS,&
     & ZSP_SB,ZSP_SG,ZSP_RR,ZSP_CI,ZSP_X2,ZSD_VF,ZSD_VV,ZSD_VX,&
     & ZGM,ZGELAT,ZGELAM,ZMORO,ZMLSM,ZGNORDL,ZGNORDM,ZRCORI,&
     & ZGEMU,ZCAGUE,ZESIG,ZSGPHI,ZSGHUM)
! results saving
    IOFF=JKGLO-1
    IND=0
    DO JROF = 1 , IEND
      IOFF=IOFF+1
      IF (SP_CI(JROF,YSP_CI%YCI(3)%MP0,IBL) > 0.5_JPRB) THEN
        IND=IND+1
        GMV(JROF,:,YT0%MU,IBL)=ZUT(IND,1:NFLEVG)
        GMV(JROF,:,YT0%MV,IBL)=ZVT(IND,1:NFLEVG)
        GMV(JROF,:,YT0%MT,IBL)=ZTT(IND,1:NFLEVG)
        GFL(JROF,1:NFLEVG,YQ%MP,IBL)=ZQT(IND,1:NFLEVG)
        IF (YL%LACTIVE) GFL(JROF,1:NFLEVG,YL%MP,IBL)=ZLT(IND,1:NFLEVG)
        IF (YI%LACTIVE) GFL(JROF,1:NFLEVG,YI%MP,IBL)=ZIT(IND,1:NFLEVG)
        GMVS(JROF,YT0%MSP,IBL)=ZPS(IND)
        SP_SB(JROF,:,:,IBL)=ZSP_SB(IND,:,:)
        IF (SIZE(SP_SG,DIM=2)==1) THEN
          SP_SG(JROF,1,:,IBL)=ZSP_SG(IND,:)
        ELSE
          CALL ABOR1('REK: I DONT KNOW HOW TO FIX THIS')
        ENDIF
!        SP_SG(JROF,:,IBL)=ZSP_SG(IND,:)
        SP_RR(JROF,:,IBL)=ZSP_RR(IND,:)
        SP_CI(JROF,:,IBL)=ZSP_CI(IND,:)
        SP_X2(JROF,:,IBL)=ZSP_X2(IND,:)
        SD_VF(JROF,:,IBL)=ZSD_VF(IND,:)
        SD_VV(JROF,:,IBL)=ZSD_VV(IND,:)
        SD_VX(JROF,:,IBL)=ZSD_VX(IND,:)
        RSGPHI(:,IOFF)=ZSGPHI(:,IND)
        RSGHUM(:,IOFF)=ZSGHUM(:,IND)
      ENDIF
    ENDDO
  ENDIF

  DEALLOCATE(ZUT,ZVT,ZTT,ZQT,ZLT,ZIT,ZRT,ZST,ZGT,ZPS,ZSP_SB,ZSP_SG,ZSP_RR,&
    & ZSP_CI,ZSP_X2,ZSD_VF,ZSD_VV,ZSD_VX,ZRCORI,ZGM,ZGELAT,ZGELAM,ZGNORDL,&
    & ZGNORDM,ZGEMU,ZCAGUE,ZESIG,ZSGPHI,ZSGHUM,ZMORO,ZMLSM)

ENDDO ! NPROMA
!$OMP END PARALLEL DO

! recup anflag (canada)
ALLOCATE(IBUFR(INBWAG))
WRITE(NULOUT,*) '(cb) ca_scan2m INBWAG = ',INBWAG,' NPRCIDS = ',NPRCIDS
CALL FLUSH(NULOUT)
IF (MYPROC /= 1) THEN ! envoi resultat local au processeur 1 (KDEST)
  CALL MPL_SEND(MUTILW(:),KDEST=NPRCIDS(1),KTAG=MTAGGSUM,KERROR=IERR,CDSTRING='CA_SCAN2M:1')
  IF (IERR < 0) CALL ABOR1(' CA_SCAN2M:1 pb envoi ROBODY')
ELSE  ! regroupement resultat
  DO JROC = 2 , NPROC
    IROC=JROC
    WRITE(NULOUT,*) '(cb) ca_scan2m IROC = ',IROC,' JROC = ',JROC,' NPRCIDS(IROC) = ',NPRCIDS(IROC)
    CALL FLUSH(NULOUT)
    !CALL MPL_RECV(IBUFR(:),KTAG=MTAGGSUM,KFROM=NPRCIDS(IROC),CDSTRING='CA_SCAN2M:1')
    CALL MPL_RECV(IBUFR(:),KTAG=MTAGGSUM,KFROM=IROC,CDSTRING='CA_SCAN2M:1')
    DO JBODY = 1, INBWAG
      IF ((IBUFR(JBODY) > 0).and.(IBUFR(JBODY) /= int(ROBODY%BODY%DATUM_ANFLAG(JBODY)))) THEN 
        DO IBIT = 21, 29
           IF (KBITLU(IBUFR(JBODY),IBIT,1) == 1) &
             & ROBODY%BODY%DATUM_ANFLAG(JBODY)=KBITEC(int(ROBODY%BODY%DATUM_ANFLAG(JBODY)),1,IBIT)
        ENDDO
      ENDIF
    ENDDO
  ENDDO
ENDIF
IF (MYPROC == 1) THEN ! envoi des flags à tous les procs
  DO JBODY=1,INBWAG
    MUTILW(JBODY)=int(ROBODY%BODY%DATUM_ANFLAG(JBODY))
  ENDDO
  DO JROC = 2 , NPROC
    IROC=JROC
    CALL MPL_SEND(MUTILW(:),KDEST=NPRCIDS(IROC),KTAG=MTAGGSUM,KERROR=IERR,CDSTRING='CA_SCAN2M:2')
    IF (IERR < 0) CALL ABOR1(' CA_SCAN2M:1 pb envoi ROBODY')
  ENDDO
ELSE
  CALL MPL_RECV(IBUFR(:),KTAG=MTAGGSUM,KFROM=NPRCIDS(1),CDSTRING='CA_SCAN2M:2')
  ROBODY%BODY%DATUM_ANFLAG(1:)=IBUFR(:)
ENDIF
DEALLOCATE(IBUFR)

DEALLOCATE(MUTILW)
IRET = YDODB%PUT(ROBHDR)
IRETB = YDODB%PUT(ROBODY)
CALL WHERE_CONDS%DESTROY()

! T1-arrays get allocated in GP_MODEL, so no ASSOCIATE renaming

!$OMP WORKSHARE
  YDGFL%GFLT1(:,:,:,:)=GFL(:,:,:,:)

  ! Copy the correct part of GMV to GMVT1 according to the rules of the Standard,
  ! that demand that the shape of the RHS is equal to the shape of the LHS.

  YDGMV%GMVT1(:,:,:,:)=GMV(:SIZE(YDGMV%GMVT1,1)+LBOUND(GMV,1)-1,&
                         & :SIZE(YDGMV%GMVT1,2)+LBOUND(GMV,2)-1,&
                         & :SIZE(YDGMV%GMVT1,3)+LBOUND(GMV,3)-1,&
                         & :SIZE(YDGMV%GMVT1,4)+LBOUND(GMV,4)-1)

  YDGMV%GMVT1S(:,:,:)=GMVS(:,:,:)
!$OMP END WORKSHARE


!     ------------------------------------------------------------------
END ASSOCIATE
END ASSOCIATE
END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('CA_SCAN2M',1,ZHOOK_HANDLE)
END SUBROUTINE CA_SCAN2M
