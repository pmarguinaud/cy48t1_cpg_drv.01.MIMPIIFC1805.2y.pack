SUBROUTINE CNT4AD(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,YDJOT,YDVARBC,YDTCV5,YDGOM,YDTCV,YDGOM5,YDODB,YDACV)

!**** *CNT4AD*  - Controls adjoint model at level 4

!     Purpose.
!     --------
!     Controls adjoint integration.

!**   Interface.
!     ----------
!        *CALL* *CNT4AD

!        Explicit arguments :
!        --------------------
!        None

!        Implicit arguments :
!        --------------------
!        None

!     Method.
!     -------
!        See documentation

!     Externals.
!     ----------
!        Called by CNT3.

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!      Mats Hamrud and Philippe Courtier  *ECMWF*
!      Original : 87-10-15

! Modifications
! -------------
!   B. Chapnik    02-May-2007 fgat : temporal loop considered only if Tstep corresponds to tslot
!                                    and call to stepo only when needed
!   Y. Seity    11-01-08 add ISHISTS for surfex output files
!   Y.Tremolet    27-Nov-2008 Jc-DFI for long windows
!   F. Vana    13-Jan-2009: removed special specHD setup when LSLHD
!   A. Alias      07-Aug-2009 Arguments added/modified to MONIO for surfex output files 
!   K. Yessad (Aug 2009): remove LSITRIC option
!   K. Yessad (Jan 2011): new architecture for LBC modules and set-up.
!   A. Geer       28-May-2012 Removed need to acess GOMs here.
!   K. Yessad (Feb 2012): various contributions.
!   F. Vana    5-Dec-2013 arguments update for GET_TRAJ_SPEC
!   R. El Khatib 04-Aug-2014 Pruning of the conf. 927/928
!   K. Yessad (July 2014): Move some variables.
!   F. Vana  05-Mar-2015  Support for single precision
!   A. Geer       27 Jul 2015 More OOPS cleaning: VARBC by argument
!   R. El Khatib 07-Mar-2016 Pruning of ISP
!   A. Geer       05 Mar 2016 SuperGOM object for OOPS; protect against adjoint model test
!   O. Marsden    August 2016 Removed use of SPA3
!   K. Yessad (June 2017): Introduce NHQE model.
!   R. El Khatib  04-Jun-2018 refactor suct1 against monio
!   S. Massart   19-Feb-2019 Solar constant optimisation
!------------------------------------------------------------------------------

USE TYPE_MODEL    , ONLY : MODEL
USE GEOMETRY_MOD  , ONLY : GEOMETRY
USE FIELDS_MOD    , ONLY : FIELDS
USE MTRAJ_MOD     , ONLY : MTRAJ
USE PARKIND1      , ONLY : JPRD, JPIM, JPRB
USE YOMHOOK       , ONLY : LHOOK, DR_HOOK
USE JO_TABLE_MOD  , ONLY : JO_TABLE
USE YOMDIMO       , ONLY : NACTIM
USE YOMECTAB      , ONLY : YECVAR, NTSLVSTST, MTSLOTNO
USE YOMLUN        , ONLY : NULOUT
USE YOMMP0        , ONLY : NPRINTLEV
USE YOMCT0        , ONLY : NCONF, NHISTS,  NHISTSMIN, &
 &                         NFRHIS, NFRGDI, NFRSDI, NFRDHFG, NFRDHFZ, NFRDHFD, NFRDHP,NGDITS   ,NSDITS   ,&
 &                         NDHFGTS  ,NDHFZTS  ,NDHFDTS  ,NDHPTS, LTWOTL, LOBS, LSIMOB, LELAM, LNHEE
USE YOMCT1        , ONLY : N1HIS, N1GDI, N1SDI
USE YOMCT2        , ONLY : NSTAR2, NSTOP2
USE YOMCT3        , ONLY : NSTEP 
USE YOMVAR        , ONLY : NFRREF, NFRANA, NFRGRA, NSIM4DL, LTRREF,&
 &                         LTWGRA, LGRASCAL, LJCDFI, LUSEJCDFI, LMODERR, LFCOBSTEST
USE ALGORITHM_STATE_MOD  , ONLY : GET_NSIM4D
USE YOMSENS       , ONLY : NJROPT
USE YOMVRTL       , ONLY : LOBSTL, LIDMODEL
USE YOMTIM        , ONLY : RSTART, RVSTART, RTIMEF
USE YOMSP5        , ONLY : SPA5
USE TRAJECTORY_MOD, ONLY : LTRAJGP, GET_TRAJ_SPEC
USE YOMTRAJ       , ONLY : TRAJEC
USE YOMLCZ        , ONLY : L_SOS, L_EOFS, NSTEPS_PER_STATE, YSTATE_VECTOR_4D,&
 &                         LOCNORM, LFORCE, YSPFORCE
USE YOMMODERR     , ONLY : NTYPE_MODERR, NDIM_MODERR, NPRTMODERR,&
 &                         SPMODERR, GPMODERR, N_COUPLED_WINDOWS
USE YOMDFI        , ONLY : NSTDFI
USE YEMJK         , ONLY : LEJK
USE YEMLBC_INIT    , ONLY : NECOAD, LE0COTA, NFRLSG, N1LSG
USE VARBC_CLASS   , ONLY : CLASS_VARBC
USE TOVSCV_MOD    , ONLY : TOVSCV
USE SUPERGOM_CLASS, ONLY : CLASS_SUPERGOM
USE TESTVAR_MIX   , ONLY : LTESTADJM
USE YOMVRTLX      , ONLY : L801TL
USE DBASE_MOD     , ONLY : DBASE
USE TYPE_ACV      , ONLY : ACV_CONTAINER
USE YOMJBACV      , ONLY : YRACV5
USE YOMJBPAR1DACV , ONLY : GET_VALUE_FROM_ACV
USE CONTROL_VECTORS_MOD
USE SPECTRAL_FIELDS_MOD, ONLY : ASSIGNMENT(=), SPECTRAL_NORM
!------------------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)      ,INTENT(INOUT) :: YDGEOMETRY  !! INOUT needed for STEPOAD call
TYPE(FIELDS)        ,INTENT(INOUT) :: YDFIELDS
TYPE(MTRAJ)         ,INTENT(INOUT) :: YDMTRAJ
TYPE(MODEL)         ,INTENT(INOUT) :: YDMODEL
TYPE(JO_TABLE)      ,INTENT(INOUT) :: YDJOT
TYPE(CLASS_VARBC)   ,INTENT(INOUT),OPTIONAL :: YDVARBC
TYPE(TOVSCV)        ,INTENT(IN)   ,OPTIONAL :: YDTCV5
TYPE(CLASS_SUPERGOM),INTENT(INOUT),OPTIONAL :: YDGOM
TYPE(TOVSCV)        ,INTENT(INOUT),OPTIONAL :: YDTCV
TYPE(CLASS_SUPERGOM),INTENT(IN)   ,OPTIONAL :: YDGOM5
CLASS(DBASE)        ,INTENT(INOUT),OPTIONAL :: YDODB
TYPE(ACV_CONTAINER) ,INTENT(INOUT),OPTIONAL :: YDACV

CHARACTER (LEN = 9) ::  CLCONF
CHARACTER (LEN = 9) ::  CLCON9
CHARACTER (LEN = 10) ::  CLTIMEOD, CLDAT(3)

!   1 : configuration of WRTRA      write the trajectory
!   2 : configuration of LTINV      inverse Legendre transform
!   3 : configuration of FTINV      inverse Fourier transform
!   4 : configuration of GPC        grid point computations
!   5 : configuration of POS        post processing
!   6 : configuration of OBS        comparison to observations
!   7 : configuration of FTDIR      direct Fourier transform
!   8 : configuration of LTDIR      direct Legendre transform
!   9 : configuration of SPC        spectral space computations

!   ZVANA : working array containing the model state.
!   ZVAGR : working array containing the gradient.
TYPE(CONTROL_VECTOR) :: YL_ZVANA, YL_ZVAGR

! - IHISTS : ARRAY CONTAINING TRAJECTORY TIME STEPS
INTEGER(KIND=JPIM) :: IHISTS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRHIS)
! - IGDITS : GRID POINT DIAGNOSTICS TIME STEPS
INTEGER(KIND=JPIM) :: IGDITS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRGDI)
! - ISDITS : SPECTRAL DIAGNOSTICS TIME STEPS
INTEGER(KIND=JPIM) :: ISDITS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRSDI)
! - IREFTS : ARRAY CONTAINING SIMULATED OBS. EVENTS STEPS
INTEGER(KIND=JPIM) :: IREFTS(0:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRREF)
! - IDHFGTS : WRITE OUT TIME STEPS FOR GLOBAL MEANS DDH
INTEGER(KIND=JPIM) :: IDHFGTS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRDHFG)
! - IDHFZTS : WRITE OUT TIME STEPS FOR ZONAL MEANS DDH
INTEGER(KIND=JPIM) :: IDHFZTS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRDHFZ)
! - IDHFDTS : WRITE OUT TIME STEPS FOR LIMITED AREAS DDH
INTEGER(KIND=JPIM) :: IDHFDTS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRDHFD)
! - IDHPTS : PAS DE TEMPS DE SORTIES IMPRIMEES DES DDH
INTEGER(KIND=JPIM) :: IDHPTS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRDHP)
! - IANATS : ANALYSIS WRITE-OUT EVENTS
INTEGER(KIND=JPIM) :: IANATS(0:NSIM4DL/NFRANA)
! - IGRATS : GRADIENT WRITE-OUT EVENTS
INTEGER(KIND=JPIM) :: IGRATS(0:NSIM4DL/NFRGRA)
! - ILSGTS : LBC GRADIENT WRITE-OUT EVENTS
INTEGER(KIND=JPIM) :: ILSGTS(0:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRLSG)

REAL(KIND=JPRB), ALLOCATABLE :: ZSPA3(:,:,:), ZSPSP(:)

INTEGER(KIND=JPIM) :: IACTIM, IDIGLST, JSTEP, I, JJ
INTEGER(KIND=JPIM) :: IHOUR, IMIN
INTEGER(KIND=JPIM) :: IVALUES(9)
INTEGER(KIND=JPIM) :: JTSLOT
INTEGER(KIND=JPIM) :: IPERSUB, ISTEP, ISUB

!   LLSLOT: logical switched on if a slot is available.
LOGICAL :: LL3DVAR,  LLSLOT, LLFIRST
LOGICAL :: LLSPNRM, LLGPNRM
LOGICAL :: LLWRELSG,LLEVS
LOGICAL :: LLSLOT_FGAT, LLFGATLAM
LOGICAL :: LLSOLARCST

REAL(KIND=JPRB) :: ZSTATI, ZSEC, ZI05, ZII0
REAL(KIND=JPRD) :: ZT1, ZT2, ZCT, ZVT, ZWT
REAL(KIND=JPRB) :: ZHOOK_HANDLE

!      -----------------------------------------------------------------

#include "user_clock.h"

#include "abor1.intfb.h"
#include "cain.intfb.h"
#include "cainad.intfb.h"
#include "cainin.intfb.h"
#include "caininad.intfb.h"
#include "costra.intfb.h"
#include "digfilad.intfb.h"
#include "elsin0ta.intfb.h"
#include "evarjkad.intfb.h"
#include "ewrlsgrad.intfb.h"
#include "gpnorm_gfl.intfb.h"
#include "lcnorad.intfb.h"
#include "moevar.intfb.h"
#include "monio_t.intfb.h"
#include "monvar.intfb.h"
#include "obsprep.intfb.h"
#include "obsvad.intfb.h"
#include "spnorm.intfb.h"
#include "stepo.intfb.h"
#include "stepoad.intfb.h"
#include "sueheg.intfb.h"
#include "suhdu.intfb.h"
#include "suheg.intfb.h"
#include "sunhsi.intfb.h"
#include "tslvstst.intfb.h"
#include "updtim.intfb.h"
#include "updtimad.intfb.h"
#include "gridpoint_norm.intfb.h"
#include "add_moderr_ad.intfb.h"

!      -----------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('CNT4AD',0,ZHOOK_HANDLE)
ASSOCIATE(YDGFL5=>YDMTRAJ%YRGFL5,YDGMV5=>YDMTRAJ%YRGMV5, YDGFL=>YDFIELDS%YRGFL,YDGMV=>YDFIELDS%YRGMV, &
 & YDSURF=>YDFIELDS%YRSURF, YDCFU=>YDFIELDS%YRCFU, YDXFU=>YDFIELDS%YRXFU, &
 & YDDIM=>YDGEOMETRY%YRDIM, YDSP=>YDFIELDS%YRSPEC, YDDIMV=>YDGEOMETRY%YRDIMV, YDGEM=>YDGEOMETRY%YRGEM, &
 & YDMP=>YDGEOMETRY%YRMP, YDDYN=>YDMODEL%YRML_DYN%YRDYN,YDRIP=>YDMODEL%YRML_GCONF%YRRIP, &
 & YDPHY3=>YDMODEL%YRML_PHY_MF%YRPHY3, YDEDYN=>YDMODEL%YRML_DYN%YREDYN)

ASSOCIATE(NFRCFU=>YDCFU%NFRCFU, &
 & LSIDG=>YDDYN%LSIDG, LSTRHD=>YDDYN%LSTRHD, NCURRENT_ITER=>YDDYN%NCURRENT_ITER, &
 & NSITER=>YDDYN%NSITER, &
 & LESIDG=>YDEDYN%LESIDG, &
 & NPSP=>YDMP%NPSP, &
 & NSTART=>YDRIP%NSTART, NSTOP=>YDRIP%NSTOP, TDT=>YDRIP%TDT, TSTEP=>YDRIP%TSTEP, &
 & NFRRAZ=>YDXFU%NFRRAZ, NFRXFU=>YDXFU%NFRXFU)
!      -----------------------------------------------------------------

!*       1.    Initialize.
!              -----------

CALL GSTATS(23,0)
WRITE(NULOUT,*)'START CNT4AD, NSIM4D=',GET_NSIM4D()

LL3DVAR = (NCONF == 131.AND.NSTOP == 0)
LLWRELSG=NCONF/100 == 8 .AND. LELAM .AND. N1LSG==1
LLFGATLAM=LELAM .AND. LIDMODEL !BC fgat for aladin


ZI05 = 0.0_JPRB
ZII0 = 0.0_JPRB
LLSOLARCST = .FALSE.
IF (PRESENT(YDACV)) THEN 
  CALL GET_VALUE_FROM_ACV(YDGEOMETRY, YRACV5, 'SOLAR_CONSTANT', ZI05, LLSOLARCST)
ENDIF  

!      -----------------------------------------------------------------

!*       2.    Prepare occurences of I/O and 3D/4D var events.
!              ----------------------------------------------

!*    2.2.1   HISTORY EVENTS FOR ATMOSPHERE
CALL MONIO_T(NSTART,YDRIP,IHISTS(NSTART:),N1HIS,NFRHIS,NHISTS,KN___TSMIN=NHISTSMIN)
!*    2.3   GRID POINT DIAGNOSTICS
CALL MONIO_T(NSTART,YDRIP,IGDITS(NSTART:),N1GDI,NFRGDI,NGDITS)
CALL MONIO_T(NSTART,YDRIP,ISDITS(NSTART:),N1SDI,NFRSDI,NSDITS)
!*    2.5   PRODUCTION DE FICHIER(S) DIAGNOSTICS DDH
!* events not implemented
CALL MONIO_T(NSTART,YDRIP,IDHFGTS(NSTART:),1,NFRDHFG,NDHFGTS,LDACTIVE=.FALSE.)
CALL MONIO_T(NSTART,YDRIP,IDHFZTS(NSTART:),1,NFRDHFZ,NDHFZTS,LDACTIVE=.FALSE.)
CALL MONIO_T(NSTART,YDRIP,IDHFDTS(NSTART:),1,NFRDHFD,NDHFDTS,LDACTIVE=.FALSE.)
CALL MONIO_T(NSTART,YDRIP,IDHPTS(NSTART:),1,NFRDHP,NDHPTS,LDACTIVE=.FALSE.)
!*    3.2   Mass conservation fix-up
CALL MONVAR(YDRIP,IREFTS,IANATS,IGRATS)

IF (LELAM) THEN
  CALL MOEVAR(YDRIP,ILSGTS)
ENDIF


! print config

IF (NPRINTLEV >= 1) THEN
  WRITE(UNIT=NULOUT,FMT='('' GRADIENT WRITE-UP, IGRATS '')')
  WRITE(UNIT=NULOUT,FMT='(40I2)')IGRATS
  WRITE(UNIT=NULOUT,FMT='('' HISTORY WRITE-UP, IHISTS '')')
  WRITE(UNIT=NULOUT,FMT='(40I2)')IHISTS
ENDIF
!      -----------------------------------------------------------

!*       3.    ADJOINT integration.
!              --------------------

!*       3.0  Preliminary calculations.

NSTEP = NSTOP

LLSLOT = .FALSE.
ZSTATI=REAL(NINT(NSTEP*TSTEP),JPRB)

IACTIM = NACTIM

LLSPNRM=ISDITS(NSTEP/MAX(1,NFRSDI)) == 1.AND.MOD(NSTEP,MAX(1,NFRSDI)) == 0
IF(LLSPNRM) THEN
  WRITE(UNIT=NULOUT,FMT='('' NORMS AT START CNT4AD '')')
  CALL SPNORM(YDGEOMETRY,YDMODEL%YRML_GCONF,YDFIELDS%YRSPEC)
  CALL GPNORM_GFL(YDGEOMETRY,YDFIELDS%YRGFL,LDPRINT_TL=.TRUE.)
ENDIF

CLCONF(1:9) = '000000000'

!*       3.21  Miscellaneous.

! Computations in observation space

IF (.NOT.LSIMOB) THEN
  IF(NCONF/100 == 1) THEN
    IF (LOBSTL.AND.LOBS.AND..NOT. LTESTADJM) THEN
      IF(.NOT. (PRESENT(YDVARBC).AND.PRESENT(YDGOM5)))&
       & CALL ABOR1('CNT4AD - YDVARBC and YDGOM5 NEEDED')
      ! PREPARE TRAJECTORY IN OBSERVATION SPACE

      CALL USER_CLOCK(PELAPSED_TIME=ZWT,PVECTOR_CP=ZVT,PTOTAL_CP=ZCT)
      ZCT=ZCT-RSTART
      ZVT=ZVT-RVSTART
      ZWT=ZWT-RTIMEF
      RSTART=RSTART+ZCT
      RVSTART=RVSTART+ZVT
      RTIMEF=RTIMEF+ZWT
      CALL GSTATS(1224,0)
      CALL GSTATS(1224,1)
      WRITE(NULOUT,'('' NSTEP ='',I6,'' OBSVAD  '',A9)') NSTEP,CLCONF
      CALL OBSVAD(YDMODEL%YRML_PHY_EC%YREPHY,YDMODEL%YRML_PHY_MF,YDJOT,YDVARBC,YDTCV5,YDGOM,YDTCV,YDGOM5,YDODB)
    ENDIF
    LLFIRST  = .TRUE.
    LLSLOT = .FALSE.
    DO JTSLOT=NACTIM,1,-1
      ! DIRECT
      IF(LL3DVAR.OR.NTSLVSTST(JTSLOT) == NSTEP ) THEN
        LLSLOT = .TRUE.
        MTSLOTNO = IACTIM
        IF(LLFIRST) THEN
          LLFIRST  = .FALSE.
          YECVAR%NTSLOTNOE = IACTIM
        ENDIF
        YECVAR%NTSLOTNOS = IACTIM
        IACTIM = IACTIM-1
        WRITE(UNIT=NULOUT,FMT='('' CNT4AD (ADJOINT INTEGRATION);''&
         & ,'' TIME SLOT NO : '',I3&
         & ,'' TO BE USED WITH TIME STEP (NSTEP) : '',I3&
         & ,'' ; MODEL TIME (SINCE START) : '',F6.0)')&
         & MTSLOTNO,NSTEP,ZSTATI
        CALL FLUSH(NULOUT)
        IF (LOBS)      THEN
          CALL OBSPREP(YDGEOMETRY,MTSLOTNO,YDODB)
        ENDIF
      ENDIF
    ENDDO
    IF(LLSLOT)   THEN
      MTSLOTNO = YECVAR%NTSLOTNOS
      IF (LOBSTL)  THEN
        ! GOM-ARRAYS ALREADY PREPARED
      ELSE
        IF (LTRREF) THEN
          CLCONF(1:9) = 'B00000000'
        ELSE
          CALL GSTATS(15,0)
          CALL GET_TRAJ_SPEC(YDGEOMETRY,YDMODEL%YRML_GCONF%YRDIMF,TRAJEC(NSTEP),YDFIELDS%YRGMV,YDMTRAJ%YRGMV5,SPA5,NSTEP)
          CALL GSTATS(15,1)
        ENDIF
        IF(LL3DVAR) THEN
          CLCONF(2:3) = 'KD'
        ELSE
          CLCONF(2:3) = 'EC'
        ENDIF
        CLCONF(6:6) = 'V'
        CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDJOT,YDVARBC)
      ENDIF
    ENDIF
    ! ADJOINT
    CLCON9(1:9) = '000000000'
    IF (LLSLOT) THEN
      IF (LL3DVAR) THEN
        CLCON9(2:3) = 'GB'
      ELSEIF (.NOT.LIDMODEL) THEN
        CLCON9(2:3) = 'AA'
      ENDIF
      IF (LOBS) CLCON9(6:6) = 'V'
    ENDIF
    IF (CLCON9(1:9)/='000000000') CALL STEPOAD(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCON9,ZII0,YDVARBC,YDGOM5,YDGOM,YDACV=YDACV)
  ENDIF
ELSE
  IF(.NOT.LTRAJGP) THEN
    IF (LTRREF) THEN
      CLCONF(1:9) = 'B00000000'
    ELSE
      CALL GSTATS(15,0)
      CALL GET_TRAJ_SPEC(YDGEOMETRY,YDMODEL%YRML_GCONF%YRDIMF,TRAJEC(NSTEP),YDFIELDS%YRGMV,YDMTRAJ%YRGMV5,SPA5,NSTEP)
      CALL GSTATS(15,1)
    ENDIF
  ENDIF
ENDIF ! LSIMOB

IF (.NOT.LSIMOB) THEN
ELSE
  IF(NCONF == 801) THEN

    !   ----- observation events management ----------------------

    IF(IREFTS(NSTEP/NFRREF) == 1.AND.MOD(NSTEP,NFRREF) == 0.0_JPRB ) THEN

      !   ----- read observations ----------------------------------

      LTRREF=.TRUE.

      IF (NJROPT /= 1) THEN
        ! do nothing!!
      ELSE
        ! read RF file
        IF(L801TL)THEN
          CLCONF(1:1)='V'
        ELSE
          CLCONF(1:1)='B'
        ENDIF
        CLCONF(2:9)='00000000'
        CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDJOT,YDVARBC)
      ENDIF
      CALL COSTRA(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,YDVARBC)
      LTRREF=.FALSE.

    ENDIF
  ENDIF
ENDIF

!      ----- add the gradient of the Jk cost function
IF (LELAM) THEN
  IF (LEJK) CALL EVARJKAD(YDMP,YDSP)
ENDIF

!        3.1.1 a  Time filtering constraint based on digital filter
!                 is being computed
!                 Its contribution is added to SPA3, SPA2 and SPA1.
!                 ----- adjoint of Jc-dfi for NSTOP ----------------

IF (LJCDFI.AND.LUSEJCDFI) THEN
  ! Step should be local to subwindow
  IF (N_COUPLED_WINDOWS>1) THEN
    ISUB=1
    ISTEP=0
    IF (NSTEP>0) THEN
      IPERSUB=NSTOP/N_COUPLED_WINDOWS
      ISTEP=MOD(NSTEP-1,IPERSUB)+1
      ISUB=(NSTEP-1)/IPERSUB+1
    ENDIF
  ELSE
    ISUB=1
    ISTEP=NSTEP
  ENDIF
  IDIGLST = 2*NSTDFI
  IF (GET_NSIM4D()==0.AND.N_COUPLED_WINDOWS>0) THEN
    WRITE(NULOUT,*)'CNT4AD: Calling DIGFILAD nstep,isub,istep=',NSTEP,ISUB,ISTEP
  ENDIF
  CALL DIGFILAD(YDGEOMETRY,YDMODEL%YRML_GCONF%YRDIMF,ISTEP,IDIGLST,ISUB,YDFIELDS%YRSPEC%SP3D,YDFIELDS%YRSPEC%SP2D, &
 & YDFIELDS%YRSPEC%SP1D,.TRUE.)
ENDIF

!        3.???  Write-up of the gradient (part not present in cnt4tl)

IF ((NCONF/100 == 1.OR.NCONF/100 == 8) .AND. LGRASCAL) THEN
  CALL ALLOCATE_CTLVEC(YL_ZVANA)
  CALL ALLOCATE_CTLVEC(YL_ZVAGR)
ENDIF

!        3.???  ??? (part not present in cnt4tl)

IF (NCONF/100 == 1.OR.NCONF/100 == 8) THEN
  IF (   (IGRATS(GET_NSIM4D()/NFRGRA) == 1.AND.&
     & MOD(GET_NSIM4D(),NFRGRA) == 0.OR.GET_NSIM4D() == NSIM4DL)&
     & .AND.(IHISTS(NSTEP/NFRHIS) == 1.AND.&
     & MOD(NSTEP,NFRHIS) == 0)         )THEN

    IF (LGRASCAL) THEN
      ! WRITE GRADIENT WITH RESPECT TO SCALP INNER-PRODUCT
      ! SAVE GRADIENT WITH RESPECT TO STANDARD INNER-PRODUCT
      WRITE(NULOUT,'(''LGRASCAL=true, sens-grad scaled by the inverse of scalp'')')
      CALL CAININ(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YL_ZVANA,YDVARBC)
      ! GET GRADIENT WITH RESPECT TO SCALP INNER-PRODUCT
      YL_ZVAGR = 0.0_JPRB
      IF (LFORCE) THEN
        CALL CAIN(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YSPFORCE,YDVARBC)
      ENDIF
      CALL CAINAD(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YL_ZVAGR,YDVARBC)
      CALL CAIN(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YL_ZVAGR,YDVARBC)
      LTWGRA = .TRUE.
      CLCONF(1:9)='A00000000'
      CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDJOT,YDVARBC)
      LTWGRA = .FALSE.
      ! FETCH GRADIENT WITH RESPECT TO STANDARD INNER-PRODUCT
      CALL CAIN(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YL_ZVANA,YDVARBC)
    ELSE
      ! WRITE GRADIENT WITH RESPECT TO IMPLICIT(STANDARD) INNER-PRODUCT
      WRITE(NULOUT,'(''LGRASCAL=false, sens-grad not scaled'')')
      IF (LFORCE) THEN
        CALL CAIN(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YSPFORCE,YDVARBC)
      ENDIF
      LTWGRA = .TRUE.
      CLCONF(1:9)='A00000000'
      CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDJOT,YDVARBC)
      LTWGRA = .FALSE.
    ENDIF
  ENDIF
ENDIF

!* TEMPORAL LOOP

IF(NSTART /= NSTAR2 .OR. NSTOP /= NSTOP2) THEN
  WRITE(NULOUT,'('' NSTART, NSTOP ARE DIFFERENT FROM NSTAR2, NSTOP2'')')
  WRITE(NULOUT,'('' NSTART, NSTOP, NSTAR2, NSTOP2: '',4(I5,1X))')&
   & NSTART, NSTOP, NSTAR2, NSTOP2
  WRITE(NULOUT,'('' THEREFORE, TIMESLOT VS TIMESTEP IS RECALCULATED'')')
  CALL TSLVSTST(NSTAR2,NSTOP2,TSTEP,NACTIM,NTSLVSTST)
ENDIF

!*       3.1  Main temporal loop

TEMPORAL_LOOP: DO JSTEP=NSTOP2-1,NSTAR2,-1

  IF (LLFGATLAM .AND. (ALL(NTSLVSTST /= JSTEP)) ) CYCLE

  CALL USER_CLOCK(PTOTAL_CP=ZT1)

  !*     3.2  Current value of the time step length

  IF(JSTEP == 0.OR.LTWOTL)THEN
    TDT=TSTEP
  ELSE
    TDT=2.0_JPRB*TSTEP
  ENDIF

  !*     3.3  Reset of time dependant constants (clock,astronomy...)

  IF (LLSOLARCST) THEN 
    CALL UPDTIM(YDGEOMETRY,YDFIELDS%YRSURF,YDMODEL,JSTEP,TDT,TSTEP,.FALSE.,ZI05)  
    ZII0=0.0_JPRB
  ELSE    
    CALL UPDTIM(YDGEOMETRY,YDFIELDS%YRSURF,YDMODEL,JSTEP,TDT,TSTEP,.FALSE.)
  ENDIF

  !*     3.4  Reset semi-implicit solver in the multilevel model, and the
  !           additional horizontal diffusion operator.

  IF (.NOT.LELAM) THEN

    ! * SI scheme:
    IF (LNHEE) THEN
      CALL SUNHSI(YDMODEL%YRCST,YDGEOMETRY,YDRIP,YDDYN,YDEDYN,NULOUT,.FALSE.)
    ELSE
      IF (LSIDG) THEN
        CALL SUHEG(YDGEOMETRY,YDRIP,YDDYN)
      ENDIF
    ENDIF

    ! * HD scheme:
    IF (LSTRHD) THEN
      ! * This call to SUHDU actually does something in a leap-frog scheme if
      !   TDT=2*TSTEP for the current jstep, and TDT=TSTEP for the previous one
      CALL SUHDU(YDGEOMETRY,YDMODEL%YRML_GCONF,YDDYN)
    ENDIF

  ELSE

    ! * SI scheme:
    IF (NSTOP > 0) THEN
      IF (LNHEE) THEN
        CALL SUNHSI(YDMODEL%YRCST,YDGEOMETRY,YDRIP,YDDYN,YDEDYN,NULOUT,.FALSE.)
      ELSE
        IF (LESIDG) CALL SUEHEG(YDGEOMETRY,YDDYN,YDEDYN,YDRIP)
      ENDIF
    ENDIF

  ENDIF

  !*     3.6  Reset YOMCT3 etc.

  NSTEP=JSTEP
  LLSLOT=.FALSE.
  ZSTATI=REAL(NINT(NSTEP*TSTEP),JPRB)

  LLSPNRM=ISDITS(JSTEP/MAX(1,NFRSDI)) == 1.AND.MOD(JSTEP,MAX(1,NFRSDI)) == 0
  LLGPNRM=IGDITS(JSTEP/MAX(1,NFRGDI)) == 1.AND.MOD(JSTEP,MAX(1,NFRGDI)) == 0
  IF(LLSPNRM) THEN
    WRITE(UNIT=NULOUT,FMT='('' NORMS AT NSTEP CNT4AD '',I4)')NSTEP
    CALL SPNORM(YDGEOMETRY,YDMODEL%YRML_GCONF,YDFIELDS%YRSPEC)
  ENDIF
  IF (LLGPNRM) THEN
    CALL GPNORM_GFL(YDGEOMETRY,YDFIELDS%YRGFL,LDPRINT_TL=.TRUE.)
  ENDIF
  IF (LFCOBSTEST.AND.(GET_NSIM4D()<=4.OR.GET_NSIM4D()==NSIM4DL)) THEN
    WRITE(NULOUT,*)'LFSOBS NORMS AT CNT4AD'
    CALL SPNORM(YDGEOMETRY,YDMODEL%YRML_GCONF,YDFIELDS%YRSPEC)
    CALL GPNORM_GFL(YDGEOMETRY,YDFIELDS%YRGFL,LDPRINT_TL=.TRUE.)
  ENDIF

  !*     3.6.1  Nullify GT3

  IF (LELAM.AND.(NECOAD < 0.OR.LE0COTA).AND.(NSTOP /= 0)) THEN
    CALL ELSIN0TA(YDRIP,YDMODEL%YRML_LBC,YDFIELDS%YRELBC_FIELDS)
  ENDIF

  !*     3.8  Reset time dependent variables

  !*     3.8.6  Add the forcing that was saved during the TL integration

  IF (L_SOS) THEN
    IF (MOD((JSTEP+1),NSTEPS_PER_STATE)==0 .AND. JSTEP+1 < NSTOP) THEN
      I = (JSTEP+1)/NSTEPS_PER_STATE
      ALLOCATE (ZSPA3(SIZE(YDFIELDS%YRSPEC%SP3D,1),SIZE(YDFIELDS%YRSPEC%SP3D,2),SIZE(YDFIELDS%YRSPEC%SP3D,3)))  !! were SPA3
      ZSPA3(:,:,:) = YDFIELDS%YRSPEC%SP3D(:,:,:)
      IF (NPSP==1) THEN
        ALLOCATE (ZSPSP(SIZE(YDFIELDS%YRSPEC%SP)))  !! was SPA3
        ZSPSP(:)   = YDFIELDS%YRSPEC%SP(:)
      ENDIF
      CALL CAININAD(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YSTATE_VECTOR_4D(I),YDVARBC)
      IF(LOCNORM) CALL LCNORAD(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL)
      YDFIELDS%YRSPEC%SP3D(:,:,:) = YDFIELDS%YRSPEC%SP3D(:,:,:) + ZSPA3(:,:,:)  !! were SPA3
      DEALLOCATE (ZSPA3)
      IF (NPSP==1) THEN
        YDFIELDS%YRSPEC%SP(:)   = YDFIELDS%YRSPEC%SP(:)   + ZSPSP(:)  !!! were SPA3
        DEALLOCATE (ZSPSP)
      ENDIF
    ENDIF
  ENDIF

  !*     3.8.7  Manage trajectory
  !             Initialize CLCONF for call to STEPO (trajectory)

  IF (LTRREF) THEN
    CLCONF(1:9) = 'BE0000000'
  ELSE
    IF(.NOT.LTRAJGP) THEN
      CALL GSTATS(15,0)
      CALL GET_TRAJ_SPEC(YDGEOMETRY,YDMODEL%YRML_GCONF%YRDIMF,TRAJEC(NSTEP),YDFIELDS%YRGMV,YDMTRAJ%YRGMV5,SPA5,NSTEP)
      CALL GSTATS(15,1)
    ENDIF
    CLCONF(1:9)='0E0000000'
  ENDIF

  ! first call for (first-guess) trajectory
  ! don't understand anymore why this is only for Aladin (CF) ...
  ! In cnt4tl this is also called for lelam=false (K.Y.)
  IF(.NOT.LTRAJGP.AND.LELAM .AND. .NOT. LIDMODEL) THEN
    CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDJOT,YDVARBC)
  ENDIF

  !*       3.12  MODERR

  IF (LMODERR.AND.NTYPE_MODERR==2) CALL ADD_MODERR_AD(YDGEOMETRY,YDFIELDS,SPMODERR,GPMODERR,NSTEP)

  !*       3.11  Corrector step.

  IF(NSITER > 0) THEN
    ! NSITER>0 not coded in the AD code
    CALL ABOR1(' CNT4AD: NSITER>0 not coded in the AD code')
  ENDIF

  !*       3.10  Ordinary time step (predictor if PC scheme).
  !              Initialize CLCON9 for call to STEPOAD

  CLCON9(1:9)='0AAA00AAA'
  NCURRENT_ITER=0

  IF (NSITER == 0) THEN
    CLCON9(9:9)='A'
  ELSEIF (NSITER > 0) THEN
    ! NSITER>0 not coded in the AD code
    CALL ABOR1(' CNT4AD: NSITER>0 not coded in the AD code')
  ELSEIF(NSITER < 0) THEN
    CALL ABOR1('NEGATIVE NSITER NOT ALLOWED')
  ENDIF

  IF (LIDMODEL) THEN
    IF (JSTEP/=0) THEN
      CLCON9(2:3)='00'
    ENDIF
    CLCON9(4:5)='00'
    CLCON9(7:9)='000'
  ENDIF

  !*     3.???  Observations (part not present in cnt4tl)

  IF (.NOT.LSIMOB)          THEN
    ! Real observations

    LLSLOT  = .FALSE.
    LLFIRST = .TRUE.
    LLSLOT_FGAT = .FALSE.
    CALL GSTATS(1832,0)
    DO JTSLOT=NACTIM,1,-1
      IF(LOBS.AND.NTSLVSTST(JTSLOT) == NSTEP ) THEN
        LLSLOT = .TRUE.
        LLSLOT_FGAT=( LLSLOT .AND. LIDMODEL )
        MTSLOTNO = IACTIM
        IF(LLFIRST) THEN
          LLFIRST  = .FALSE.
          YECVAR%NTSLOTNOE = IACTIM
        ENDIF
        YECVAR%NTSLOTNOS = IACTIM
        IACTIM = IACTIM-1
        IF (LOBSTL) THEN
          !  GOM-ARRAYS ALREADY PREPARED
        ELSE
          CLCONF(3:3) = 'C'
          CLCONF(6:6) = 'V'
          IF (CLCONF(2:3) == 'AC') THEN
            ! ky: non-existing conf, leading to ABOR1 in TRANSINVH => obsolete piece of code.
            CALL ABOR1(' CNT4AD: non existing conf CLCONF(2:3)=AC ')
          ENDIF
        ENDIF
        WRITE(UNIT=NULOUT,FMT='('' CNT4AD (TEMPORAL LOOP);''&
         & ,'' TIME SLOT NO : '',I3&
         & ,'' TO BE USED WITH TIME STEP (NSTEP) : '',I3&
         & ,'' ; MODEL TIME (SINCE START) : '',F6.0)')&
         & MTSLOTNO,NSTEP,ZSTATI
        CALL FLUSH(NULOUT)
        IF (LOBS)      THEN
          CALL OBSPREP(YDGEOMETRY,MTSLOTNO,YDODB)
        ENDIF
      ENDIF
    ENDDO
    CALL GSTATS(1832,1)
    IF ((.NOT.LTRAJGP .AND. .NOT. LIDMODEL) .OR. LLSLOT_FGAT ) THEN
      CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDJOT,YDVARBC)
    ENDIF

    IF(LLSLOT) THEN
      MTSLOTNO = YECVAR%NTSLOTNOS
      CLCON9(6:6)='V'
    ENDIF

    IF (CLCON9(1:9)/='000000000') CALL STEPOAD(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCON9,ZII0,YDVARBC,YDGOM5,YDGOM,YDACV=YDACV)
  ELSE

    ! Simulated observations

    ! Trajectory.
    IF(.NOT.LTRAJGP) THEN
      CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDJOT,YDVARBC)
    ENDIF
    ! Adjoint integration.
    CALL STEPOAD(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCON9,ZII0,YDVARBC,YDGOM5,YDGOM,YDACV=YDACV)

    IF(IREFTS(JSTEP/NFRREF) == 1.AND.MOD(JSTEP,NFRREF) == 0&
       & .AND.NCONF == 801) THEN

      !* read observations and not trajectory
      LTRREF=.TRUE.
      IF(L801TL)THEN
         CLCONF(1:1)='V'
       ELSE
         CLCONF(1:1)='B'
       ENDIF
      CLCONF(2:9)='00000000'
      CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDJOT,YDVARBC)
      CALL COSTRA(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,YDVARBC)
      LTRREF=.FALSE.
    ENDIF
  ENDIF

  !      3.1.1 b  Time filtering constraint based on digital filter
  !               is being computed
  !               Its contribution is added to SPA3, SPA2 and SPA1.

  IF (LJCDFI.AND.LUSEJCDFI) THEN
    ! Step should be local to subwindow
    IF (N_COUPLED_WINDOWS>1) THEN
      ISUB=1
      ISTEP=0
      IF (NSTEP>0) THEN
        IPERSUB=NSTOP/N_COUPLED_WINDOWS
        ISTEP=MOD(NSTEP-1,IPERSUB)+1
        ISUB=(NSTEP-1)/IPERSUB+1
      ENDIF
    ELSE
      ISUB=1
      ISTEP=NSTEP
    ENDIF
    IDIGLST = 2*NSTDFI
    IF (GET_NSIM4D()==0.AND.N_COUPLED_WINDOWS>0) THEN
      WRITE(NULOUT,*)'CNT4AD: Calling DIGFILAD nstep,isub,istep=',NSTEP,ISUB,ISTEP
    ENDIF
    CALL DIGFILAD(YDGEOMETRY,YDMODEL%YRML_GCONF%YRDIMF,ISTEP,IDIGLST,ISUB,YDFIELDS%YRSPEC%SP3D,YDFIELDS%YRSPEC%SP2D, &
 & YDFIELDS%YRSPEC%SP1D,.TRUE.)
  ENDIF

  !*     3.???  Write-up of the gradient (part not present in cnt4tl).

  IF (NCONF/100 == 1.OR.NCONF/100 == 8) THEN
    IF (   (IGRATS(GET_NSIM4D()/NFRGRA) == 1.AND.&
       & MOD(GET_NSIM4D(),NFRGRA) == 0.OR.GET_NSIM4D() == NSIM4DL)&
       & .AND.(IHISTS(NSTEP/NFRHIS) == 1.AND.&
       & MOD(NSTEP,NFRHIS) == 0)         )THEN

      IF (LGRASCAL) THEN
        ! WRITE GRADIENT WITH RESPECT TO SCALP INNER-PRODUCT
        ! SAVE GRADIENT WITH RESPECT TO STANDARD INNER-PRODUCT
        CALL CAININ(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YL_ZVANA,YDVARBC)
        ! GET GRADIENT WITH RESPECT TO SCALP INNER-PRODUCT
        YL_ZVAGR = 0.0_JPRB
        IF (LFORCE) THEN
          CALL CAIN(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YSPFORCE,YDVARBC)
        ENDIF
        CALL CAINAD(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YL_ZVAGR,YDVARBC)
        CALL CAIN(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YL_ZVAGR,YDVARBC)
        LTWGRA = .TRUE.
        CLCONF(1:9)='A00000000'
        CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDJOT,YDVARBC)
        LTWGRA = .FALSE.
        ! FETCH GRADIENT WITH RESPECT TO STANDARD INNER-PRODUCT
        CALL CAIN(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YL_ZVANA,YDVARBC)
      ELSE
        ! WRITE GRADIENT WITH RESPECT TO IMPLICIT(STANDARD) INNER-PRODUCT
        IF (LFORCE) THEN
          CALL CAIN(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YSPFORCE,YDVARBC)
        ENDIF
        LTWGRA = .TRUE.
        CLCONF(1:9)='A00000000'
        CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDJOT,YDVARBC)
        LTWGRA = .FALSE.
      ENDIF
    ENDIF
    IF (LLWRELSG) THEN
      IF (((ILSGTS(NSTEP/NFRLSG) == 1.AND.MOD(NSTEP,NFRLSG) == 0)&
         & .OR.(NSTEP == 1)).AND.NSTEP /= 0) THEN
        CALL EWRLSGRAD(YDGEOMETRY,YDMODEL%YRML_GCONF,YDMODEL%YRML_LBC,YDFIELDS%YRELBC_FIELDS)
      ENDIF
    ENDIF
  ENDIF

  !*     3.13  Copy state for use as forcing during the TL integration

  IF (L_EOFS) THEN
    IF (MOD((JSTEP+1),NSTEPS_PER_STATE)==0 .AND. JSTEP+1 < NSTOP) THEN
      I = (JSTEP+1)/NSTEPS_PER_STATE
      YSTATE_VECTOR_4D(I)%DATA = 0.0_JPRB
      CALL CAINAD(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YSTATE_VECTOR_4D(I),YDVARBC)
    ENDIF
  ENDIF

  !*     3.15  Signal SMS event for completion of post_processing

  CALL USER_CLOCK(PTOTAL_CP=ZT2)
  CALL DATE_AND_TIME(CLDAT(1),CLTIMEOD,CLDAT(3),IVALUES)
  ZSEC   = REAL(NSTEP,JPRB)*TSTEP +0.5_JPRB
  IHOUR  = INT( ZSEC/3600._JPRB )
  IMIN   = INT( (ZSEC-REAL(IHOUR,JPRB)*3600._JPRB)/60._JPRB )

  IF (LLSOLARCST) CALL UPDTIMAD(YDGEOMETRY,YDMODEL,JSTEP,YDACV,ZII0)

ENDDO TEMPORAL_LOOP


!*       3.20  Miscellaneous (deallocations and final call to SPNORM).

IF ((NCONF/100 == 1.OR.NCONF/100 == 8) .AND. LGRASCAL) THEN
  CALL DEALLOCATE_CTLVEC(YL_ZVANA)
  CALL DEALLOCATE_CTLVEC(YL_ZVAGR)
ENDIF

LLSPNRM=ISDITS(NSTEP/MAX(1,NFRSDI)) == 1.AND.MOD(NSTEP,MAX(1,NFRSDI)) == 0
IF (LLSPNRM.OR.GET_NSIM4D()<=1.OR.GET_NSIM4D()==NSIM4DL) THEN
  WRITE(UNIT=NULOUT,FMT='('' NORMS AT END CNT4AD '')')
  CALL SPNORM(YDGEOMETRY,YDMODEL%YRML_GCONF,YDFIELDS%YRSPEC)
  CALL GPNORM_GFL(YDGEOMETRY,YDFIELDS%YRGFL,LDPRINT_TL=.TRUE.)
  IF (LMODERR) THEN
    LLEVS=(NPRTMODERR>=2)
    DO JJ=1,NDIM_MODERR
      CALL SPECTRAL_NORM (SPMODERR(JJ),'CNT4AD MODERR')
      CALL GRIDPOINT_NORM(YDGEOMETRY,GPMODERR(JJ),'CNT4AD MODERR',LDLEVS=LLEVS)
    ENDDO
  ENDIF
ENDIF

CALL GSTATS(23,1)
!      -----------------------------------------------------------------

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('CNT4AD',1,ZHOOK_HANDLE)
END SUBROUTINE CNT4AD
