SUBROUTINE CNT4TL(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,YDJOT,YDVARBC,YDTCV5,YDGOM,YDTCV,YDGOM5,YDODB,YDACV)

!**** *CNT4TL*  - Controls tangent linear model at level 4

!     Purpose.
!     --------
!     Controls the temporal loop

!**   Interface.
!     ----------
!        *CALL* *CNT4TL

!        Explicit arguments :
!        --------------------
!        None

!        Implicit arguments :
!        --------------------
!        None

!     Method.
!     -------
!        See documentation

!     Externals.
!     ----------
!        Called by CNT3TL.

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!      Mats Hamrud and Philippe Courtier  *ECMWF*
!      Original : 87-10-15

! Modifications
! -------------
!   B. Chapnik    02-May-2007 fgat : temporal loop considered only if tstep corresponds to tslot
!                                    and call to stepo only when needed
!   Y. Seity     11-Jan-2008 : add ISHISTS for surfex output files   
!   Y.Tremolet    27-Nov-2008 Jc-DFI for long windows
!   F. Vana   13-Jan-2009 : Removed special specHD setup when LSLHD
!   A. Alias      07-Aug-2009 Arguments added/modified to MONIO for surfex output files
!   K. Yessad (Aug 2009): remove LSITRIC option
!   K. Yessad (Jan 2011): new architecture for LBC modules and set-up.
!   K. Yessad (Feb 2012): various contributions.
!   F. Vana  28-Nov-2013 : Redesigned trajectory handling.
!   R. El Khatib 04-Aug-2014 Pruning of the conf. 927/928
!   K. Yessad (July 2014): Move some variables.
!   F. Vana  05-Mar-2015  Support for single precision
!   A. Geer  27 Jul 2015 More OOPS cleaning: VARBC encapsulated in an object
!   A. Geer  05 Mar 2016 SuperGOM object for OOPS; protect against adjoint model test
!   M. Janiskova 14-Mar-2016 Post-processing increments
!   O. Marsden  Aug 2016 Removed use of SPA3
!   P. Lean    17 Aug 2016 ODB dbase object for OOPS
!   R. El Khatib 07-Mar-2016 Pruning of ISP
!   K. Yessad (June 2017): Introduce NHQE model.
!   R. El Khatib  04-Jun-2018 refactor suct1 against monio
!   S. Massart   19-Feb-2019 Solar constant optimisation
!      -----------------------------------------------------------------

USE TYPE_MODEL    , ONLY : MODEL
USE GEOMETRY_MOD  , ONLY : GEOMETRY
USE FIELDS_MOD    , ONLY : FIELDS
USE MTRAJ_MOD     , ONLY : MTRAJ
USE PARKIND1      , ONLY : JPRD, JPIM, JPRB
USE YOMHOOK       , ONLY : LHOOK, DR_HOOK
USE JO_TABLE_MOD  , ONLY : JO_TABLE
USE YOMDIMO       , ONLY : NOBTOTG
USE YOMLUN        , ONLY : NULOUT
USE YOMVAR        , ONLY : NSIMU, NFRREF, NFRANA, NFRGRA, NSIM4DL,&
 &                         LTWINC, LTWANA, LJCDFI, LTRREF, LMODERR, LFCOBSTEST
USE YOMCT0        , ONLY : NCONF, NFRPOS, NPOSTS, NPOSTSMIN, &
 &                         NFRGDI, NFRSDI, NFRDHFG, NFRDHFZ, NFRDHFD,&
 &                         NGDITS   ,NSDITS   ,NDHFGTS  ,NDHFZTS  ,NDHFDTS  ,NDHPTS, &
 &                         NFRDHP, LFDBOP, LTWOTL, LOBS, LELAM, LECMWF, LNHEE
USE YOMCT1        , ONLY : N1POS, N1GDI, N1SDI
USE YOMCT2        , ONLY : NSTAR2, NSTOP2
USE YOMCT3        , ONLY : NSTEP
USE YOMECTAB      , ONLY : NTSLVSTST, MTSLOTNO
USE YOMVRTL       , ONLY : L131TL, LOBSTL, LIDMODEL
USE YOMMP0        , ONLY : NOUTTYPE, NPRINTLEV
USE YOMTIM        , ONLY : RSTART, RVSTART, RTIMEF
USE YEMJK         , ONLY : LEJK
USE YOMDFI        , ONLY : NSTDFI
USE YOMSP5        , ONLY : SPA5
USE YOETLDIAG     , ONLY : NSIM4DWR
USE YOMLCZ        , ONLY : L_SOS, L_EOFS, NSTEPS_PER_STATE, YSTATE_VECTOR_4D, LOCNORM
USE TRAJECTORY_MOD, ONLY : LTRAJGP, GET_TRAJ_SPEC
USE YOMTRAJ       , ONLY : TRAJEC
USE YOMMODERR     , ONLY : NTYPE_MODERR, NDIM_MODERR, NPRTMODERR,&
 &                         SPMODERR, GPMODERR, N_COUPLED_WINDOWS
USE YEMLBC_INIT   , ONLY : LE0COTA, NFRLSG
USE VARBC_CLASS   , ONLY : CLASS_VARBC
USE TOVSCV_MOD    , ONLY : TOVSCV
USE SUPERGOM_CLASS, ONLY : CLASS_SUPERGOM
USE TESTVAR_MIX   , ONLY : LTESTADJM
USE DBASE_MOD     , ONLY : DBASE
USE TYPE_ACV      , ONLY : ACV_CONTAINER
USE YOMJBACV      , ONLY : YRACV5
USE YOMJBPAR1DACV , ONLY : GET_VALUE_FROM_ACV
USE SPECTRAL_FIELDS_MOD, ONLY : ASSIGNMENT(=), SPECTRAL_NORM
USE ALGORITHM_STATE_MOD, ONLY : GET_NSIM4D
USE CONTROL_VECTORS_MOD

!      -----------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)      ,INTENT(INOUT) :: YDGEOMETRY  !! INOUT needed for call to IOPACK
TYPE(FIELDS)        ,INTENT(INOUT) :: YDFIELDS
TYPE(MTRAJ)         ,INTENT(INOUT) :: YDMTRAJ
TYPE(MODEL)         ,INTENT(INOUT) :: YDMODEL
TYPE(CLASS_VARBC)   ,INTENT(INOUT),OPTIONAL :: YDVARBC
TYPE(TOVSCV)        ,INTENT(IN)   ,OPTIONAL :: YDTCV5
TYPE(CLASS_SUPERGOM),INTENT(INOUT),OPTIONAL :: YDGOM, YDGOM5
TYPE(TOVSCV)        ,INTENT(IN)   ,OPTIONAL :: YDTCV
TYPE(ACV_CONTAINER) ,INTENT(INOUT),OPTIONAL :: YDACV
CLASS(DBASE)        ,INTENT(INOUT) :: YDODB
TYPE(JO_TABLE)      ,INTENT(INOUT) :: YDJOT

CHARACTER (LEN = 10) ::  CLTIMEOD,CLDAT(3)
CHARACTER (LEN = 9) ::  CLCONF ! see CDCONF comments in STEPOTL

! - IPOSTS : ARRAY CONTAINING POST-PROCESSING TIME STEPS
INTEGER(KIND=JPIM) :: IPOSTS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRPOS)
! - IGDITS : GRID POINT DIAGNOSTICS TIME STEPS
INTEGER(KIND=JPIM) :: IGDITS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRGDI)
! - ISDITS : SPECTRAL DIAGNOSTICS TIME STEPS
INTEGER(KIND=JPIM) :: ISDITS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRSDI)
! - IDHFGTS : WRITE OUT TIME STEPS FOR GLOBAL MEANS DDH
INTEGER(KIND=JPIM) :: IDHFGTS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRDHFG)
! - IDHFZTS : WRITE OUT TIME STEPS FOR ZONAL MEANS DDH
INTEGER(KIND=JPIM) :: IDHFZTS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRDHFZ)
! - IDHFDTS : WRITE OUT TIME STEPS FOR LIMITED AREAS DDH
INTEGER(KIND=JPIM) :: IDHFDTS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRDHFD)
! - IDHPTS : PAS DE TEMPS DE SORTIES IMPRIMEES DES DDH
INTEGER(KIND=JPIM) :: IDHPTS(YDMODEL%YRML_GCONF%YRRIP%NSTART:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRDHP)
! - IANATS : ARRAY CONTAINING ITERATIONS FOR WHICH THE ANALYSIS
!        MUST BE WRITTEN ON FILE, POST-PROCESSED TO MODEL LEVELS.
INTEGER(KIND=JPIM) :: IANATS(0:NSIM4DL/NFRANA)
! - IGRATS : ARRAY CONTAINING ITERATIONS FOR WRITE OUT OF GRADIENTS
INTEGER(KIND=JPIM) :: IGRATS(0:NSIM4DL/NFRGRA)
! - IREFTS : ARRAY CONTAINING ITERATIONS FOR WRITE OUT OF REFERENCE STATE
INTEGER(KIND=JPIM) :: IREFTS(0:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRREF)
! - ILSGTS : ARRAY CONTAINING ITERATIONS FOR LBC GRADIENTS I/O
INTEGER(KIND=JPIM) :: ILSGTS(0:YDMODEL%YRML_GCONF%YRRIP%NSTOP/NFRLSG)

REAL(KIND=JPRB), ALLOCATABLE :: ZSPA3(:,:,:), ZSPSP(:)

INTEGER(KIND=JPIM) :: IACTIM,IDIGLST,IOUTTYPE, ISTOP, J, JSTEP, I&
                  & , JJ, IACTIM2, IPERSUB, ISTEP, ISUB
INTEGER(KIND=JPIM) :: IHOUR, IMIN, IVALUES(9)

LOGICAL :: LL3DVAR, LLFDBOP, LLPLPP, LLSLOT, LLEVS
LOGICAL :: LLSPNRM,LLGPNRM, LLSLOT2, LLFGATLAM, LLSOLARCST

REAL(KIND=JPRB) :: ZSEC, ZI05, ZII0
REAL(KIND=JPRD) :: ZT1, ZT2, ZCT, ZVT, ZWT
REAL(KIND=JPRB) :: ZHOOK_HANDLE

!      -----------------------------------------------------------------

#include "user_clock.h"

#include "abor1.intfb.h"
#include "add5to3.intfb.h"
#include "cain.intfb.h"
#include "cainin.intfb.h"
#include "chkobtim.intfb.h"
#include "digfil.intfb.h"
#include "elsin0ta.intfb.h"
#include "evarjk.intfb.h"
#include "gpnorm_gfl.intfb.h"
#include "iopack.intfb.h"
#include "lcnortl.intfb.h"
#include "moevar.intfb.h"
#include "monio_t.intfb.h"
#include "monvar.intfb.h"
#include "obsv.intfb.h"
#include "obsvtl.intfb.h"
#include "spnorm.intfb.h"
#include "stepo.intfb.h"
#include "stepotl.intfb.h"
#include "sbs5to3.intfb.h"
#include "sueheg.intfb.h"
#include "suhdu.intfb.h"
#include "suheg.intfb.h"
#include "sunhsi.intfb.h"
#include "updtim.intfb.h"
#include "updtimtl.intfb.h"
#include "savmoderr.intfb.h"
#include "gridpoint_norm.intfb.h"
#include "add_moderr_tl.intfb.h"

!      -----------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('CNT4TL',0,ZHOOK_HANDLE)
ASSOCIATE(YDGFL5=>YDMTRAJ%YRGFL5,YDGMV5=>YDMTRAJ%YRGMV5, YDGFL=>YDFIELDS%YRGFL,YDGMV=>YDFIELDS%YRGMV, &
 & YDSURF=>YDFIELDS%YRSURF, YDCFU=>YDFIELDS%YRCFU,YDXFU=>YDFIELDS%YRXFU, &
 & YDDIM=>YDGEOMETRY%YRDIM, YDDIMV=>YDGEOMETRY%YRDIMV, YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP, &
 & YDDYN=>YDMODEL%YRML_DYN%YRDYN, YDEPHLI=>YDMODEL%YRML_PHY_SLIN%YREPHLI, &
 & YDRIP=>YDMODEL%YRML_GCONF%YRRIP,YDDIMACV=>YDMODEL%YRML_GCONF%YRDIMACV,YDEDYN=>YDMODEL%YRML_DYN%YREDYN, &
 & YDLDDH=>YDMODEL%YRML_DIAG%YRLDDH)

ASSOCIATE(NFRCFU=>YDCFU%NFRCFU, &
 & LSIDG=>YDDYN%LSIDG, LSTRHD=>YDDYN%LSTRHD, NCURRENT_ITER=>YDDYN%NCURRENT_ITER, &
 & NSITER=>YDDYN%NSITER, &
 & LESIDG=>YDEDYN%LESIDG, &
 & LTLEVOL=>YDEPHLI%LTLEVOL, &
 & LHDOUFD=>YDLDDH%LHDOUFD, LHDOUFG=>YDLDDH%LHDOUFG, LHDOUFZ=>YDLDDH%LHDOUFZ, &
 & LHDOUP=>YDLDDH%LHDOUP, &
 & NPSP=>YDMP%NPSP, &
 & NSTART=>YDRIP%NSTART,NSTOP=>YDRIP%NSTOP, TDT=>YDRIP%TDT, TSTEP=>YDRIP%TSTEP, &
 & NFRRAZ=>YDXFU%NFRRAZ, NFRXFU=>YDXFU%NFRXFU)
!      -----------------------------------------------------------------

!*       1.    Initialize.
!              -----------

CALL GSTATS(22,0)
WRITE(NULOUT,*)'START CNT4TL, NSIM4D=',GET_NSIM4D()

LL3DVAR=(NCONF == 131.AND.NSTOP == 0)

!!BC 3d-fgat-case
LLFGATLAM=(LELAM .AND. LIDMODEL)

ZI05 = 0.0_JPRB
LLSOLARCST = .FALSE.
IF (PRESENT(YDACV)) THEN 
  CALL GET_VALUE_FROM_ACV(YDGEOMETRY, YRACV5, 'SOLAR_CONSTANT', ZI05, LLSOLARCST)
ENDIF  


!      -----------------------------------------------------------------

!*       2.    Prepare occurences of I/O events.
!              ---------------------------------

!*    2.1   POST-PROCESSING EVENTS
CALL MONIO_T(NSTART,YDRIP,IPOSTS(NSTART:),N1POS,NFRPOS,NPOSTS,KN___TSMIN=NPOSTSMIN)
!*    2.3   GRID POINT DIAGNOSTICS
CALL MONIO_T(NSTART,YDRIP,IGDITS(NSTART:),N1GDI,NFRGDI,NGDITS)
CALL MONIO_T(NSTART,YDRIP,ISDITS(NSTART:),N1SDI,NFRSDI,NSDITS)
!*    2.5   PRODUCTION DE FICHIER(S) DIAGNOSTICS DDH
!* events not implemented
CALL MONIO_T(NSTART,YDRIP,IDHFGTS(NSTART:),1,NFRDHFG,NDHFGTS,LDACTIVE=.FALSE.)
CALL MONIO_T(NSTART,YDRIP,IDHFZTS(NSTART:),1,NFRDHFZ,NDHFZTS,LDACTIVE=.FALSE.)
CALL MONIO_T(NSTART,YDRIP,IDHFDTS(NSTART:),1,NFRDHFD,NDHFDTS,LDACTIVE=.FALSE.)
CALL MONIO_T(NSTART,YDRIP,IDHPTS(NSTART:),1,NFRDHP,NDHPTS,LDACTIVE=.FALSE.)

CALL MONVAR(YDRIP,IREFTS,IANATS,IGRATS)

IF (LELAM) THEN
  CALL MOEVAR(YDRIP,ILSGTS)
ENDIF

IF (NPRINTLEV >= 1) THEN
  WRITE(NULOUT,'('' POST-PROCESSING EVENTS, IPOSTS '')')
  WRITE(NULOUT,'(40I2)')IPOSTS
  WRITE(NULOUT,'('' AN WRITE-OUT EVENTS, IANATS '')')
  WRITE(NULOUT,'(40I2)') (IANATS(J),J=0,NSIMU/NFRANA)
ENDIF
IACTIM=1
IACTIM2=1

IF (GET_NSIM4D()<=2.OR.GET_NSIM4D()==NSIM4DL.OR.LTLEVOL) THEN
  WRITE(NULOUT,*)'NORMS AT START CNT4TL'
  CALL SPNORM(YDGEOMETRY,YDMODEL%YRML_GCONF,YDFIELDS%YRSPEC)
  CALL GPNORM_GFL(YDGEOMETRY,YDFIELDS%YRGFL,LDPRINT_TL=.TRUE.)
  LLEVS=(NPRTMODERR>=2)
  DO JJ=1,NDIM_MODERR
    CALL SPECTRAL_NORM (SPMODERR(JJ),'CNT4TL MODERR')
    CALL GRIDPOINT_NORM(YDGEOMETRY,GPMODERR(JJ),'CNT4TL MODERR',LDLEVS=LLEVS)
  ENDDO
ENDIF

!      -----------------------------------------------------------------

!*       3.    Tangent-linear integration.
!              ---------------------------

!*       3.1  Main temporal loop

IF(NSTOP2 == NSTOP)THEN
  ! For final time step (diagnostics, post-processing)
  ISTOP=NSTOP
ELSE
  ISTOP=NSTOP2-1
ENDIF

!     Temporal loop begins ...

TEMPORAL_LOOP: DO JSTEP=NSTAR2,ISTOP

  IF (LLFGATLAM .AND. (ALL(NTSLVSTST /= JSTEP)) .AND. (JSTEP /= ISTOP)) CYCLE

  CALL USER_CLOCK(PTOTAL_CP=ZT1)

  !      3.1.1  Time filtering constraint based on digital filter is being computed.

  IF (LJCDFI) THEN
    ! Step should be local to subwindow
    IF (N_COUPLED_WINDOWS>1) THEN
      ISUB=1
      ISTEP=0
      IF (JSTEP>0) THEN
        IPERSUB=NSTOP/N_COUPLED_WINDOWS
        ISTEP=MOD(JSTEP-1,IPERSUB)+1
        ISUB=(JSTEP-1)/IPERSUB+1
      ENDIF
    ELSE
      ISUB=1
      ISTEP=JSTEP
    ENDIF
    IDIGLST=2*NSTDFI
    IF (GET_NSIM4D()==0.AND.N_COUPLED_WINDOWS>0) THEN
      WRITE(NULOUT,*)'CNT4TL: Calling DIGFIL: jstep,isub,istep=',JSTEP,ISUB,ISTEP
    ENDIF
    CALL DIGFIL(YDGEOMETRY,YDFIELDS%YRGFL,YDMODEL%YRML_GCONF,ISTEP, IDIGLST, ISUB, &
         &     YDFIELDS%YRSPEC%SP3D, YDFIELDS%YRSPEC%SP2D, YDFIELDS%YRSPEC%SP1D, .TRUE.)  !! were SPA3
  ENDIF

  !*     3.2  Current value of the time step length

  IF(JSTEP == 0.OR.LTWOTL)THEN
    TDT=TSTEP
  ELSE
    TDT=2.0_JPRB*TSTEP
  ENDIF

  !*     3.3  Reset of time dependant constants (clock,astronomy...)

  IF (LLSOLARCST) THEN 
    CALL UPDTIM(YDGEOMETRY,YDFIELDS%YRSURF,YDMODEL,JSTEP,TDT,TSTEP,.FALSE.,ZI05)  
    CALL UPDTIMTL(YDGEOMETRY,YDMODEL,JSTEP,YDACV,ZII0)
  ELSE
    ZII0 = 0._JPRB
    CALL UPDTIM(YDGEOMETRY,YDFIELDS%YRSURF,YDMODEL,JSTEP,TDT,TSTEP,.FALSE.)  
  ENDIF

  !*     3.4  Reset semi-implicit solver in the multilevel model, and the
  !           additional horizontal diffusion operator.

  IF (.NOT.LELAM) THEN

    ! * SI scheme:
    IF (LNHEE) THEN
      CALL SUNHSI(YDMODEL%YRCST,YDGEOMETRY,YDRIP,YDDYN,YDEDYN,NULOUT,.FALSE.)
    ELSE
      IF (LSIDG) THEN
        CALL SUHEG(YDGEOMETRY,YDRIP,YDDYN)
      ENDIF
    ENDIF

    ! * HD scheme:
    IF (LSTRHD) THEN
      ! * This call to SUHDU actually does something in a leap-frog scheme if
      !   TDT=2*TSTEP for the current jstep, and TDT=TSTEP for the previous one.
      CALL SUHDU(YDGEOMETRY,YDMODEL%YRML_GCONF,YDDYN)
    ENDIF

  ELSE

    ! * SI scheme:
    IF (NSTOP > 0) THEN
      IF (LNHEE) THEN
        CALL SUNHSI(YDMODEL%YRCST,YDGEOMETRY,YDRIP,YDDYN,YDEDYN,NULOUT,.FALSE.)
      ELSE
        IF (LESIDG) CALL SUEHEG(YDGEOMETRY,YDDYN,YDEDYN,YDRIP)
      ENDIF
    ENDIF

  ENDIF

  !*     3.6  Reset YOMCT3

  NSTEP=JSTEP

  !*     3.6.1  Nullify GT3

  IF (LELAM.AND.LE0COTA.AND.(NSTOP /= 0)) THEN
    CALL ELSIN0TA(YDRIP,YDMODEL%YRML_LBC,YDFIELDS%YRELBC_FIELDS)
  ENDIF

  !*     3.8  Reset time dependent variables

  LLSPNRM=ISDITS(JSTEP/MAX(1,NFRSDI)) == 1.AND.MOD(JSTEP,MAX(1,NFRSDI)) == 0
  LLGPNRM=IGDITS(JSTEP/MAX(1,NFRGDI)) == 1.AND.MOD(JSTEP,MAX(1,NFRGDI)) == 0

  !*     3.8.2  Some diagnostics

  IF (LFCOBSTEST.AND.(GET_NSIM4D()<=4.OR.GET_NSIM4D()==NSIM4DL)) THEN
    WRITE(NULOUT,*)'LFSOBS NORMS AT START CNT4TL'
    CALL SPNORM(YDGEOMETRY,YDMODEL%YRML_GCONF,YDFIELDS%YRSPEC)
    CALL GPNORM_GFL(YDGEOMETRY,YDFIELDS%YRGFL,LDPRINT_TL=.TRUE.)
  ENDIF
  IF(LLSPNRM) THEN
    WRITE(UNIT=NULOUT,FMT='('' NORMS AT NSTEP CNT4TL '',I4)')NSTEP
    CALL SPNORM(YDGEOMETRY,YDMODEL%YRML_GCONF,YDFIELDS%YRSPEC)
  ENDIF
  IF (LLGPNRM.OR.LTLEVOL) THEN
    CALL GPNORM_GFL(YDGEOMETRY,YDFIELDS%YRGFL,LDPRINT_TL=.TRUE.)
  ENDIF

  LLPLPP =IPOSTS(JSTEP/NFRPOS) == 1.AND.MOD(JSTEP,NFRPOS) == 0

  IF(IDHFGTS(JSTEP/NFRDHFG) == 1.AND.MOD(JSTEP,NFRDHFG) == 0) THEN
    LHDOUFG=.TRUE.
  ELSE
    LHDOUFG=.FALSE.
  ENDIF
  IF(IDHFZTS(JSTEP/NFRDHFZ) == 1.AND.MOD(JSTEP,NFRDHFZ) == 0) THEN
    LHDOUFZ=.TRUE.
  ELSE
    LHDOUFZ=.FALSE.
  ENDIF
  IF(IDHFDTS(JSTEP/NFRDHFD) == 1.AND.MOD(JSTEP,NFRDHFD) == 0) THEN
    LHDOUFD=.TRUE.
  ELSE
    LHDOUFD=.FALSE.
  ENDIF

  IF(IDHPTS(JSTEP/NFRDHP) == 1.AND.MOD(JSTEP,NFRDHP) == 0) THEN
    LHDOUP=.TRUE.
  ELSE
    LHDOUP=.FALSE.
  ENDIF

  !*     3.8.6  Add the forcing that was saved during the adjoint integration

  IF (L_EOFS) THEN
    IF (MOD((JSTEP+1),NSTEPS_PER_STATE)==0 .AND. JSTEP+1 < NSTOP) THEN
      I = (JSTEP+1)/NSTEPS_PER_STATE
      ALLOCATE (ZSPA3(SIZE(YDFIELDS%YRSPEC%SP3D,1),SIZE(YDFIELDS%YRSPEC%SP3D,2),SIZE(YDFIELDS%YRSPEC%SP3D,3)))  !! were SPA3
      ZSPA3(:,:,:) = YDFIELDS%YRSPEC%SP3D(:,:,:)
      IF (NPSP==1) THEN
        ALLOCATE (ZSPSP(SIZE(YDFIELDS%YRSPEC%SP)))
        ZSPSP(:)   = YDFIELDS%YRSPEC%SP(:)
      ENDIF
      CALL CAIN(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YSTATE_VECTOR_4D(I),YDVARBC)
      YDFIELDS%YRSPEC%SP3D(:,:,:) = YDFIELDS%YRSPEC%SP3D(:,:,:) + ZSPA3(:,:,:)
      DEALLOCATE (ZSPA3)
      IF (NPSP==1) THEN
        YDFIELDS%YRSPEC%SP(:)   = YDFIELDS%YRSPEC%SP(:)   + ZSPSP(:)
        DEALLOCATE (ZSPSP)
      ENDIF
    ENDIF
  ENDIF

  !*     3.8.7  Manage trajectory

  IF(.NOT.LTRAJGP) THEN
    IF (LTRREF) THEN
      CLCONF(1:1)='B'
    ELSE
      CALL GSTATS(15,0)
      CALL GET_TRAJ_SPEC(YDGEOMETRY,YDMODEL%YRML_GCONF%YRDIMF,TRAJEC(JSTEP),YDFIELDS%YRGMV,YDMTRAJ%YRGMV5,SPA5,JSTEP)
      CALL GSTATS(15,1)
      CLCONF(1:1)='0'
    ENDIF
    IF(LL3DVAR) THEN
      CLCONF(2:2)='K'
    ELSE
      CLCONF(2:2)='E'
    ENDIF
    CLCONF(3:9)='0000000'
    LLSLOT=.FALSE.
    CALL CHKOBTIM(YDGEOMETRY,YDRIP,LLSLOT,IACTIM,YDODB)
    IF(.NOT. LIDMODEL .OR. (LLSLOT .AND. LIDMODEL) ) THEN
    CALL STEPO(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,YDVARBC=YDVARBC)
    ENDIF
  ENDIF

  !*     3.9  Post-processing time step

  IF (GET_NSIM4D() == NSIM4DWR .AND. JSTEP == NSTAR2) THEN
    LLPLPP=.TRUE.
    WRITE(NULOUT,*) 'forcing postprocessing LLPLPP for NSIM4D=', LLPLPP, GET_NSIM4D()
  ENDIF

  IF (LLPLPP .AND. (LTLEVOL .OR. GET_NSIM4D()==NSIM4DL&
   & .OR. GET_NSIM4D()==NSIM4DWR&
   & .OR. (.NOT.LECMWF .AND. IANATS(GET_NSIM4D()/NFRANA) == 1&
   & .AND.MOD(GET_NSIM4D(),NFRANA) == 0) )) THEN
    CLCONF(1:9)='A00000000'
    LLFDBOP=LFDBOP
    LFDBOP=.FALSE.
    IOUTTYPE=NOUTTYPE
    NOUTTYPE=1
    IF(LECMWF)THEN
      LTWINC=.TRUE.
      CALL IOPACK(YDGEOMETRY,YDFIELDS,YDMTRAJ%YRGFL5,YDMODEL,'A',PTRAJEC=TRAJEC(NSTEP),YDACV=YDACV)
      LTWINC=.FALSE.
    ELSE
      LTWANA=.TRUE.
      CALL ADD5TO3(YDGEOMETRY,YDFIELDS,YDGMV5,YDMODEL%YRML_GCONF)
      CALL STEPOTL(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,ZII0,YDACV=YDACV)
      LTWANA=.FALSE.
    ENDIF
    IF (LMODERR.AND.NTYPE_MODERR/=1.AND.JSTEP==0) CALL SAVMODERR(YDGEOMETRY,YDRIP)
    IF(.NOT.LECMWF) CALL SBS5TO3(YDGEOMETRY,YDFIELDS,YDMTRAJ%YRGMV5,YDMODEL%YRML_GCONF)
    LFDBOP=LLFDBOP
    NOUTTYPE=IOUTTYPE
    LTWINC=.FALSE.
  ELSE
    LLPLPP=.FALSE.
  ENDIF

  !*     3.9.5 Comparison to the global analysis
  ! Not managed in the 4DVAR framework
  IF (LELAM) THEN
   IF (LEJK.AND.(JSTEP==0)) CALL EVARJK(YDGEOMETRY,YDMODEL%YRML_GCONF%YRDIMF,YDFIELDS%YRSPEC)
  ENDIF

  !*       3.10  Ordinary time step (predictor if PC scheme).

  IF(L131TL.AND.JSTEP == 0) THEN
    CLCONF(1:1)='I'
  ELSE
    CLCONF(1:1)='0'
  ENDIF

  IF(JSTEP < NSTOP)THEN
    CLCONF(2:4)='AAA'
  ELSE
    CLCONF(2:4)='000'
  ENDIF

  CLCONF(5:6)='00'

  IF(L131TL) THEN
    LLSLOT2=.FALSE.
    CALL CHKOBTIM(YDGEOMETRY,YDRIP,LLSLOT2,IACTIM2,YDODB)
    IF(LLSLOT2) THEN
      IF(LL3DVAR) THEN
        CLCONF(2:3)='GB'
      ELSE
        CLCONF(2:3)='AA'
      ENDIF
      CLCONF(6:6)='V'
    ENDIF
  ENDIF

  NCURRENT_ITER=0
  IF(JSTEP < NSTOP)THEN
    CLCONF(7:8)='AA'
    IF (NSITER == 0) THEN
      CLCONF(9:9)='A'
    ELSEIF (NSITER > 0) THEN
      ! NSITER>0 not coded in the TL code
      CALL ABOR1(' CNT4TL: NSITER>0 not coded in the TL code')
    ELSEIF(NSITER < 0) THEN
      CALL ABOR1('NEGATIVE NSITER NOT ALLOWED')
    ENDIF
  ELSE
    CLCONF(7:9)='000'
  ENDIF

  ! Identity model (I)
  IF (LIDMODEL) THEN
    IF (JSTEP/=0) CLCONF(2:3)='00'
    CLCONF(4:5)='00'
    CLCONF(7:9)='000'
  ENDIF

  IF(CLCONF(1:9)/='000000000') THEN
    CALL STEPOTL(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL,CLCONF,ZII0,YDGOM5,YDGOM,YDACV=YDACV)
  ENDIF

  !*     3.11  Corrector step.

  IF(JSTEP < NSTOP .AND. NSITER > 0) THEN
    ! NSITER>0 not coded in the TL code
    CALL ABOR1(' CNT4TL: NSITER>0 not coded in the TL code')
  ENDIF

  !*     3.12  MODERR

  IF (LMODERR.AND.NTYPE_MODERR==2) CALL ADD_MODERR_TL(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,SPMODERR,GPMODERR,NSTEP)

  !*     3.13  Copy state for use as forcing during the adjoint

  IF (L_SOS) THEN
    IF (MOD((JSTEP+1),NSTEPS_PER_STATE)==0 .AND. JSTEP+1 < NSTOP) THEN
      I = (JSTEP+1)/NSTEPS_PER_STATE
      IF(LOCNORM) THEN
        ALLOCATE (ZSPA3(SIZE(YDFIELDS%YRSPEC%SP3D,1),SIZE(YDFIELDS%YRSPEC%SP3D,2),SIZE(YDFIELDS%YRSPEC%SP3D,3)))  !! were SPA3
        ZSPA3(:,:,:) = YDFIELDS%YRSPEC%SP3D(:,:,:)
        IF (NPSP==1) THEN
          ALLOCATE (ZSPSP(SIZE(YDFIELDS%YRSPEC%SP)))
          ZSPSP(:)   = YDFIELDS%YRSPEC%SP(:)
        ENDIF
        CALL LCNORTL(YDGEOMETRY,YDFIELDS,YDMTRAJ,YDMODEL)
        CALL CAININ(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YSTATE_VECTOR_4D(I),YDVARBC)
        YDFIELDS%YRSPEC%SP3D(:,:,:) = ZSPA3(:,:,:)
        DEALLOCATE (ZSPA3)
        IF (NPSP==1) THEN
          YDFIELDS%YRSPEC%SP(:)   = ZSPSP(:)
          DEALLOCATE (ZSPSP)
        ENDIF
      ELSE
        CALL CAININ(YDGEOMETRY,YDFIELDS,YDMODEL%YRML_GCONF,YSTATE_VECTOR_4D(I),YDVARBC)
      ENDIF
    ENDIF
  ENDIF

  !*     3.15  Signal SMS event for completion of post_processing

  CALL USER_CLOCK(PTOTAL_CP=ZT2)
  CALL DATE_AND_TIME(CLDAT(1),CLTIMEOD,CLDAT(3),IVALUES)
  ZSEC   = REAL(NSTEP,JPRB)*TSTEP +0.5_JPRB
  IHOUR  = INT( ZSEC/3600._JPRB )
  IMIN   = INT( (ZSEC-REAL(IHOUR,JPRB)*3600._JPRB)/60._JPRB )

ENDDO TEMPORAL_LOOP

!      -----------------------------------------------------------------

!*       4.    Miscellaneous.
!              --------------

! Computations in observation space

IF(LOBS .AND. NOBTOTG > 0 .AND. .NOT. LTESTADJM) THEN
  IF(.NOT.(PRESENT(YDVARBC).AND.PRESENT(YDGOM5)))&
   & CALL ABOR1('CN4TL - YDVARBC and YDGOM5 NEEDED')
  CALL USER_CLOCK(PELAPSED_TIME=ZWT,PVECTOR_CP=ZVT,PTOTAL_CP=ZCT)
  ZCT=ZCT-RSTART
  ZVT=ZVT-RVSTART
  ZWT=ZWT-RTIMEF
  RSTART=RSTART+ZCT
  RVSTART=RVSTART+ZVT
  RTIMEF=RTIMEF+ZWT
  WRITE(NULOUT,'('' NSTEP ='',I6,'' OBSVTL  '',A9)')&
   & NSTEP,CLCONF
  IF(NCONF == 131)THEN
    IF(LOBSTL)THEN
      CALL OBSVTL(YDMODEL%YRML_PHY_EC%YREPHY,YDMODEL%YRML_PHY_MF,YDJOT,&
       & YDVARBC,YDTCV5,YDGOM,YDTCV,YDGOM5,YDODB,MTSLOTNO)
    ENDIF
  ELSE
    CALL OBSV(YDMODEL%YRML_PHY_EC%YREPHY,YDMODEL%YRML_PHY_MF,YDJOT,YDVARBC,YDTCV5,YDGOM5,YDODB,MTSLOTNO,'DI')
  ENDIF
ENDIF


CALL GSTATS(22,1)
!     ------------------------------------------------------------------

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('CNT4TL',1,ZHOOK_HANDLE)
END SUBROUTINE CNT4TL
