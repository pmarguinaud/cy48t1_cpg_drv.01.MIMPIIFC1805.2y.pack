SUBROUTINE RERESF_PART2 (YDGEOMETRY,YDFIELDS,YDMODEL)

!**** *RERESF_PART2 *  - read  restart files

!     Purpose.
!     --------
!     Read  a set of restart files if they exist:
!       (1) spectral fields
!       (2) upper-air grid-point fields (t-dt)
!       (3) surface fields
!       (4) upper-air grid-point fields (t)
!       (5) cumulated fluxes
!       (6) instantaneous fluxes
!       (7) restart control file

!**   Interface.
!     ----------
!        *CALL* *RERESF_PART2 

!        Explicit arguments :      None.
!        --------------------

!        Implicit arguments :      None.
!        --------------------

!     Method.
!     -------
!        See documentation

!     Externals.
!     ----------

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!      David Dent *ECMWF*
!      Original : 92-04-06

!     Modifications.
!     --------------
!      Modified : 01-06-13 R. El Khatib (ISP restart)
!      R. El Khatib : 01-08-07 Pruning options
!      Modified : 02-06-10 by D.Dent - Additional file for GP fields
!                          LFASTRES option and improved DDH handling
!      Modified : 08-2002 C. Smith : use "w" as prognostic variable in the
!       semi-lag advection of vertical divergence in the NH model.
!      M.Hamrud      01-Oct-2003 CY28 Cleaning
!      M.Hamrud      10-Jan-2004 CY28R1 Cleaning
!      Modified : 02-07-17 by P. Marquet : add VCLIA for aerosol files
!      Modified : 04-08-12 R. El Khatib Bugfixes + COPY
!      JJMorcrette 20060721 PP clear-sky PAR and TOA incident solar radiation
!      M.Hamrud      01-Jul-2006  Revised surface fields
!      JJMorcrette 20070321 Prognostic aerosols in rad and clouds
!      M.Hamrud      13-Oct-2008 Use IOSTREAM, one file per task, only FASTRES supported
!      JJMorcrette 20091201 Total and clear-sky direct SW radiation flux at surface 
!      M. Steinheimer Oct-2009  improved for stochastic physics options LSTOPH and LSTOPH_SPBS
!      M. Ahlgrimm 31 Oct 2011 Surface downward clear-sky LW and SW fluxes
!      K. Mogensen: 26-Jan-2012 Ocean fields when coupling to LIM2
!      T. Wilhelmsson and K. Yessad (Oct 2013) Geometry and setup refactoring.
!      K. Yessad (July 2014): Move some variables.
!      F. Vana  05-Mar-2015  Support for single precision
!      F. Vana & M. Kharoutdinov 06-Feb-2015: Super-parametrization fields restart.
!      R. El Khatib 07-Mar-2016 Pruning of ISP
!      SJ Lock:    Jan-2016  Removed LSTOPH option
!      O. Marsden  Aug 2016  Removed use of SPA3, replaced by YDFIELDS%YRSPEC
!     ------------------------------------------------------------------

USE TYPE_MODEL         , ONLY : MODEL
USE GEOMETRY_MOD       , ONLY : GEOMETRY
USE FIELDS_MOD         , ONLY : FIELDS
USE SURFACE_FIELDS_MIX , ONLY : GPOPER
USE PARKIND1           , ONLY : JPIM, JPRB
USE YOMHOOK            , ONLY : LHOOK, DR_HOOK
USE YOMLUN             , ONLY : NULOUT, NULERR
USE YOMCT0             , ONLY : LNF, LELAM
USE YOMCT2             , ONLY : NSTAR2
USE YOMSP              , ONLY : SPVOR_FLT, SPDIV_FLT
USE YOMSPSDT           , ONLY : YSPPT_CONFIG, YSPPT
USE YOMIOS             , ONLY : CIOSPRF
USE YOMDYNA            , ONLY : YRDYNA
USE YOMRES             , ONLY : CTIME
USE YOMMP0             , ONLY : MYPROC, NPRTRW, NPRTRV, MYSETV
USE YOMMSC             , ONLY : NINTLEN
USE YOMOPH0            , ONLY : CFNDDH, LINC
USE IOSTREAM_MIX       , ONLY : SETUP_IOSTREAM, SETUP_IOREQUEST, IO_GET,&
 &                              CLOSE_IOSTREAM, TYPE_IOSTREAM , TYPE_IOREQUEST,CLOSE_IOREQUEST
USE RANDOM_NUMBERS_MIX , ONLY : RANDOM_NUMBER_RESTARTFILE
USE SPECTRAL_FIELDS_MOD, ONLY : ASSIGNMENT(=)
USE YOMGPPB            , ONLY : GPARBUF

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY),               INTENT(INOUT) :: YDGEOMETRY
TYPE(FIELDS),                 INTENT(INOUT) :: YDFIELDS
TYPE(MODEL),  TARGET,         INTENT(INOUT) :: YDMODEL
CHARACTER (LEN = 256)  ::  CLFN, CLFS
CHARACTER (LEN = 5)    ::  CLMYPROC
CHARACTER (LEN = 200)  ::  CLSHELL
CHARACTER (LEN = 14)   ::  CLNMFI
CHARACTER (LEN = 4)    ::  CLNAME
CHARACTER (LEN = 6000) ::  CLDATA

REAL(KIND=JPRB), ALLOCATABLE :: ZBUF(:),ZBUF2(:,:),ZBUF3(:,:,:)

REAL(KIND=JPRB) :: ZDATA

INTEGER(KIND=JPIM) :: IB1PAR(18)
INTEGER(KIND=JPIM),ALLOCATABLE :: IPSCOD(:)

INTEGER(KIND=JPIM) :: I, IEND, IPROCA, IPROCB,&
 & IRET, ISDDH, IT, IUNIT, IWSTEP, JLEV, ILEN, J2D,&
 & JSTGLO, IBL, JGFL, ISTEP,II,IINC,IUNITIN,ILENBYT,IDATA,&
 & IBYTE,ILENPS,ILENCH,ILENFP,ILENIN,ILENLG,IRSERV,IBIT,IWORD,JBLK,&
 & ISIZE,JFLD,JROF,IBUF(1),IFLDS,IOFF,IBLSZ1,IBLSZ2,IBLSZ3,IBLSZ
TYPE(TYPE_IOSTREAM) :: YL_IOSTREAM
TYPE(TYPE_IOREQUEST) :: YL_IOREQUEST

INTEGER(KIND=JPIM),PARAMETER :: JPSCOD=500000

LOGICAL :: LLEXIST, LLFSTEP,LLDAT
REAL(KIND=JPRB), ALLOCATABLE :: ZALBICE(:),ZTHKICE(:),ZSNTICE(:),&
  & ZTEMPSEA(:),ZTEMPICE(:),ZFRACICE(:)
REAL(KIND=JPRB) :: ZSPOR(YDGEOMETRY%YRDIM%NSPEC2)
REAL(KIND=JPRB) :: ZHOOK_HANDLE

#ifdef __INTEL_COMPILER                          
INTRINSIC :: SHAPE ! Fails with Intel compiler as it thinks we use ATLAS shape function
#endif        

!     ------------------------------------------------------------------

REAL(KIND=JPRB), POINTER  :: GMASS0, GMASSI 

!     ------------------------------------------------------------------

#include "abor1.intfb.h"
#include "ddhrcv.intfb.h"
#include "gpnorm3.intfb.h"
#include "suorog.intfb.h"
!#include "surand2.intfb.h"

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('RERESF_PART2',0,ZHOOK_HANDLE)
ASSOCIATE(YDGFL=>YDFIELDS%YRGFL,YDGMV=>YDFIELDS%YRGMV, YDSURF=>YDFIELDS%YRSURF, &
 & YDXFU=>YDFIELDS%YRXFU, YDCFU=>YDFIELDS%YRCFU, YDTILEPROP=>YDFIELDS%YEC_PHYS_FIELDS%YRTILEPROP, &
 & YDDIMV=>YDGEOMETRY%YRDIMV, YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP, YDDIM=>YDGEOMETRY%YRDIM, &
 & YDSTOPH=>YDMODEL%YRML_PHY_STOCH%YRSTOPH, &
 & YDRIP=>YDMODEL%YRML_GCONF%YRRIP,YDMCC=>YDMODEL%YRML_AOC%YRMCC,YDTDDH=>YDMODEL%YRML_DIAG%YRTDDH, &
 & YDDPHY=>YDMODEL%YRML_PHY_G%YRDPHY,YDEPHY=>YDMODEL%YRML_PHY_EC%YREPHY, &
 & YDEAERSRC=>YDMODEL%YRML_PHY_AER%YREAERSRC,YGFL=>YDMODEL%YRML_GCONF%YGFL,&
 & YDEWCOU=>YDMODEL%YREWCOU, YDRADF=>YDMODEL%YRML_PHY_RAD%YRRADF,YDLDDH=>YDMODEL%YRML_DIAG%YRLDDH,&
 & YDSLPHY=>YDMODEL%YRML_PHY_G%YRSLPHY)

ASSOCIATE(NDIM=>YGFL%NDIM, NDIM0=>YGFL%NDIM0, NDIM9=>YGFL%NDIM9, &
 & NUMGPFLDS=>YGFL%NUMGPFLDS, YCOMP=>YGFL%YCOMP, &
 & LCUMFU=>YDCFU%LCUMFU, NFDCFU=>YDCFU%NFDCFU, &
 & NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, NSPEC2=>YDDIM%NSPEC2, &
 & NFLEVG=>YDDIMV%NFLEVG, &
 & NTILES=>YDDPHY%NTILES, &
 & HDCS0=>YDTDDH%HDCS0, HDCS1=>YDTDDH%HDCS1, HDCVB0=>YDTDDH%HDCVB0, &
 & HDCVB1=>YDTDDH%HDCVB1, &
 & LEPAERO=>YDEAERSRC%LEPAERO, &
 & LEPHYS=>YDEPHY%LEPHYS, LSLPHY=>YDEPHY%LSLPHY, &
 & CBEGDAT=>YDEWCOU%CBEGDAT, LWCOU=>YDEWCOU%LWCOU, &
 & NGPTOT=>YDGEM%NGPTOT, &
 & GFL=>YDGFL%GFL, GFLSLP=>YDGFL%GFLSLP, &
 & GMV=>YDGMV%GMV, GMVS=>YDGMV%GMVS, YT0=>YDGMV%YT0, YT9=>YDGMV%YT9, &
 & LSDDH=>YDLDDH%LSDDH, &
 & LNEMOCOUP=>YDMCC%LNEMOCOUP, LNEMOLIMGET=>YDMCC%LNEMOLIMGET, &
 & CPLNG_FLD=>YDMCC%CPLNG_FLD, &
 & EDRO=>YDRADF%EDRO, EMTC=>YDRADF%EMTC, EMTD=>YDRADF%EMTD, &
 & SRCDIR=>YDRADF%SRCDIR, SRFDIR=>YDRADF%SRFDIR, SRLWDC=>YDRADF%SRLWDC, &
 & SRSWD=>YDRADF%SRSWD, SRSWDC=>YDRADF%SRSWDC, SRSWDCS=>YDRADF%SRSWDCS, &
 & SRSWPAR=>YDRADF%SRSWPAR, SRSWPARC=>YDRADF%SRSWPARC, &
 & SRSWTINC=>YDRADF%SRSWTINC, SRSWUVB=>YDRADF%SRSWUVB, TAUAER=>YDRADF%TAUAER, &
 & TRSC=>YDRADF%TRSC, TRSW=>YDRADF%TRSW, &
 & NSTOP=>YDRIP%NSTOP, TSTEP=>YDRIP%TSTEP, &
 & SAVTEND=>YDSLPHY%SAVTEND, &
 & GPSTREAM=>YDSTOPH%GPSTREAM, GPTEMP=>YDSTOPH%GPTEMP, &
 & GPTOTDISS=>YDSTOPH%GPTOTDISS, GPTOTDISS_SMOOTH=>YDSTOPH%GPTOTDISS_SMOOTH, &
 & GPVORTGRAD=>YDSTOPH%GPVORTGRAD, &
 & LSTOPH_CASBS=>YDSTOPH%LSTOPH_CASBS, LSTOPH_SPBS=>YDSTOPH%LSTOPH_SPBS, &
 & LSTOPH_SPBS_T=>YDSTOPH%LSTOPH_SPBS_T, LVORTCON=>YDSTOPH%LVORTCON, &
 & SPSTREAM=>YDSTOPH%SPSTREAM, SPSTREAM_FORC=>YDSTOPH%SPSTREAM_FORC, & 
 & SPTEMP=>YDSTOPH%SPTEMP, SPTEMP_FORC=>YDSTOPH%SPTEMP_FORC, &
 & NDIMSURFL=>YDSURF%NDIMSURFL, &
 & RAHFSTI=>YDTILEPROP%RAHFSTI, REVAPTI=>YDTILEPROP%REVAPTI, &
 & RTSKTI=>YDTILEPROP%RTSKTI, RUSTRTI=>YDTILEPROP%RUSTRTI, &
 & RVSTRTI=>YDTILEPROP%RVSTRTI, &
 & LXFU=>YDXFU%LXFU, NFDXFU=>YDXFU%NFDXFU)
! Associate pointers for variables in namelist
GMASS0 => YDMODEL%YRML_DYN%YRDYN%GMASS0
GMASSI => YDMODEL%YRML_DYN%YRDYN%GMASSI

!     ------------------------------------------------------------------

!*       1.    READ  RESTART CONTROL FILE
!              --------------------------

CALL GSTATS(28,0)

IF (.NOT. LNF) THEN

  WRITE(NULOUT,'(A,I5.5)') ' READING RESTART FILES - STEP=',NSTAR2
  IT=INDEX(CTIME,' ')-1

!    ------------------------------------------------------------------

!*       3.    READ  SPECTRAL DATA
!              -------------------

  I = INDEX(CIOSPRF,' ')-1

  WRITE(CLMYPROC,'(A1,I4.4)')'.',MYPROC

  CLFN=CIOSPRF(1:I)//CTIME(1:IT)//CLMYPROC
  CALL SETUP_IOSTREAM(YL_IOSTREAM,'CIO',TRIM(CLFN),CDMODE='r')
  CALL SETUP_IOREQUEST(YL_IOREQUEST,'RAW')
    
  CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
  IF(IBUF(1) /= 88801) THEN
    CALL ABOR1('WRONG CHECK ON READ 1')
  ENDIF
  CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=YDFIELDS%YRSPEC%SP3D)
  CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR2=YDFIELDS%YRSPEC%SP2D)
  IF (LELAM) THEN
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR2=YDFIELDS%YRSPEC%SP1D)
  ENDIF

  IF (YSPPT_CONFIG%LSPSDT) THEN
    DO J2D=1,YSPPT%N2D
      CALL IO_GET(YL_IOSTREAM, YL_IOREQUEST,PR2=YSPPT%YSPSDT_AR1(J2D)%SF%SP2D)
    ENDDO
  ENDIF

  IF (YRDYNA%LGRADSP) THEN
    CALL IO_GET(YL_IOSTREAM, YL_IOREQUEST,PR2=SPVOR_FLT)
    CALL IO_GET(YL_IOSTREAM, YL_IOREQUEST,PR2=SPDIV_FLT)
  ENDIF

!        3.1   COMPUTE OROGRAPHY IN GRID SPACE

  IF (YDGEOMETRY%YRMP%NBSETSP == MYSETV) THEN
    DO II=1,NSPEC2
      ZSPOR(II)=YDFIELDS%YRSPEC%OROG(II)  !! was SPA3
    ENDDO
  ELSE
    ZSPOR = 0._JPRB
  ENDIF

  CALL SUOROG(YDGEOMETRY,ZSPOR)


!     ------------------------------------------------------------------

!*       4.    READ UPPER-AIR AND SURFACE DATA
!              -------------------------------

!*       4.1   READ UPPER-AIR T-DT GRID-POINT DATA

  IF(NSTAR2 > 0) THEN
    LLFSTEP = .FALSE.
  ELSE
    LLFSTEP = .TRUE.
  ENDIF

  IF(.NOT.LLFSTEP) THEN

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88802) THEN
      CALL ABOR1('WRONG CHECK ON READ 2')
    ENDIF
    IBLSZ1=NPROMA*NFLEVG*YT9%NDIM
    IBLSZ2=NPROMA*YT9%NDIMS
    IBLSZ3=NPROMA*NFLEVG*NDIM9
    IBLSZ =IBLSZ1+IBLSZ2+IBLSZ3
    ALLOCATE(ZBUF(NGPBLKS*IBLSZ))
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR1=ZBUF)

    DO JSTGLO=1,NGPTOT,NPROMA
      IBL=(JSTGLO-1)/NPROMA+1
      IEND=MIN(NPROMA,NGPTOT-JSTGLO+1)
      DO JFLD=1,YT9%NDIM
        DO JLEV=1,NFLEVG
          DO JROF=1,IEND
            II=(IBL-1)*IBLSZ&
             & +(JFLD-1)*NPROMA*NFLEVG+(JLEV-1)*NPROMA+JROF
            GMV(JROF,JLEV,YT0%NDIM+JFLD,IBL)= ZBUF(II)
          ENDDO
        ENDDO
      ENDDO
      DO JFLD=1,YT9%NDIMS
        DO JROF=1,IEND
          II=IBLSZ1+(IBL-1)*IBLSZ&
           & +(JFLD-1)*NPROMA+JROF
          GMVS(JROF,YT0%NDIMS+JFLD,IBL)=ZBUF(II)
        ENDDO
      ENDDO
      DO JFLD=1,NDIM9
        DO JLEV=1,NFLEVG
          DO JROF=1,IEND
            II=IBLSZ1+IBLSZ2+(IBL-1)*IBLSZ&
             & +(JFLD-1)*NPROMA*NFLEVG+(JLEV-1)*NPROMA+JROF
            GFL(JROF,JLEV,NDIM0+JFLD,IBL)=ZBUF(II)
          ENDDO
        ENDDO
      ENDDO

    ENDDO
    DEALLOCATE(ZBUF)
  ENDIF

!*       4.2   READ SURFACE GRID-POINT DATA



  CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
  IF(IBUF(1) /= 88803) THEN
    CALL ABOR1('WRONG CHECK ON READ 3')
  ENDIF
  ALLOCATE(ZBUF3(NPROMA,NDIMSURFL,NGPBLKS))
  CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=ZBUF3)
  DO JBLK=1,NGPBLKS
    CALL GPOPER(YDDIM,YDMODEL%YRML_DYN%YRDYN,'PUTALLFLDS',YDSURF,KBL=JBLK,PFIELD=ZBUF3(:,:,JBLK))
  ENDDO
  DEALLOCATE(ZBUF3)
 

!*       4.3   READ UPPER-AIR T GRID-POINT DATA

  IF(NUMGPFLDS > 0) THEN

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88804) THEN
      CALL ABOR1('WRONG CHECK ON READ 4')
    ENDIF
    IF (YDEPHY%LSPCRM) THEN
      ! workaround to reduce memory requirements (being excessive in case of CRM)
      JFLD = YGFL%NUMGPFLDS/15
      IF(JFLD*15 < YGFL%NUMGPFLDS) JFLD=JFLD+1
      DO II = 1, JFLD
        CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR4=GFL(:,:,(II-1)*15+1:MIN(II*15,YGFL%NUMGPFLDS),:))
      ENDDO
    ELSE
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR4=GFL(:,:,1:YGFL%NUMGPFLDS,:))
    ENDIF

    WRITE(NULOUT,'(A)') ' RERESF_PART2 : STATISTICS FOR ALL G.P. GFL FIELDS'
    DO JGFL=1,NUMGPFLDS
      WRITE(NULOUT,'(A)') YCOMP(JGFL)%CNAME
      CALL GPNORM3(YDGEOMETRY,GFL,NDIM,JGFL)
    ENDDO
  ENDIF

!*       4.4   READ CUMULATED AND INSTANTANEOUS FLUXES GRID-POINT DATA

  IF (LCUMFU) THEN
    IF (NFDCFU > 0) THEN
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
      IF(IBUF(1) /= 88805) THEN
        CALL ABOR1('WRONG CHECK ON READ 5')
      ENDIF
      ALLOCATE(ZBUF2(NGPTOT,NFDCFU))
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR2=ZBUF2)
      DO JSTGLO=1,NGPTOT,NPROMA
        IBL=(JSTGLO-1)/YDDIM%NPROMA+1
        IEND=MIN(NPROMA,NGPTOT-JSTGLO+1)
        YDFIELDS%YRCFU%GFUBUF (1:IEND, :, IBL) = ZBUF2 (JSTGLO:JSTGLO+IEND-1, :)
      ENDDO
      DEALLOCATE(ZBUF2)
    ENDIF
  ENDIF


  IF (LXFU) THEN
    IF (NFDXFU > 0) THEN
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
      IF(IBUF(1) /= 88806) THEN
        CALL ABOR1('WRONG CHECK ON READ 6')
      ENDIF
      ALLOCATE(ZBUF2(NGPTOT,NFDXFU))
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR2=ZBUF2)
      DO JSTGLO=1,NGPTOT,NPROMA
        IBL=(JSTGLO-1)/YDDIM%NPROMA+1
        IEND=MIN(NPROMA,NGPTOT-JSTGLO+1)
        YDFIELDS%YRXFU%XFUBUF (1:IEND, :, IBL) = ZBUF2 (JSTGLO:JSTGLO+IEND-1, :)
      ENDDO
      DEALLOCATE(ZBUF2)
    ENDIF
  ENDIF

!*       4.41  READ ADDITIONAL TENDENCIES AND RADIATION FIELD DATA

  IF (LEPHYS) THEN
    IF (LSLPHY) THEN
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
      IF(IBUF(1) /= 88807) THEN
        CALL ABOR1('WRONG CHECK ON READ 7')
      ENDIF
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR4=SAVTEND)
      
      IF(ALLOCATED(YDGFL%GFLSLP)) THEN
        IF(SIZE(GFLSLP) > 0) THEN
          CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR4=GFLSLP)
        ENDIF
      ENDIF
    ENDIF

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88808) THEN
      CALL ABOR1('WRONG CHECK ON READ 8')
    ENDIF
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=EMTD)
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=TRSW)
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=EMTC)
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=TRSC)

    IF (LEPAERO) THEN
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR4=TAUAER)
    ENDIF

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88809) THEN
      CALL ABOR1('WRONG CHECK ON READ 9')
    ENDIF
    IFLDS=11
    ISIZE=NPROMA*NGPBLKS
    ALLOCATE(ZBUF(ISIZE*IFLDS))
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR1=ZBUF)
    IOFF=0
    SRLWDC=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(SRLWDC))
    IOFF=IOFF+ISIZE
    SRSWDCS=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(SRSWDCS))
    IOFF=IOFF+ISIZE
    SRSWDC=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(SRSWDC))
    IOFF=IOFF+ISIZE
    SRSWD=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(SRSWD))
    IOFF=IOFF+ISIZE
    EDRO=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(EDRO))
    IOFF=IOFF+ISIZE
    SRSWPAR=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(SRSWPAR))
    IOFF=IOFF+ISIZE
    SRSWUVB=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(SRSWUVB))
    IOFF=IOFF+ISIZE
    SRSWPARC=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(SRSWPARC))
    IOFF=IOFF+ISIZE
    SRSWTINC=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(SRSWTINC))
    IOFF=IOFF+ISIZE
    SRFDIR  =RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(SRFDIR))
    IOFF=IOFF+ISIZE
    SRCDIR  =RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(SRCDIR))
    DEALLOCATE(ZBUF)

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88810) THEN
      CALL ABOR1('WRONG CHECK ON READ 10')
    ENDIF
    IFLDS=5
    ISIZE=NPROMA*NGPBLKS*NTILES
    ALLOCATE(ZBUF(ISIZE*IFLDS))
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR1=ZBUF)
    IOFF=0
    RUSTRTI=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(RUSTRTI))
    IOFF=IOFF+ISIZE
    RVSTRTI=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(RVSTRTI))
    IOFF=IOFF+ISIZE
    RAHFSTI=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(RAHFSTI))
    IOFF=IOFF+ISIZE
    REVAPTI=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(REVAPTI))
    IOFF=IOFF+ISIZE
    RTSKTI=RESHAPE(ZBUF(IOFF+1:IOFF+ISIZE),SHAPE(RTSKTI))
    IOFF=IOFF+ISIZE
    DEALLOCATE(ZBUF)

  ELSE

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88808) THEN
      CALL ABOR1('WRONG CHECK ON READ 8')
    ENDIF

    IF (YDMODEL%YRML_PHY_MF%YRPHY%LMPHYS .AND. &
     & (YDMODEL%YRML_PHY_MF%YRPHY%LRAYFM .OR.  &
     &  YDMODEL%YRML_PHY_MF%YRPHY%LRAYFM15)) THEN
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=YDRADF%EMTD) 
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=YDRADF%TRSW)
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=YDRADF%EMTU)
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR2=YDRADF%RMOON)
    ENDIF
    IF (YDMODEL%YRML_PHY_MF%YRPARAR%NGPAR > 0) THEN
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=GPARBUF)
    ENDIF

  ENDIF

!*       4.5  READ  DDH RESTART DATA

  IF (LSDDH ) THEN 

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88811) THEN
      CALL ABOR1('WRONG CHECK ON READ 11')
    ENDIF
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IPROCA=IBUF(1)
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IPROCB=IBUF(1)
    
    ISDDH=1
    IF( IPROCA /= NPRTRW .OR. IPROCB /= NPRTRV )THEN
      WRITE(NULOUT,'("RERESF_PART2: NPRTRW/NPRTRV DIFFERENT ON ",&
       & "DDH RESTART FILE, DDH TURNED OFF")')  
      WRITE(NULERR,'("RERESF_PART2: NPRTRW/NPRTRV DIFFERENT ON ",&
       & "DDH RESTART FILE, DDH TURNED OFF")')  
      LSDDH=.FALSE.
      ISDDH=0
    ENDIF

    CALL DDHRCV(HDCVB0,SIZE(HDCVB0),YL_IOSTREAM,YL_IOREQUEST)
    CALL DDHRCV(HDCVB1,SIZE(HDCVB1),YL_IOSTREAM,YL_IOREQUEST)
    CALL DDHRCV(HDCS0 ,SIZE(HDCS0 ),YL_IOSTREAM,YL_IOREQUEST)
    CALL DDHRCV(HDCS1 ,SIZE(HDCS1 ),YL_IOSTREAM,YL_IOREQUEST)
    
  ENDIF

!*       4.51 READ DDH DATA FILE and POSITION CORRECTLY AT RESTART TIMESTEP

  IF ( LINC ) THEN
    IINC = NINT( REAL(NSTAR2,JPRB)*TSTEP/3600._JPRB )
  ELSE
    IINC = NSTAR2
  ENDIF
  WRITE (CLNMFI,'(A9,I4.4)') CFNDDH(1:9),IINC
  CLNMFI(4:5)='DL'
  IF(MYPROC == 1) INQUIRE(FILE=CLNMFI(1:9),EXIST=LLEXIST)
  IF (LLEXIST.AND.MYPROC == 1) THEN
!     Rename the DDH data file
    WRITE(CLSHELL,'(''mv '',A,'' '',A)') CLNMFI(1:9),CLNMFI
    CALL SYSTEM(CLSHELL) 
    CALL PBOPEN(IUNITIN,CLNMFI,'r',IRET)
    IF (IRET /= 0) THEN
      WRITE(*,*) ' PROBLEMS OPENING THE DDH DATA FILE',CLNMFI
      WRITE(*,*) ' IRET= ',IRET
      CALL ABOR1('PROBLEMS OPENING THE DDH DATA FILE')
    ENDIF 
    CALL PBOPEN(IUNIT,CLNMFI(1:9),'w',IRET)
    IF (IRET /= 0) THEN
      WRITE(*,*) ' PROBLEMS OPENING THE DDH NEW DATA FILE',CLNMFI(1:9)
      WRITE(*,*) ' IRET= ',IRET
      CALL ABOR1('PROBLEMS OPENING THE DDH NEW DATA FILE')
    ENDIF 
    ALLOCATE(IPSCOD(JPSCOD))
    READ_LOOP:DO
      IRET=0
      CALL PBPSEU(IUNITIN,IPSCOD,NINTLEN*JPSCOD,ILENBYT,IRET)
      IF (IRET == -1) THEN
        EXIT READ_LOOP
      ELSEIF(IRET <= -1) THEN
        WRITE(*,*) ' PROBLEMS READING THE DDH DATA FILE',CLNMFI
        WRITE(*,*) ' IRET= ',IRET
        CALL ABOR1('PROBLEMS READING THE DDH DATA FILE')
      ELSE
        ILENPS=JPSCOD
        IBIT=32
        CALL DECOPS2(CLNAME,CLDATA,1,ZDATA,1,IDATA,1,&
         & IBYTE,LLDAT,1,IB1PAR,IPSCOD,ILENPS,&
         & ILENCH,ILENFP,ILENIN,ILENLG,IRSERV,IBIT,IWORD,IRET)  
        IF(IRET /= 0) THEN
          WRITE (NULOUT,*) ' ERROR IN DECOPS - IERR= ',IRET
          CALL ABOR1('ERROR IN DECOPS FOR DDH DATA FILE')
        ENDIF
        ISTEP=IB1PAR(15)
      ENDIF
      IF (ISTEP < NSTAR2 ) THEN
        CALL PBWRITE(IUNIT,IPSCOD,ILENBYT,IRET)
        IF(IRET < 0) THEN
          WRITE(NULOUT,*)'RERESF_PART2: ERROR IN PBWRITE FOR DDH- IERR= ',IRET
          CALL ABOR1('RERESF_PART2: ERROR IN PBWRITE FOR DDH')
        ENDIF
      ENDIF
    ENDDO READ_LOOP
    DEALLOCATE(IPSCOD)

    CALL PBCLOSE(IUNITIN,IRET)
    CALL PBCLOSE(IUNIT,IRET)

  ENDIF

!*       4.6 READ NEMO DATA NEEDED FOR COUPLING TO LIM.

  IF (LNEMOCOUP.AND.LNEMOLIMGET) THEN

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88812) THEN
      CALL ABOR1('WRONG CHECK ON READ 12')
    ENDIF
    ! General code working also in single precision 
    ILEN = SIZE(TRANSFER(CPLNG_FLD(YDMCC%IP_A_ICE_ALBEDO)%D(:,1,1),ZALBICE(:)))
    IF (ILEN /= NGPTOT) CALL ABOR1('Something wrong with the restart fields')
    ALLOCATE(ZALBICE(ILEN))
    ALLOCATE(ZTHKICE(ILEN))
    ALLOCATE(ZSNTICE(ILEN))
    ALLOCATE(ZTEMPSEA(ILEN))
    ALLOCATE(ZTEMPICE(ILEN))
    ALLOCATE(ZFRACICE(ILEN))
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR1=ZALBICE)
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR1=ZTHKICE)
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR1=ZSNTICE)
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR1=ZTEMPSEA)
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR1=ZTEMPICE)
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR1=ZFRACICE)
    CPLNG_FLD(YDMCC%IP_A_ICE_ALBEDO)%D(:,1,1) = &
       & TRANSFER(ZALBICE(:),CPLNG_FLD(YDMCC%IP_A_ICE_ALBEDO)%D(:,1,1))
    CPLNG_FLD(YDMCC%IP_A_ICE_THICKNESS)%D(:,1,1) = & 
       & TRANSFER(ZTHKICE(:),CPLNG_FLD(YDMCC%IP_A_ICE_THICKNESS)%D(:,1,1))
    CPLNG_FLD(YDMCC%IP_A_SNOW_THICKNESS)%D(:,1,1) = &
       & TRANSFER(ZSNTICE(:),CPLNG_FLD(YDMCC%IP_A_SNOW_THICKNESS)%D(:,1,1))
    CPLNG_FLD(YDMCC%IP_A_SST)%D(:,1,1) = & 
       & TRANSFER(ZTEMPSEA(:),CPLNG_FLD(YDMCC%IP_A_SST)%D(:,1,1))
    CPLNG_FLD(YDMCC%IP_A_ICE_TEMP)%D(:,1,1) = &
       & TRANSFER(ZTEMPICE(:),CPLNG_FLD(YDMCC%IP_A_ICE_TEMP)%D(:,1,1))
    CPLNG_FLD(YDMCC%IP_A_ICE_FRAC)%D(:,1,1) = & 
       & TRANSFER(ZFRACICE(:),CPLNG_FLD(YDMCC%IP_A_ICE_FRAC)%D(:,1,1))
    DEALLOCATE(ZALBICE,ZTHKICE,ZSNTICE,ZTEMPSEA,ZTEMPICE,ZFRACICE)

  ENDIF

  CALL CLOSE_IOREQUEST(YL_IOREQUEST)
  CALL CLOSE_IOSTREAM(YL_IOSTREAM)


!*       4.9 READ SPBS DATA
  IF (LSTOPH_SPBS) THEN
    CLFS='../stoph_spbs' // CTIME(1:IT) //CLMYPROC
    WRITE(UNIT=NULOUT,FMT='('' READING RESTART FILE FOR SPBS'',A)') CLFS
    CALL SETUP_IOSTREAM(YL_IOSTREAM,'CIO',TRIM(CLFS),CDMODE='r')
    CALL SETUP_IOREQUEST(YL_IOREQUEST,'RAW')

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88801) THEN
       CALL ABOR1('WRONG CHECK ON SPBS READ 1')
    ENDIF
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR2=SPSTREAM)

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88802) THEN
       CALL ABOR1('WRONG CHECK ON SPBS READ 2')
    ENDIF
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR2=SPSTREAM_FORC)

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88803) THEN
       CALL ABOR1('WRONG CHECK ON SPBS READ 3')
    ENDIF
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=GPSTREAM)

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88804) THEN
       CALL ABOR1('WRONG CHECK ON SPBS READ 4')
    ENDIF
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=GPTOTDISS)

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88805) THEN
       CALL ABOR1('WRONG CHECK ON SPBS READ 5')
    ENDIF
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=GPTOTDISS_SMOOTH)

    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
    IF(IBUF(1) /= 88806) THEN
       CALL ABOR1('WRONG CHECK ON SPBS READ 6')
    ENDIF
    CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=GPVORTGRAD)

    IF (LSTOPH_SPBS_T) THEN
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
      IF(IBUF(1) /= 88807) THEN
        CALL ABOR1('WRONG CHECK ON SPBS READ 7')
      ENDIF
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR2=SPTEMP)

      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
      IF(IBUF(1) /= 88808) THEN
        CALL ABOR1('WRONG CHECK ON SPBS READ 8')
      ENDIF
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR2=SPTEMP_FORC)

      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,KR1=IBUF)
      IF(IBUF(1) /= 88809) THEN
        CALL ABOR1('WRONG CHECK ON SPBS READ 9')
      ENDIF
      CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR3=GPTEMP)
    ENDIF
    CALL CLOSE_IOREQUEST(YL_IOREQUEST)
    CALL CLOSE_IOSTREAM(YL_IOSTREAM)
    !read state of the random number generator
    CLFS='../stoph_spbs_rand_nbrs' // CTIME(1:IT) //CLMYPROC
    WRITE(UNIT=NULOUT,FMT='('' READ RANDOM NUMBER STATE FOR SPBS'',A)') CLFS
    CALL RANDOM_NUMBER_RESTARTFILE( CLFS, 'r',YDMODEL%YRML_PHY_STOCH%YR_RANDOM_STREAMS%STOCHPHYS_SPBS)
    CLFS='../stoph_rvp_rand_nbrs' // CTIME(1:IT) //CLMYPROC
    WRITE(UNIT=NULOUT,FMT='('' READ RANDOM NUMBER STATE FOR RVP'',A)') CLFS
    CALL RANDOM_NUMBER_RESTARTFILE( CLFS, 'r',YDMODEL%YRML_PHY_STOCH%YR_RANDOM_STREAMS%STOCHPHYS_RVP)
    IF (LSTOPH_SPBS_T) THEN
      CLFS='../stoph_spbs_T_rand_nbrs' // CTIME(1:IT) //CLMYPROC
      WRITE(UNIT=NULOUT,FMT='('' READ RANDOM NUMBER STATE FOR SPBS_T'',A)') CLFS
      CALL RANDOM_NUMBER_RESTARTFILE( CLFS, 'r',YDMODEL%YRML_PHY_STOCH%YR_RANDOM_STREAMS%STOPH_SPBS_T)
      CLFS='../stoph_rvp_T_rand_nbrs' // CTIME(1:IT) //CLMYPROC
      WRITE(UNIT=NULOUT,FMT='('' READ RANDOM NUMBER STATE FOR RVP_T'',A)') CLFS
      CALL RANDOM_NUMBER_RESTARTFILE( CLFS, 'r',YDMODEL%YRML_PHY_STOCH%YR_RANDOM_STREAMS%STOPH_RVP_T)
    ENDIF
  ENDIF


!     ------------------------------------------------------------------

!*       5.    IF COUPLED WITH WAM CORRECT BEGINNDATE.
!              ---------------------------------------

  IF (LWCOU) THEN
    IWSTEP=NSTAR2-1
#ifdef WITH_WAVE
    CALL INCDATE(CBEGDAT, (IWSTEP)*NINT(TSTEP))
#else
    CALL ABOR1('RERESF_PART2: INCDATE should never be called')    
#endif
  ENDIF

ENDIF

CALL GSTATS(28,1)
!     ------------------------------------------------------------------

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('RERESF_PART2',1,ZHOOK_HANDLE)
END SUBROUTINE RERESF_PART2

