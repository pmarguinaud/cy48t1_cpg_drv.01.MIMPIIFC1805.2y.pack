SUBROUTINE PRESET_GRIB_TEMPLATE(YDGEOMETRY,YDVAB,LDMCC04,CDTYPE,YDGBH,YDFPUSERGEO)

! No heading title ??
!      R. El Khatib : 01-Mar-2012 LFPOS => NFPOS + NFPRESOL
!      K. Yessad (July 2014): Move some variables.
!      R. El Khatib : 23-Aug-2016 Interoperability
! ------------------------------------------------------------------

USE GEOMETRY_MOD      , ONLY : GEOMETRY
USE PARKIND1          , ONLY : JPIM, JPRB, JPRD
USE YOMHOOK           , ONLY : LHOOK, DR_HOOK
USE PARDIM            , ONLY : JPMXLE, JPMXGL
USE GRIB_API_INTERFACE, ONLY : IGRIB_CLONE, IGRIB_SET_VALUE
USE YOMCT0            , ONLY : CNMEXP,&
 &                             LOBSC1, NSTEPINI, NCONF
USE YOMLUN            , ONLY : NULOUT
USE YOMGRIB           , ONLY : NLOCGRB, NTOTENS, NENSFNB, NWINOFF, NJDIAG, NJDOMAI, NJITER, NSTREAM,&
 &                             NSYSTEM, NMETHOD, NREFERENCE, NCONSENSUS, NDWD, NMFR, NNCEP, NUKM, NLEG,&
 &                             CTYPE, CFCLASS, NCYCLE
USE TYPE_FPUSERGEO    , ONLY : TFPUSERGEO
USE YOMRIP0           , ONLY : NINDAT, NSSSSS
USE YOMVAREPS         , ONLY : NFCHO_TRUNC_INI, LVAREPS
USE GRIB_HANDLES_MOD  , ONLY : TYPE_GRIB_HANDLES,YGRIB_SAMPLES
USE YOMVERT           , ONLY : TVAB

! ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)  ,INTENT(IN)    :: YDGEOMETRY
TYPE(TVAB)      ,INTENT(IN)    :: YDVAB
LOGICAL         ,INTENT(IN)    :: LDMCC04
CHARACTER(LEN=*),INTENT(IN)    :: CDTYPE
TYPE(TYPE_GRIB_HANDLES),INTENT(INOUT) :: YDGBH
TYPE (TFPUSERGEO),  INTENT(IN), OPTIONAL :: YDFPUSERGEO

! ------------------------------------------------------------------

INTEGER(KIND=JPIM) :: IGRIB_HANDLE, ISMAX, ILATS, ILONS, IFLEV, IDGNH
INTEGER(KIND=JPIM) :: IDD, IMM, IYYYY, IHOUR, IHOUR1, ID1, IM1, IYYYY1, ILMO(12)
INTEGER(KIND=JPIM) :: IINDAT, ISSSSS, ITIME, IHDAY
INTEGER(KIND=JPIM) :: ILOENG(JPMXGL)
INTEGER(KIND=JPIM) :: ICENTRE, IMIMI, IHHMM, IFCHO_RES, IFCDA_INI
INTEGER(KIND=JPIM), PARAMETER :: JPSHOUR=3600_JPIM

REAL(KIND=JPRD) :: ZNLAT, ZSLAT
REAL(KIND=JPRB) :: ZVERT(2*(JPMXLE+1))
REAL(KIND=JPRD) :: ZVAL
REAL(KIND=JPRB) :: ZHOOK_HANDLE

CHARACTER(LEN=96) :: CLWORD

! ------------------------------------------------------------------

#include "abor1.intfb.h"
#include "updcal.intfb.h"

#include "fcttim.func.h"

! ------------------------------------------------------------------
IF (LHOOK) CALL DR_HOOK('PRESET_GRIB_TEMPLATE',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDGEM=>YDGEOMETRY%YRGEM, YDCSGLEG=>YDGEOMETRY%YRCSGLEG)
ASSOCIATE(NDGLG=>YDDIM%NDGLG, NDLON=>YDDIM%NDLON, NSMAX=>YDDIM%NSMAX,   NHTYP=>YDGEM%NHTYP, NLOENG=>YDGEM%NLOENG, &
& NSTTYP=>YDGEM%NSTTYP,   RLOCEN=>YDGEM%RLOCEN, RMUCEN=>YDGEM%RMUCEN, RSTRET=>YDGEM%RSTRET)
! ------------------------------------------------------------------

SELECT CASE(CDTYPE)
CASE('GG')
IF( NSMAX >= 7999 ) THEN
  CALL IGRIB_CLONE(YGRIB_SAMPLES%NGRIB_HANDLE_GG,YDGBH%NGRIB_HANDLE_GG2)
  IGRIB_HANDLE = YDGBH%NGRIB_HANDLE_GG2
ELSE
  CALL IGRIB_CLONE(YGRIB_SAMPLES%NGRIB_HANDLE_GG,YDGBH%NGRIB_HANDLE_GG)
  IGRIB_HANDLE = YDGBH%NGRIB_HANDLE_GG
ENDIF
CASE('GG2')
CALL IGRIB_CLONE(YGRIB_SAMPLES%NGRIB_HANDLE_GG2,YDGBH%NGRIB_HANDLE_GG2)
IGRIB_HANDLE = YDGBH%NGRIB_HANDLE_GG2
CASE('GG_ML')
CALL IGRIB_CLONE(YGRIB_SAMPLES%NGRIB_HANDLE_GG_ML,YDGBH%NGRIB_HANDLE_GG_ML)
IGRIB_HANDLE = YDGBH%NGRIB_HANDLE_GG_ML
CASE('SH_ML')
CALL IGRIB_CLONE(YGRIB_SAMPLES%NGRIB_HANDLE_SH_ML,YDGBH%NGRIB_HANDLE_SH_ML)
IGRIB_HANDLE = YDGBH%NGRIB_HANDLE_SH_ML
CASE('SH')
CALL IGRIB_CLONE(YGRIB_SAMPLES%NGRIB_HANDLE_SH,YDGBH%NGRIB_HANDLE_SH)
IGRIB_HANDLE = YDGBH%NGRIB_HANDLE_SH
CASE DEFAULT
  CALL ABOR1('PRESET_GRIB_TEMPLATE - UNKNOWN TYPE')
END SELECT


IF(PRESENT(YDFPUSERGEO)) THEN
! "overwrite" templates with fullpos variables.
! It supposes that pp data and historical data will not be written out in the
! same configuration, unless they are both of the same geometry.
! I would rather recommend to move this subroutine to the I/Os. REK.
  ILATS = YDFPUSERGEO%NLAT
  ILONS = YDFPUSERGEO%NLON
  ZNLAT = ASIN(YDFPUSERGEO%FPMU(1))
  ZSLAT = ASIN(YDFPUSERGEO%FPMU(ILATS))
  ILOENG(1:ILATS) = YDFPUSERGEO%NFPRGRI(1:ILATS)
  ISMAX = YDFPUSERGEO%NFPMAX
ELSE
  ILATS = NDGLG
  ILONS = NDLON
  ZNLAT = REAL(YDCSGLEG%RLATIG(1),JPRD)
  ZSLAT = REAL(YDCSGLEG%RLATIG(NDGLG),JPRD)
  ILOENG(1:ILATS) = NLOENG(1:ILATS)
  ISMAX = NSMAX
ENDIF
IFLEV = UBOUND(YDVAB%VBH,DIM=1)
ZVERT(1:IFLEV+1) = YDVAB%VAH(0:IFLEV)
ZVERT(IFLEV+2:2*(IFLEV+1)) = YDVAB%VBH(0:IFLEV)
IDGNH =(ILATS+1)/2

CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'generatingProcessIdentifier',NCYCLE)
IHDAY=24
IF(CTYPE == 'fc'.AND.LOBSC1) THEN
  IDD    = NDD(NINDAT)
  IMM    = NMM(NINDAT)
  IYYYY  = NCCAA(NINDAT)
  IHOUR  = NSSSSS/JPSHOUR
  IHOUR1 = IHOUR-NSTEPINI
  IF(IHOUR1 < 0) THEN
    IHOUR1=IHOUR1+IHDAY
    CALL UPDCAL(IDD,IMM,IYYYY,-1,ID1,IM1,IYYYY1,ILMO,NULOUT)
  ELSE
    IYYYY1=IYYYY
    IM1=IMM
    ID1=IDD
  ENDIF
  WRITE(NULOUT,FMT='(''PRESET_GRIB_TEMPLATE DATE: '',I6,2I3)') IYYYY1,IM1,ID1
  WRITE(NULOUT,FMT='(''PRESET_GRIB_TEMPLATE HOUR: '',I3)') IHOUR1
  IINDAT=IYYYY1*10000+IM1*100+ID1
  ISSSSS=IHOUR1*JPSHOUR
ELSE
  IINDAT=NINDAT
  ISSSSS=NSSSSS
ENDIF
!*       1.0.2  CHANGE GRIB HEADERS TO WRITE FC IF VAREPS

IF(LVAREPS.AND.(NLEG >= 2)) THEN

! Change initial date/time

  IDD    = NDD(NINDAT)
  IMM    = NMM(NINDAT)
  IYYYY  = NCCAA(NINDAT)
  IHOUR  = NSSSSS/JPSHOUR

  IFCDA_INI=NFCHO_TRUNC_INI/IHDAY
  IFCHO_RES=NFCHO_TRUNC_INI-IFCDA_INI*IHDAY

  IHOUR1=IHOUR-IFCHO_RES
  IF (IHOUR1<0) THEN
    IHOUR1=IHOUR1+24
    IFCDA_INI=IFCDA_INI+1
  ENDIF
  CALL UPDCAL(IDD,IMM,IYYYY,-IFCDA_INI,ID1,IM1,IYYYY1,ILMO,NULOUT)
  WRITE(NULOUT,FMT='(''PRESET_GRIB_TEMPLATE: after subtracting NFCHO_TRUNC_INI'')')
  WRITE(NULOUT,FMT='(''PRESET_GRIB_TEMPLATE DATE:'',I6,2I3)') IYYYY1,IM1,ID1
  WRITE(NULOUT,FMT='(''PRESET_GRIB_TEMPLATE HOUR:'',I3)') IHOUR1
  IINDAT=IYYYY1*10000+IM1*100+ID1
  ISSSSS=IHOUR1*JPSHOUR
ELSE
  IINDAT=NINDAT
  ISSSSS=NSSSSS
ENDIF

! Date and time
ITIME=100*NCTH(ISSSSS)+0


! Keep the order, local def, stream, type and class in this order before rest
! May be imoprtant for GRIB_API internals
CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'localDefinitionNumber',NLOCGRB)
CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'stream',NSTREAM)
CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'type',CTYPE)
CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'class',CFCLASS)
!
CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'dataDate',IINDAT)
CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'time',ITIME)
CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'experimentVersionNumber',CNMEXP(1:4))

IF(CTYPE == 'cf' .OR. CTYPE == 'pf' .OR. CTYPE == 'cv'&
                 & .OR. NSTREAM == 1030 .OR. NSTREAM == 1249) THEN
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'eps',1)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'perturbationNumber',NENSFNB)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'numberOfForecastsInEnsemble',NTOTENS)
ELSE
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'eps',0)
ENDIF
IF (NLOCGRB == 7) THEN
  ! Sensitivity data
  IF (IABS(NCONF)/100 == 8) THEN
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'type','sg')
  ELSE
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'type','sf')
  ENDIF
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'iterationNumber',NJITER) 
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'sensitiveAreaDomain',NJDOMAI)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'diagnosticNumber',NJDIAG)
ELSEIF (NLOCGRB == 9) THEN
  ! Singular vectors and ensemble perturbations
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'type','sv')
  !NB The rest set in SULCZ or NALAN1
ELSEIF (NLOCGRB == 15) THEN
  ! Seasonal forecast data
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'eps',1) 
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'perturbationNumber',NENSFNB)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'numberOfForecastsInEnsemble',NTOTENS)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'systemNumber',NSYSTEM)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'methodNumber',NMETHOD)
ELSEIF (NLOCGRB == 23) THEN
  ! Coupled atmospheric, wave and ocean means (with hindcast support)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'systemNumber',NSYSTEM)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'methodNumber',NMETHOD)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'referenceDate',NREFERENCE)
ELSEIF (NLOCGRB == 26) THEN
  ! MARS labelling or ensemble forecast data (with hindcast support)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'referenceDate',NREFERENCE)
ELSEIF ( NLOCGRB == 27 .OR. NLOCGRB == 30 ) THEN 
  ! Date and time of current leg for VAREPS
  IDD    = NDD(NINDAT)
  IMM    = NMM(NINDAT)
  IYYYY  = NCCAA(NINDAT)
  IHOUR  = NSSSSS/JPSHOUR
  IMIMI  = (NSSSSS-(IHOUR*JPSHOUR))/60
  IINDAT = IYYYY*10000+IMM*100+IDD
  IHHMM = IHOUR*100+IMIMI
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'legBaseDate',IINDAT)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'legBaseTime',IHHMM)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'legNumber',NLEG)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'referenceDate',NREFERENCE)
  IF (LDMCC04) CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'oceanAtmosphereCoupling',2)  
ELSEIF (NLOCGRB == 36) THEN
  !long window
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'anoffset',NWINOFF)  
ELSEIF (NLOCGRB == 18) THEN
  ! Multi-analysis ensemble data
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'modelIdentifier','ECMF')
  IF(NCONSENSUS == 0) THEN
    !   Data from one centre
    IF(NDWD == 1) THEN
      CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'dataOrigin',78)
    ELSEIF(NMFR == 1) THEN
      CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'dataOrigin',85)
    ELSEIF(NNCEP == 1) THEN
      CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'dataOrigin',7)
    ELSEIF(NUKM == 1) THEN
      CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'dataOrigin',74)
    ENDIF
  ELSE
    ! Consensus analysis (always includes EC)
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'dataOrigin',255)
    ICENTRE=1
    CLWORD='ECMF'
    IF(NDWD == 1) THEN
      ICENTRE=ICENTRE+1
      CLWORD=CLWORD//'EDZW'
    ENDIF
    IF(NMFR == 1) THEN
      ICENTRE=ICENTRE+1
      CLWORD=CLWORD//'LFPW'
    ENDIF
    IF(NNCEP == 1) THEN
      ICENTRE=ICENTRE+1
      CLWORD=CLWORD//'KWBC'
    ENDIF
    IF(NUKM == 1) THEN
      ICENTRE=ICENTRE+1
      CLWORD=CLWORD//'EGRR'
    ENDIF
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'consensusCount',ICENTRE)
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'ccccIdentifiers',CLWORD(1:4*ICENTRE))
  ENDIF
ENDIF
!Geography
IF(CDTYPE == 'GG' .OR. CDTYPE == 'GG2' .OR. CDTYPE == 'GG_ML') THEN
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'truncateDegrees',1)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'numberOfPointsAlongAMeridian',ILATS)
  ZVAL = 180._JPRD/(2.0_JPRD*ASIN(1.0_JPRD))*ZNLAT
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'latitudeOfFirstGridPointInDegrees',ZVAL)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'longitudeOfFirstGridPointInDegrees',0)
  ZVAL = 180._JPRD/(2.0_JPRD*ASIN(1.0_JPRD))*ZSLAT
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'latitudeOfLastGridPointInDegrees',ZVAL)
  ZVAL=360._JPRD-360._JPRD/REAL(ILONS,JPRD)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'longitudeOfLastGridPointInDegrees',ZVAL)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'numberOfParallelsBetweenAPoleAndTheEquator',IDGNH)
  IF(NHTYP > 0) THEN
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'gridType','reduced_gg')
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'pl',ILOENG(1:ILATS))
  ELSE
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'gridType','regular_gg')
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'numberOfPointsAlongAParallel',NDLON)
    ZVAL = 360.0_JPRD/REAL(NDLON,JPRD)
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'iDirectionIncrementInDegrees',ZVAL)
  ENDIF
ENDIF
IF(CDTYPE == 'SH' .OR. CDTYPE == 'SH_ML') THEN
  IF(NSTTYP >= 2) THEN
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'gridType','stretched_rotated_sh')
    ZVAL = 180._JPRD/(2.0_JPRD*ASIN(1.0_JPRD))*ASIN(REAL(RMUCEN,JPRD))
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'latitudeOfStretchingPoleInDegrees',&
      & ZVAL)
    ZVAL = 180._JPRD/(2.0_JPRD*ASIN(1.0_JPRD))*REAL(RLOCEN,JPRD)
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'longitudeOfStretchingPoleInDegrees',&
      & ZVAL)
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'stretchingFactor',RSTRET)
  ELSEIF(ABS(RSTRET-1.0_JPRB) >= 1.E-14_JPRB) THEN
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'gridType','stretched_sh')
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'stretchingFactor',RSTRET)
  ELSE
    CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'gridType','sh')
  ENDIF
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'pentagonalResolutionParameterJ',ISMAX)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'pentagonalResolutionParameterK',ISMAX)
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'pentagonalResolutionParameterM',ISMAX)
ENDIF
IF(CDTYPE == 'SH_ML' .OR. CDTYPE == 'GG_ML') THEN
  !  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'nvNumberOfVerticalCoordinateParameters', &
  !                     & 2*(IFLEV+1))
  CALL IGRIB_SET_VALUE(IGRIB_HANDLE,'pv',ZVERT(1:2*(IFLEV+1)))
ENDIF

! ------------------------------------------------------------------
END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('PRESET_GRIB_TEMPLATE',1,ZHOOK_HANDLE)
END SUBROUTINE PRESET_GRIB_TEMPLATE
