MODULE ECPHYS_STATE_TYPE_MOD

USE PARKIND1, ONLY: JPIM, JPRB
USE GEOMETRY_MOD, ONLY: GEOMETRY
USE FIELD_MODULE, ONLY: FIELD_3D, FIELD_4D
USE FIELD_REGISTRY_MOD, ONLY: CREATE_TEMPORARY, DELETE_TEMPORARY
USE YOECLDP, ONLY : NCLV, NCLDQR, NCLDQS, NCLV, NCLDQI, NCLDQL

IMPLICIT NONE

TYPE STATE_FIELD_MASK
  LOGICAL :: U, V, T, O3, Q, A, TKE
END TYPE STATE_FIELD_MASK

TYPE MASK_GFL_TYPE
  LOGICAL :: O3, Q, A, QL, QI, QR, QS, TKE
CONTAINS
  PROCEDURE :: INIT => MASK_GFL_TYPE_INIT
END TYPE MASK_GFL_TYPE

TYPE STATE_TYPE
  TYPE(MASK_GFL_TYPE) :: KEYMASK

  REAL(KIND=JPRB), DIMENSION(:,:),   POINTER, CONTIGUOUS :: U,V,T      ! GMV fields
  REAL(KIND=JPRB), DIMENSION(:,:),   POINTER, CONTIGUOUS :: O3,Q,A,TKE ! GFL fields
  REAL(KIND=JPRB), DIMENSION(:,:),   POINTER, CONTIGUOUS :: QL,QI,QR,QS! Cloud component views
  REAL(KIND=JPRB), DIMENSION(:,:,:), POINTER, CONTIGUOUS :: CLD        ! composed cloud array
  !REAL(KIND=JPRB), dimension(:,:), pointer :: qsat    ! spec. humidity at saturation

  ! Storage fields to provide thread-local views
  TYPE(FIELD_3D), POINTER :: F_U, F_V, F_T, F_O3, F_Q, F_A, F_QL, F_QI, F_QR, F_QS, F_TKE
  TYPE(FIELD_4D), POINTER :: F_CLD
  TYPE(STATE_FIELD_MASK) :: FIELD_OWNED

CONTAINS
  PROCEDURE :: INIT => STATE_TYPE_INIT
  PROCEDURE :: UPDATE_VIEW => STATE_TYPE_UPDATE_VIEW
  PROCEDURE :: FINAL => STATE_TYPE_FINAL
END TYPE STATE_TYPE

CONTAINS

  SUBROUTINE MASK_GFL_TYPE_INIT(SELF, O3, Q, A, QL, QI, QR, QS, TKE)
    CLASS(MASK_GFL_TYPE) :: SELF
    LOGICAL, INTENT(IN) :: O3, Q, A, QL, QI, QR, QS, TKE

    SELF%Q  = Q
    SELF%O3 = O3
    SELF%A  = A
    SELF%QL = QL
    SELF%QI = QI
    SELF%QR = QR
    SELF%QS = QS
    SELF%TKE= TKE
  END SUBROUTINE MASK_GFL_TYPE_INIT

  SUBROUTINE STATE_TYPE_INIT(SELF, GEOM, U, V, T, O3, Q, A, QL, QI, QR, QS, TKE, KEYMASK, PERSISTENT)
    ! Initializes FIELD objects that provide access to data views in parallel regions.
    !
    ! Note, if PERSISTENT=.TRUE. is passed all fields that have not been explicitly
    ! provided will allocate thread-local buffers only.
    CLASS(STATE_TYPE) :: SELF
    TYPE(GEOMETRY), INTENT(IN) :: GEOM
    TYPE(FIELD_3D), POINTER, OPTIONAL, INTENT(INOUT) :: U, V, T, O3, Q, A, QL, QI, QR, QS, TKE
    TYPE(MASK_GFL_TYPE), INTENT(IN) :: KEYMASK
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: NLEV

    SELF%KEYMASK = KEYMASK

    IF (PRESENT(U))   SELF%F_U => U
    IF (PRESENT(V))   SELF%F_V => V
    IF (PRESENT(T))   SELF%F_T => T
    IF (PRESENT(O3) .AND. SELF%KEYMASK%O3)  SELF%F_O3 => O3
    IF (PRESENT(Q)  .AND. SELF%KEYMASK%Q)   SELF%F_Q => Q
    IF (PRESENT(A)  .AND. SELF%KEYMASK%A)   SELF%F_A => A
    IF (PRESENT(QL))  SELF%F_QL  => QL
    IF (PRESENT(QI))  SELF%F_QI  => QI
    IF (PRESENT(QR))  SELF%F_QR  => QR
    IF (PRESENT(QS))  SELF%F_QS  => QS
    IF (PRESENT(TKE).AND. SELF%KEYMASK%TKE) SELF%F_TKE => TKE

    ! Create temporaries for all other fields
    NLEV = GEOM%YRDIMV%NFLEVG
    IF (.NOT. PRESENT(U))   SELF%F_U   => CREATE_TEMPORARY(   GEOM=GEOM, NLEV=NLEV, PERSISTENT=PERSISTENT)
    IF (.NOT. PRESENT(V))   SELF%F_V   => CREATE_TEMPORARY(   GEOM=GEOM, NLEV=NLEV, PERSISTENT=PERSISTENT)
    IF (.NOT. PRESENT(T))   SELF%F_T   => CREATE_TEMPORARY(   GEOM=GEOM, NLEV=NLEV, PERSISTENT=PERSISTENT)
    IF (.NOT.(PRESENT(O3).AND. SELF%KEYMASK%O3))SELF%F_O3=> CREATE_TEMPORARY(GEOM=GEOM, NLEV=NLEV, PERSISTENT=PERSISTENT)
    IF (.NOT.(PRESENT(Q) .AND. SELF%KEYMASK%Q)) SELF%F_Q => CREATE_TEMPORARY(GEOM=GEOM, NLEV=NLEV, PERSISTENT=PERSISTENT)
    IF (.NOT.(PRESENT(A) .AND. SELF%KEYMASK%A)) SELF%F_A => CREATE_TEMPORARY(GEOM=GEOM, NLEV=NLEV, PERSISTENT=PERSISTENT)
    IF (.NOT. PRESENT(QL))  SELF%F_QL  => NULL()  ! These are only input fields to the CLD vector
    IF (.NOT. PRESENT(QI))  SELF%F_QI  => NULL()
    IF (.NOT. PRESENT(QR))  SELF%F_QR  => NULL()
    IF (.NOT. PRESENT(QS))  SELF%F_QS  => NULL()
    IF (.NOT.(PRESENT(TKE).AND.SELF%KEYMASK%TKE))SELF%F_TKE=>CREATE_TEMPORARY(GEOM=GEOM,NLEV=NLEV,PERSISTENT=PERSISTENT)

    ! Create a mask of field ownership, so that we can delete temporaries appropriately
    SELF%FIELD_OWNED%U   = .NOT. PRESENT(U)
    SELF%FIELD_OWNED%V   = .NOT. PRESENT(V)
    SELF%FIELD_OWNED%T   = .NOT. PRESENT(T)
    SELF%FIELD_OWNED%O3  = .NOT. (PRESENT(O3) .AND. SELF%KEYMASK%O3)
    SELF%FIELD_OWNED%Q   = .NOT. (PRESENT(Q)  .AND. SELF%KEYMASK%Q)
    SELF%FIELD_OWNED%A   = .NOT. (PRESENT(A)  .AND. SELF%KEYMASK%A)
    SELF%FIELD_OWNED%TKE = .NOT. (PRESENT(TKE).AND. SELF%KEYMASK%TKE)

    ! Always create the cloud vector as a temporary
    SELF%F_CLD => CREATE_TEMPORARY(GEOM=GEOM, NLEV=NLEV, NDIM=NCLV, PERSISTENT=PERSISTENT)

  END SUBROUTINE STATE_TYPE_INIT

  SUBROUTINE STATE_TYPE_UPDATE_VIEW(SELF, BLOCK_INDEX)
    ! Extract local array views from field objects
    CLASS(STATE_TYPE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX

    IF (ASSOCIATED(SELF%F_U))   SELF%U   => SELF%F_U%GET_VIEW(BLOCK_INDEX)
    IF (ASSOCIATED(SELF%F_V))   SELF%V   => SELF%F_V%GET_VIEW(BLOCK_INDEX)
    IF (ASSOCIATED(SELF%F_T))   SELF%T   => SELF%F_T%GET_VIEW(BLOCK_INDEX)
    IF (ASSOCIATED(SELF%F_O3))  SELF%O3  => SELF%F_O3%GET_VIEW(BLOCK_INDEX)
    IF (ASSOCIATED(SELF%F_Q))   SELF%Q   => SELF%F_Q%GET_VIEW(BLOCK_INDEX)
    IF (ASSOCIATED(SELF%F_A))   SELF%A   => SELF%F_A%GET_VIEW(BLOCK_INDEX)
    IF (ASSOCIATED(SELF%F_TKE)) SELF%TKE => SELF%F_TKE%GET_VIEW(BLOCK_INDEX)
    IF (ASSOCIATED(SELF%F_CLD)) SELF%CLD => SELF%F_CLD%GET_VIEW(BLOCK_INDEX)

    ! Populate cloud vector with values from the relevant fields
    IF (ASSOCIATED(SELF%F_QL)) THEN
      SELF%QL => SELF%F_QL%GET_VIEW(BLOCK_INDEX)
      IF (SELF%KEYMASK%QL)  SELF%CLD(:,:,NCLDQL) = SELF%QL(:,:)
    END IF
    IF (ASSOCIATED(SELF%F_QI)) THEN
      SELF%QI => SELF%F_QI%GET_VIEW(BLOCK_INDEX)
      IF (SELF%KEYMASK%QI)  SELF%CLD(:,:,NCLDQI) = SELF%QI(:,:)
    END IF
    IF (ASSOCIATED(SELF%F_QR)) THEN
      SELF%QR => SELF%F_QR%GET_VIEW(BLOCK_INDEX)
      IF (SELF%KEYMASK%QR)  SELF%CLD(:,:,NCLDQR) = SELF%QR(:,:)
    END IF
    IF (ASSOCIATED(SELF%F_QS)) THEN
      SELF%QS => SELF%F_QS%GET_VIEW(BLOCK_INDEX)
      IF (SELF%KEYMASK%QS)  SELF%CLD(:,:,NCLDQS) = SELF%QS(:,:)
    END IF
  END SUBROUTINE STATE_TYPE_UPDATE_VIEW

  SUBROUTINE STATE_TYPE_FINAL(SELF)
    ! Finalize underlying field storage
    CLASS(STATE_TYPE) :: SELF

    IF (SELF%FIELD_OWNED%U)   CALL DELETE_TEMPORARY(SELF%F_U)
    IF (SELF%FIELD_OWNED%V)   CALL DELETE_TEMPORARY(SELF%F_V)
    IF (SELF%FIELD_OWNED%T)   CALL DELETE_TEMPORARY(SELF%F_T)
    IF (SELF%FIELD_OWNED%O3)  CALL DELETE_TEMPORARY(SELF%F_O3)
    IF (SELF%FIELD_OWNED%Q)   CALL DELETE_TEMPORARY(SELF%F_Q)
    IF (SELF%FIELD_OWNED%A)   CALL DELETE_TEMPORARY(SELF%F_A)
    IF (SELF%FIELD_OWNED%TKE) CALL DELETE_TEMPORARY(SELF%F_TKE)
    CALL DELETE_TEMPORARY(SELF%F_CLD)
  END SUBROUTINE STATE_TYPE_FINAL
END MODULE ECPHYS_STATE_TYPE_MOD
