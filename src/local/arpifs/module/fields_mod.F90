
! Copyright 2011 ECMWF
! 
! This software was developed at ECMWF for evaluation
! and may be used for academic and research purposes only.
! The software is provided as is without any warranty.
! 
! This software can be used, copied and modified but not
! redistributed or sold. This notice must be reproduced
! on each copy made.
!

!> Handle state for the IFS model

MODULE FIELDS_MOD

USE PARKIND1,               ONLY : JPRB, JPIM
USE YOMLUN,                 ONLY : NULOUT, NULNAM
USE FIELDS_BASE_MOD,        ONLY : FIELDS_BASE
USE GEOMETRY_MOD,           ONLY : GEOMETRY,GEOMETRY_SAME
USE VARIABLES_MOD,          ONLY : VARIABLES, VARIABLES_CLONE ! , HAS_MODEL_FIELDS
USE TYPE_MODEL,             ONLY : MODEL
USE YOMGFL,                 ONLY : TGFL
USE YOMGMV,                 ONLY : TGMV
USE SURFACE_FIELDS_MIX,     ONLY : TSURF
USE EC_PHYS_FIELDS_MOD,     ONLY : TEC_PHYS_FIELDS
USE SPECTRAL_FIELDS_MOD,    ONLY : SPECTRAL_FIELD, ASSIGNMENT(=)
USE FIELD_CONTAINER_GP_MOD, ONLY : FIELD_CONTAINER_GP
USE FIELD_VARIABLES_MOD,    ONLY : FIELD_VARIABLES
USE SURFACE_VARIABLES_MOD,  ONLY : SURFACE_VARIABLES
USE FIELD_REGISTRY_MOD,     ONLY : FIELD_REGISTRY
USE YOMCFU,                 ONLY : TCFU
USE YOMXFU,                 ONLY : TXFU
USE YOMMCUF,                ONLY : TMCUF
USE FULLPOS,                ONLY : TFPOS, TFPDATA
!
USE YEMLBC_FIELDS,          ONLY : TELBC_FIELDS

IMPLICIT NONE
PRIVATE

TYPE, PUBLIC,EXTENDS(FIELDS_BASE) :: FIELDS
!  TYPE(GEOMETRY),  POINTER :: GEOM   => NULL()
!  TYPE(VARIABLES)          :: VARS
  TYPE(TGMV)               :: YRGMV
  TYPE(TGFL)               :: YRGFL
  TYPE(TSURF)              :: YRSURF
  TYPE(SPECTRAL_FIELD)     :: YRSPEC
  TYPE(TEC_PHYS_FIELDS)    :: YEC_PHYS_FIELDS
  TYPE(FIELD_CONTAINER_GP),POINTER    :: FIELD_T0=>NULL()
  TYPE(FIELD_CONTAINER_GP) :: FIELD_T1
  TYPE(FIELD_CONTAINER_GP) :: FIELD_T9
  TYPE(FIELD_CONTAINER_GP) :: FIELD_PC
  TYPE(FIELD_CONTAINER_GP) :: FIELD_PT

  !! physics related diagnostics
  TYPE(TCFU)   :: YRCFU !! cumulated flux activation
  TYPE(TXFU)   :: YRXFU !! instantaneous flux activation
  !! moved here from model_lam_coupling_mod.F90 
  TYPE(TELBC_FIELDS), POINTER    :: YRELBC_FIELDS=>NULL()
! Fullpos
  TYPE(TFPOS),ALLOCATABLE :: YFPOS
  !! Monitoring the Coupling-Update Frequency CUF
  TYPE(TMCUF)                    :: YMCUF !! CUF

  ! Field registry for new object-based field management
  TYPE(FIELD_REGISTRY) :: REGISTRY

  ! Storage object hierarchy for core state and surface fields
  ! Note, these are large auto-generated derived types, so we
  ! attach them via pointers to avoid the nested type becoming
  ! too big for compilers to handle!
  TYPE(FIELD_VARIABLES), POINTER :: VARIABLES => NULL()
  TYPE(SURFACE_VARIABLES), POINTER :: SURFVARS => NULL()

CONTAINS

FINAL :: FIELDS_FINAL

END TYPE FIELDS

PUBLIC :: FIELDS_CREATE, FIELDS_DELETE, FIELDS_ZEROS,FIELDS_SET_MODEL,&
 & FIELDS_COPY, FIELDS_ADD, FIELDS_SUB, FIELDS_MUL, FIELDS_AXPY,&
 & FIELDS_DOT_PROD, FIELDS_SCHUR_PROD, FIELDS_ADD_INCR, FIELDS_DIFF_INCR,&
 & FIELDS_RANDOM, FIELDS_CHANGE_RESOL, FIELDS_GPNORM,FIELDS_CONTAIN,&
 & FIELDS_FORCE_WITH

! ------------------------------------------------------------------------------

CONTAINS

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_CREATE(SELF, GEOM, YDMODEL, VARS)
USE PARKIND1           , ONLY : JPRB, JPIM
USE TYPE_MODEL         , ONLY : MODEL
USE YOMMP0             , ONLY : LOUTPUT
USE YOMHOOK            , ONLY : LHOOK, DR_HOOK
USE SPECTRAL_FIELDS_MOD, ONLY : ALLOCATE_SPEC
IMPLICIT NONE

TYPE(FIELDS)   ,         INTENT(INOUT) :: SELF
TYPE(GEOMETRY) , TARGET, INTENT(IN)    :: GEOM
TYPE(MODEL)    , TARGET, INTENT(INOUT) :: YDMODEL
TYPE(VARIABLES),         INTENT(IN)    :: VARS

INTEGER(KIND=JPIM), ALLOCATABLE :: IGRIB(:)
LOGICAL,SAVE :: LLFIRST=.TRUE.
REAL(KIND=JPRB) :: ZHOOK_HANDLE

INTEGER(KIND=JPIM) :: IUNIT,IOS
LOGICAL :: LL_OPEN, LL_NAMOPEN

#include "su_surf_flds.intfb.h"
#include "susc2c.intfb.h"
#include "sucfu.intfb.h"
#include "suxfu.intfb.h"
#include "sumcuf.intfb.h"

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_CREATE',0,ZHOOK_HANDLE)

WRITE(NULOUT,*) 'CALLING FIELDS_CREATE'

! Don't want to write output from here on second and subsequent calls
! so change NULOUT if it refers to NODE output file, but only after
! checking /dev/null isn't already open. If LOUTPUT is .FALSE. then
! NULOUT already points to /dev/null.
IF(.NOT.LLFIRST.AND.LOUTPUT) THEN
  INQUIRE (FILE='/dev/null', OPENED=LL_OPEN, NUMBER=IUNIT)
  IF(LL_OPEN) THEN
    NULOUT=IUNIT
  ELSE
    NULOUT = 89
    OPEN(UNIT=NULOUT, FILE='/dev/null')
  ENDIF
ENDIF

!* Open namelist fort.4
INQUIRE(NULNAM,OPENED=LL_NAMOPEN)
IF (LL_NAMOPEN) CLOSE(NULNAM)
OPEN(NULNAM,FILE='fort.4',ACTION='READ',IOSTAT=IOS)
IF (IOS /= 0) CALL ABOR1("FIELFS_MOD:CREATE failed to open namelist fort.4")

SELF%GEOM => GEOM
CALL VARIABLES_CLONE(SELF%VARS, VARS)

IF (.NOT. SELF%VARS%LINEAR) THEN

!IF (HAS_MODEL_FIELDS(SELF%VARS)) THEN
  !* Initialize full post processing (scientif. and techn. options)
  !* NEEDED because it drives a bit of the physics diagnostics. REK
!WARNING THESE LINES HAVE BEEN REMOVED
!  WRITE(NULOUT,*) '------ Set up F-post processing options --------------'
!  CALL SUFPC(SELF%GEOM)
  !*    Set up for surface grid-point fields, from suyoma:288
  !*    (needs to be executed every time for 3dvar)
  WRITE(NULOUT,*) '---- Set up for surface grid-point fields --------------'
  CALL SU_SURF_FLDS(SELF%GEOM%YRDIMV,SELF%YRSURF,YDMODEL)
!ENDIF
ENDIF

!*    Initialize buffers for gridpoint scanning, part 3, from suyomb:634
!*    (needs to be executed every time for 3dvar)
WRITE(NULOUT,*) '---- Set up gridpoint scanning, part C -----------------'

CALL SUSC2C(SELF%GEOM,YDMODEL%YRML_PHY_EC%YREPHY,YDMODEL%YRML_GCONF,YDMODEL%YRML_PHY_MF%YRPHY, &
 &          SELF%VARS,SELF%YRGFL,SELF%YRGMV,SELF%YRSURF)

ALLOCATE(IGRIB(YDMODEL%YRML_GCONF%YRDIMF%NS3D+YDMODEL%YRML_GCONF%YRDIMF%NS2D))
IGRIB(1:YDMODEL%YRML_GCONF%YRDIMF%NS3D)=YDMODEL%YRML_GCONF%YRDIMF%NGRBSP3(:)
IGRIB(YDMODEL%YRML_GCONF%YRDIMF%NS3D+1:YDMODEL%YRML_GCONF%YRDIMF%NS3D+YDMODEL%YRML_GCONF%YRDIMF%NS2D) = &
  & YDMODEL%YRML_GCONF%YRDIMF%NGRBSP2(:)

CALL ALLOCATE_SPEC(SELF%YRSPEC, SELF%GEOM%YRDIMV%NFLEVL, SELF%GEOM%YRDIMV%NFLEVG, &
                 & SELF%GEOM%YRDIM%NUMP, SELF%GEOM%YRLAP%MYMS, SELF%GEOM%YRDIM%NSMAX, &
                 & SELF%GEOM%YRDIM%NMSMAX, SELF%GEOM%YRMP%NALLMS, SELF%GEOM%YRMP%NPTRMS, &
                 & SELF%GEOM%YRMP%NUMLL, SELF%GEOM%YRMP%NPTRLL, &
                 & SELF%GEOM%YRMP%NPSURF, YDMODEL%YRML_GCONF%YRDIMF%NS3D, YDMODEL%YRML_GCONF%YRDIMF%NS2D, &
                 & IGRIB)

DEALLOCATE(IGRIB)


!! moved here from MODEL_CREATE, at request of REK  : olivier
!*    Initialize cumulated fluxes requests
WRITE(NULOUT,*) '------ Set up cumulated fluxes diags ---'
CALL SUCFU(SELF%GEOM,SELF%YRCFU,YDMODEL%YRML_GCONF%YRRIP,YDMODEL%YRML_PHY_RAD%YRERAD,YDMODEL%YRML_PHY_MF%YRPHY,NULOUT)

!*    Initialize instantaneous fluxes requests
WRITE(NULOUT,*) '------ Set up instantaneous fluxes diags '
CALL SUXFU(SELF%GEOM,SELF%YRXFU,YDMODEL%YRML_GCONF%YRRIP,YDMODEL%YRML_PHY_MF%YRPHY,NULOUT)

!*    Initialize filter for monitoring the coupling updates
WRITE(NULOUT,*) '------ Set up monitoring coupling-updates'
CALL SUMCUF(SELF%YMCUF,SELF%GEOM%YRDIM,YDMODEL%YRML_GCONF%YRRIP)

!! Maybe this shouldn't be done for every field created, in which case it would need to move. Olivier
IF(.NOT.ALLOCATED(SELF%YRGMV%GMVT1))  ALLOCATE(SELF%YRGMV%GMVT1(GEOM%YRDIM%NPROMA, GEOM%YRDIMV%NFLEVG,&
 &                                                          SELF%YRGMV%YT1%NDIM,GEOM%YRDIM%NGPBLKS))
IF(.NOT.ALLOCATED(SELF%YRGMV%GMVT1S)) ALLOCATE(SELF%YRGMV%GMVT1S(GEOM%YRDIM%NPROMA,SELF%YRGMV%YT1%NDIMS, GEOM%YRDIM%NGPBLKS))
IF(.NOT.ALLOCATED(SELF%YRGFL%GFLT1))  ALLOCATE(SELF%YRGFL%GFLT1(GEOM%YRDIM%NPROMA, GEOM%YRDIMV%NFLEVG, &
 &                                                          YDMODEL%YRML_GCONF%YGFL%NDIM1,GEOM%YRDIM%NGPBLKS))

SELF%YRGMV%GMVT1  = 0._JPRB
SELF%YRGMV%GMVT1S = 0._JPRB
SELF%YRGFL%GFLT1  = 0._JPRB

IF (YDMODEL%YRML_PHY_EC%YREPHY%LEPHYS) CALL SELF%YEC_PHYS_FIELDS%CREATE(SELF%GEOM,YDMODEL%YRML_PHY_G%YRDPHY)

!! point the YGFL pointer in self%yrgfl to that in the model passed in
SELF%YRGFL%YGFL => YDMODEL%YRML_GCONF%YGFL
!! point the model pointer in self to the model passed in 
SELF%STATE_MODEL => YDMODEL

CALL FIELDS_CONTAIN(SELF,SELF%GEOM)

!YT CALL GEOMETRY_UNSET(SELF%GEOM)
IF(.NOT.LLFIRST.AND.LOUTPUT) THEN
  IF(.NOT.LL_OPEN) CLOSE(UNIT=NULOUT)
  NULOUT=20
ENDIF
LLFIRST = .FALSE.  

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_CREATE',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_CREATE

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_DELETE(SELF)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
USE YOMCT0   , ONLY : LSLAG, LTWOTL
USE SURFACE_FIELDS_MIX , ONLY : DEALLO_SURF
USE SPECTRAL_FIELDS_MOD, ONLY: DEALLOCATE_SPEC
IMPLICIT NONE

TYPE(FIELDS), INTENT(INOUT) :: SELF

REAL(KIND=JPRB) :: ZHOOK_HANDLE

#include "dealxmo.intfb.h"
#include "falsify_surf_flds.intfb.h"

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_DELETE',0,ZHOOK_HANDLE)

WRITE(NULOUT,*) 'CALLING FIELDS_DELETE'

IF (.NOT. SELF%VARS%LINEAR) THEN
  CALL DEALLO_SURF(SELF%YRSURF)
ENDIF
CALL FALSIFY_SURF_FLDS(SELF%YRSURF)
DEALLOCATE(SELF%YRCFU%GFUBUF)
DEALLOCATE(SELF%YRXFU%XFUBUF)
IF (SELF%YMCUF%LMCUF) THEN
  DEALLOCATE(SELF%YMCUF%RMCUFSP)
  DEALLOCATE(SELF%YMCUF%RMCUFFP)
ENDIF
CALL DEALLOCATE_SPEC(SELF%YRSPEC)
IF(ALLOCATED(SELF%YRGMV%GMVT1))  DEALLOCATE(SELF%YRGMV%GMVT1)
IF(ALLOCATED(SELF%YRGMV%GMVT1S)) DEALLOCATE(SELF%YRGMV%GMVT1S)
IF(ALLOCATED(SELF%YRGFL%GFLT1))  DEALLOCATE(SELF%YRGFL%GFLT1)
NULLIFY(SELF%YRGFL%YGFL)
CALL DEALXMO(SELF%YRGFL,SELF%YRGMV)
CALL SELF%FIELD_T1%FIELD_DESTROY()
IF (ASSOCIATED(SELF%FIELD_T0)) THEN
    CALL SELF%FIELD_T0%FIELD_DESTROY()
    DEALLOCATE(SELF%FIELD_T0)
ENDIF
CALL SELF%FIELD_T9%FIELD_DESTROY()
CALL SELF%FIELD_PC%FIELD_DESTROY()
CALL SELF%FIELD_PT%FIELD_DESTROY()
NULLIFY(SELF%GEOM)
NULLIFY(SELF%STATE_MODEL)
IF (ASSOCIATED(SELF%VARIABLES)) THEN
  CALL SELF%REGISTRY%FINAL()
  CALL SELF%VARIABLES%FINAL()
END IF
! CALL SELF%SURFACE_FIELDS%FINAL()
IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_DELETE',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_DELETE

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_ZEROS(SELF)
USE PARKIND1          , ONLY : JPRB
USE YOMHOOK           , ONLY : LHOOK, DR_HOOK
USE YOMGFL            , ONLY : ZERO_YOMGFL
USE YOMGMV            , ONLY : ZERO_YOMGMV
USE SURFACE_FIELDS_MIX, ONLY : ZERO_SURF
USE YOMMCUF           , ONLY : ZERO_MCUF
IMPLICIT NONE

TYPE(FIELDS), INTENT(INOUT) :: SELF
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_ZEROS',0,ZHOOK_HANDLE)
WRITE(NULOUT,*) 'CALLING FIELDS_ZEROS'

CALL ZERO_YOMGMV(SELF%YRGMV)
CALL ZERO_YOMGFL(SELF%YRGFL)
CALL ZERO_SURF(SELF%YRSURF)
CALL ZERO_MCUF(SELF%YMCUF)
SELF%YRSPEC = 0.0_JPRB
CALL SELF%YEC_PHYS_FIELDS%ZERO()

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_ZEROS',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_ZEROS

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_COPY(SELF,RHS)
USE PARKIND1          , ONLY : JPRB
USE YOMHOOK           , ONLY : LHOOK, DR_HOOK
USE YOMGFL            , ONLY : COPY_YOMGFL
USE YOMGMV            , ONLY : COPY_YOMGMV
USE SURFACE_FIELDS_MIX, ONLY : COPY_SURF
USE TYPE_FLUXES       , ONLY : COPY_FLUX
USE YOMMCUF           , ONLY : COPY_MCUF
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(INOUT) :: SELF
TYPE(FIELDS)    , INTENT(IN)    :: RHS

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_COPY',0,ZHOOK_HANDLE)
WRITE(NULOUT,*) 'CALLING FIELDS_COPY'

CALL COPY_YOMGMV(SELF%YRGMV,RHS%YRGMV)
CALL COPY_YOMGFL(SELF%YRGFL,RHS%YRGFL)
CALL COPY_SURF(SELF%YRSURF,RHS%YRSURF)
CALL COPY_FLUX(SELF%YRCFU%GFUBUF,RHS%YRCFU%GFUBUF)
CALL COPY_FLUX(SELF%YRXFU%XFUBUF,RHS%YRXFU%XFUBUF)
CALL COPY_MCUF(SELF%YMCUF,RHS%YMCUF)
!SELF%YRSPEC = RHS%YRSPEC
! Copy arrays to be safe
SELF%YRSPEC%SP2D = RHS%YRSPEC%SP2D
SELF%YRSPEC%SP3D = RHS%YRSPEC%SP3D

! Copy the model-related pointers as well
SELF%YRGFL%YGFL => RHS%YRGFL%YGFL
SELF%STATE_MODEL => RHS%STATE_MODEL

IF (SELF%STATE_MODEL%YRML_PHY_EC%YREPHY%LEPHYS) CALL SELF%YEC_PHYS_FIELDS%COPY(RHS%YEC_PHYS_FIELDS)

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_COPY',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_COPY

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_SET_MODEL(SELF,YDMODEL)
TYPE(FIELDS),         INTENT(INOUT) :: SELF
TYPE(MODEL) , TARGET, INTENT(IN)    :: YDMODEL

!! point the YGFL pointer in self%yrgfl to that in the model passed in
SELF%YRGFL%YGFL => YDMODEL%YRML_GCONF%YGFL
!! point the model pointer in self to the model passed in 
SELF%STATE_MODEL => YDMODEL

END SUBROUTINE FIELDS_SET_MODEL

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_ADD(SELF,RHS)
USE PARKIND1, ONLY : JPRB
USE YOMGFL,   ONLY : AXPBY_YOMGFL
USE YOMGMV,   ONLY : AXPBY_YOMGMV
USE SURFACE_FIELDS_MIX, ONLY : ADD_SURF
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(INOUT) :: SELF
TYPE(FIELDS)    , INTENT(IN)    :: RHS

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_ADD',0,ZHOOK_HANDLE)

WRITE(NULOUT,*) 'CALLING FIELDS_ADD'

CALL AXPBY_YOMGMV(SELF%YRGMV,1.0_JPRB,RHS%YRGMV,1.0_JPRB)
CALL AXPBY_YOMGFL(SELF%YRGFL,1.0_JPRB,RHS%YRGFL,1.0_JPRB)
CALL ADD_SURF(SELF%YRSURF,RHS%YRSURF)

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_ADD',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_ADD

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_SUB(SELF,RHS)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK , ONLY : LHOOK, DR_HOOK
USE YOMGFL  , ONLY : AXPBY_YOMGFL,DIFF_YOMGFL
USE YOMGMV  , ONLY : AXPBY_YOMGMV,DIFF_YOMGMV
USE SURFACE_FIELDS_MIX, ONLY : AXPBY_SURF
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(INOUT) :: SELF
TYPE(FIELDS)    , INTENT(IN)    :: RHS

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_SUB',0,ZHOOK_HANDLE)
WRITE(NULOUT,*) 'CALLING FIELDS_SUB'

!!CALL AXPBY_YOMGMV(SELF%YRGMV,1.0_JPRB,RHS%YRGMV,-1.0_JPRB)
!!CALL AXPBY_YOMGFL(SELF%YRGFL,1.0_JPRB,RHS%YRGFL,-1.0_JPRB)

!! slightly cheaper than calling axpby
CALL DIFF_YOMGMV(SELF%YRGMV,RHS%YRGMV)
CALL DIFF_YOMGFL(SELF%YRGFL,RHS%YRGFL)
CALL AXPBY_SURF(SELF%YRSURF,1.0_JPRB,RHS%YRSURF,-1.0_JPRB)

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_SUB',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_SUB

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_MUL(SELF,PZ)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
USE YOMGFL,   ONLY : MUL_YOMGFL
USE YOMGMV,   ONLY : MUL_YOMGMV
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(INOUT) :: SELF
REAL(KIND=JPRB) , INTENT(IN)    :: PZ
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_MUL',0,ZHOOK_HANDLE)
WRITE(NULOUT,*) 'CALLING FIELDS_MUL'

CALL MUL_YOMGMV(SELF%YRGMV,PZ)
CALL MUL_YOMGFL(SELF%YRGFL,PZ)

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_MUL',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_MUL

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_AXPY(SELF,PZ,RHS)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
USE YOMGFL,   ONLY : AXPBY_YOMGFL
USE YOMGMV,   ONLY : AXPBY_YOMGMV
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(INOUT) :: SELF
REAL(KIND=JPRB) , INTENT(IN)    :: PZ
TYPE(FIELDS)    , INTENT(IN)    :: RHS
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_AXPY',0,ZHOOK_HANDLE)
WRITE(NULOUT,*) 'CALLING FIELDS_AXPY'

CALL AXPBY_YOMGMV(SELF%YRGMV,1.0_JPRB,RHS%YRGMV,PZ)
CALL AXPBY_YOMGFL(SELF%YRGFL,1.0_JPRB,RHS%YRGFL,PZ)

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_AXPY',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_AXPY

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_DOT_PROD(FLD1,FLD2,PPROD)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
USE YOMGFL,   ONLY : DOT_PROD_YOMGFL
USE YOMGMV,   ONLY : DOT_PROD_YOMGMV
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(IN)    :: FLD1, FLD2
REAL(KIND=JPRB) , INTENT(OUT)   :: PPROD

REAL(KIND=JPRB) :: ZTMP
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_DOT_PROD',0,ZHOOK_HANDLE)
WRITE(NULOUT,*) 'CALLING FIELDS_DOT_PROD'

IF (.NOT. ASSOCIATED(FLD1%GEOM,FLD2%GEOM)) THEN
  CALL ABOR1("FIELDS_MOD:FIELDS_DOT_PRODUCT Different geometries")
ENDIF

PPROD = 0.0_JPRB
CALL DOT_PROD_YOMGMV(FLD1%GEOM,FLD1%YRGMV,FLD2%YRGMV,ZTMP)
PPROD = PPROD + ZTMP
CALL DOT_PROD_YOMGFL(FLD1%GEOM,FLD1%YRGFL,FLD2%YRGFL,ZTMP)
PPROD = PPROD + ZTMP

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_DOT_PROD',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_DOT_PROD

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_SCHUR_PROD(FLD1, FLD2)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
IMPLICIT NONE

TYPE(FIELDS), INTENT(INOUT) :: FLD1
TYPE(FIELDS), INTENT(IN)    :: FLD2

REAL(KIND=JPRB) :: ZHOOK_HANDLE

#include "abor1.intfb.h"

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_SCHUR_PROD',0,ZHOOK_HANDLE)

CALL ABOR1("FIELDS_MOD: Schur product not implemented")
!CALL SCHUR_PROD_YOMGMV(FLD1%YRGMV,FLD2%YRGMV)
!CALL SCHUR_PROD_YOMGFL(FLD1%YRGFL,FLD2%YRGFL)

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_SCHUR_PROD',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_SCHUR_PROD

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_ADD_INCR(SELF,RHS)
USE PARKIND1, ONLY : JPRB
USE YOMGFL,   ONLY : AXPBY_YOMGFL
USE YOMGMV,   ONLY : AXPBY_YOMGMV
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(INOUT) :: SELF
TYPE(FIELDS)    , INTENT(IN)    :: RHS
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_ADD_INCR',0,ZHOOK_HANDLE)
WRITE(NULOUT,*) 'CALLING FIELDS_ADD_INCR'

CALL FIELDS_GPNORM(SELF,'FIELDS_ADD_INCR: First Guess')
CALL FIELDS_GPNORM(RHS,'FIELDS_ADD_INCR: Increment')

! Currently identical to fields_add
CALL AXPBY_YOMGMV(SELF%YRGMV,1.0_JPRB,RHS%YRGMV,1.0_JPRB)
CALL AXPBY_YOMGFL(SELF%YRGFL,1.0_JPRB,RHS%YRGFL,1.0_JPRB)

CALL FIELDS_GPNORM(SELF,'FIELDS_ADD_INCR: Analysis')

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_ADD_INCR',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_ADD_INCR

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_DIFF_INCR(LHS,X1,X2)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(INOUT) :: LHS
TYPE(FIELDS)    , INTENT(IN)    :: X1
TYPE(FIELDS)    , INTENT(IN)    :: X2
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_DIFF_INCR',0,ZHOOK_HANDLE)
WRITE(NULOUT,*) 'CALLING FIELDS_DIFF_INCR'

! Currently identical to a 3-argument fields_sub
CALL FIELDS_COPY(LHS,X1)
CALL FIELDS_SUB(LHS,X2)

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_DIFF_INCR',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_DIFF_INCR

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_RANDOM(SELF)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
USE YOMGFL,   ONLY : RANDOM_YOMGFL
USE YOMGMV,   ONLY : RANDOM_YOMGMV
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(INOUT) :: SELF
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_RANDOM',0,ZHOOK_HANDLE)

CALL RANDOM_YOMGMV(SELF%YRGMV)
CALL RANDOM_YOMGFL(SELF%YRGFL)

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_RANDOM',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_RANDOM

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_CHANGE_RESOL(SELF,RHS)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
USE YOMCT3,  ONLY : NSTEP
USE FIELD_CONTAINER_OPER_MOD
USE FIELD_DEFINITIONS, ONLY : FID
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(INOUT) :: SELF
TYPE(FIELDS)    , INTENT(INOUT) :: RHS

LOGICAL :: LLSAME_RESOL
INTEGER(KIND=JPIM),ALLOCATABLE :: IFIDS_SPEC(:),IACTIVE(:)
REAL(KIND=JPRB) :: ZHOOK_HANDLE


IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_CHANGE_RESOL',0,ZHOOK_HANDLE)
LLSAME_RESOL = GEOMETRY_SAME(SELF%GEOM,RHS%GEOM)
WRITE(NULOUT,*) 'FIELDS_CHANGE_RESOL CALLED ', LLSAME_RESOL,SELF%GEOM%YRGEM%NGPTOTG,RHS%GEOM%YRGEM%NGPTOTG,NSTEP
CALL FLUSH(NULOUT)

IF(LLSAME_RESOL) THEN
  CALL FIELDS_COPY(SELF,RHS)
ELSE 
  ALLOCATE(IFIDS_SPEC(4))
  IFIDS_SPEC=(/FID%U,FID%V,FID%T,FID%SP/)
! CALL FIELD_CONTAINER_INTERP(RHS%GEOM,SELF%GEOM,RHS%FIELD,SELF%FIELD,KFIDS_SPEC=IFIDS_SPEC,PSPSP=RHS%YRSPEC%SP)
  CALL FIELD_CONTAINER_INTERP(RHS%GEOM,SELF%GEOM,RHS%FIELD,SELF%FIELD,KFIDS_SPEC=IFIDS_SPEC)
  SELF%YRSPEC = RHS%YRSPEC ! Assignement does also truncation/zero-filling
ENDIF
! Uncomment the following to read surface climate data
!!$if(SELF%GEOM%YRDIM%NSMAX < 100) then
!!$  write(clfname,'(a,i2.2)') 'climate_data_',SELF%GEOM%YRDIM%NSMAX
!!$else
!!$  write(clfname,'(a,i3.3)') 'climate_data_',SELF%GEOM%YRDIM%NSMAX
!!$endif
!!$ALLOCATE(IFIDS_CLIM(22))
!!$IFIDS_CLIM=[FID%VF_VRLDI,FID%VF_VRLAN,FID%VF_SIG,FID%VF_GETRL,FID%VF_Z0F,FID%VF_LZ0H,FID%VF_CVH,FID%VF_CVL, &
!!$ & FID%VF_TVH,FID%VF_TVL,FID%VF_LSM,FID%VF_SOTY,FID%VF_DL,FID%VF_CLK,FID%VF_LAIL,FID%VF_LAIH,FID%VF_ALBF, &
!!$ & FID%VF_ALUVP,FID%VF_ALUVD,FID%VF_ALNIP, FID%VF_ALNID, &
!!$ & FID%VF_ALUVI,FID%VF_ALUVV,FID%VF_ALUVG, &
!!$ & FID%VF_ALNII,FID%VF_ALNIV,FID%VF_ALNIG, &
!!$ & FID%VF_SDFOR]
!!$CALL SELF%fields_read(cdfname=clfname,kfids=ifids_clim)

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_CHANGE_RESOL',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_CHANGE_RESOL
! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_FORCE_WITH(SELF,RHS)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
USE YOMCT0,  ONLY : LECMWF
USE YOMCT3,  ONLY : NSTEP
USE FIELD_CONTAINER_OPER_MOD
USE FIELD_DEFINITIONS, ONLY : FID
IMPLICIT NONE

TYPE(FIELDS)    , INTENT(INOUT) :: SELF
TYPE(FIELDS)    , INTENT(INOUT) :: RHS

LOGICAL :: LLSAME_RESOL
INTEGER(KIND=JPIM),ALLOCATABLE :: IFIDS_GP(:),IFIDS_SPEC(:),IACTIVE(:),IFIDS_CLIM(:),IFIDS(:)
CHARACTER(LEN=32) :: CLFNAME
REAL(KIND=JPRB) :: ZHOOK_HANDLE


IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_FORCE_WITH',0,ZHOOK_HANDLE)
LLSAME_RESOL = GEOMETRY_SAME(SELF%GEOM,RHS%GEOM)
WRITE(NULOUT,*) 'FIELDS_FORCE_WITH CALLED ', LLSAME_RESOL,SELF%GEOM%YRGEM%NGPTOTG,RHS%GEOM%YRGEM%NGPTOTG,NSTEP
CALL FLUSH(NULOUT)

ALLOCATE(IFIDS_SPEC(4))
IFIDS_SPEC=(/FID%U,FID%V,FID%T,FID%SP/)
IF (LECMWF) THEN
  ALLOCATE(IFIDS(2))
  IFIDS=(/FID%Q,FID%O3/) !This should not be hard-coded
ELSE
  ALLOCATE(IFIDS(1))
  IFIDS=(/FID%Q/) !This should not be hard-coded
ENDIF
IF(LLSAME_RESOL) THEN
  CALL SELF%FIELD%FIELD_COPY(RHS%FIELD,KFIDS=IFIDS) 
ELSE
  CALL FIELD_CONTAINER_INTERP(RHS%GEOM,SELF%GEOM,RHS%FIELD,SELF%FIELD,KFIDS_SPEC=IFIDS_SPEC,KFIDS=IFIDS)
ENDIF
SELF%YRSPEC = RHS%YRSPEC ! Assignement does also truncation/zero-filling

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_FORCE_WITH',1,ZHOOK_HANDLE)

END SUBROUTINE FIELDS_FORCE_WITH

! ------------------------------------------------------------------------------

SUBROUTINE FIELDS_GPNORM(SELF,CDGREP)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK

IMPLICIT NONE

TYPE(FIELDS)    , INTENT(IN)    :: SELF
CHARACTER(LEN=*), INTENT(IN)    :: CDGREP

REAL(KIND=JPRB) :: ZSPNORMS(3,1), ZGMVNORMS(3,SELF%GEOM%YRDIMV%NFLEVG), ZGFLNORMS(3,SELF%GEOM%YRDIMV%NFLEVG)
REAL(KIND=JPRB) :: ZHOOK_HANDLE

#include "gpnorm_gmv.intfb.h"
#include "gpnorm_gfl.intfb.h"

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_GPNORM',0,ZHOOK_HANDLE)

WRITE(NULOUT,*)CDGREP

!! OOPS calls fields_gpnorm with an output argument
IF (.FALSE.) THEN
  ZSPNORMS  = 0._JPRB
  ZGMVNORMS = 0._JPRB
  ZGFLNORMS = 0._JPRB
!!  CALL GPNORM_GMV(SELF%GEOM,SELF%YRGMV,PSPNORMS=ZSPNORMS,PGMVNORMS=ZGMVNORMS)
!!  CALL GPNORM_GFL(SELF%GEOM,SELF%YRGFL,PGFLNORMS=ZGFLNORMS)
  !! this is probably not at all what is wanted for OOPS , it is just a meaningless positive scalar value
!!  NORMS_OUT = ABS( SUM( ZGFLNORMS(1,:) + ZGMVNORMS(1,:) ) )
ELSE
  CALL GPNORM_GMV(SELF%GEOM,SELF%YRGMV)
  CALL GPNORM_GFL(SELF%GEOM,SELF%YRGFL,LDPRINT_TL=.TRUE.)
ENDIF
CALL FLUSH(NULOUT)

IF (LHOOK) CALL DR_HOOK('FIELDS_MOD:FIELDS_GPNORM',1,ZHOOK_HANDLE)
END SUBROUTINE FIELDS_GPNORM

SUBROUTINE FIELDS_CONTAIN(SELF,YDGEOMTRY)
USE PARKIND1, ONLY : JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
USE YOMDYNA  , ONLY : LPC_FULL
USE YOMCT0   , ONLY : LSLAG, LTWOTL
USE YOMMP0   , ONLY : NPRINTLEV
USE YOEPHY   , ONLY : YREPHY
USE YOMPHY   , ONLY : YRPHY
USE FIELD_DEFINITIONS_BASE, ONLY : JP_T0, JP_T9, JP_T1, JP_PC, JP_PT
USE FIELD_DEFINITIONS, ONLY : MAIN_FIELD_METADATA
IMPLICIT NONE
TYPE(FIELDS), INTENT(INOUT)  :: SELF
TYPE(GEOMETRY),INTENT(IN)    :: YDGEOMTRY

INTEGER(KIND=JPIM),ALLOCATABLE :: IACTIVE(:)
INTEGER(KIND=JPIM) :: JID


ALLOCATE(SELF%FIELD_T0)
ASSOCIATE(FIELD_T1=>SELF%FIELD_T1,FIELD_T0=>SELF%FIELD_T0,FIELD_T9=>SELF%FIELD_T9,FIELD_PC=>SELF%FIELD_PC,FIELD_PT=>SELF%FIELD_PT,&
 & YDGFL=>SELF%YRGFL,YDGMV=>SELF%YRGMV, YDSURF=>SELF%YRSURF,YDGEM=>YDGEOMTRY%YRGEM,YDDIMV=>YDGEOMTRY%YRDIMV,& 
 & YDDIM=>YDGEOMTRY%YRDIM,YGFL=>SELF%YRGFL%YGFL)
ASSOCIATE(NGPTOT=>YDGEM%NGPTOT,NFLEVG=>YDDIMV%NFLEVG,NPROMA=>YDDIM%NPROMA,LEPHYS=>YREPHY%LEPHYS,LMPHYS=>YRPHY%LMPHYS,&
 & NCHEM_FLX=>YGFL%NCHEM_FLX, NCHEM_FLXO=>YGFL%NCHEM_FLXO,NCHEM_DV=>YGFL%NCHEM_DV,&
 & NGFL_EXT=>YGFL%NGFL_EXT,NGFL_EZDIAG=>YGFL%NGFL_EZDIAG)


CALL FIELD_T1%FIELD_CREATE(MAIN_FIELD_METADATA,  NGPTOT, &
 & (/ NFLEVG, NFLEVG+1, YDSURF%YSP_SBD%NLEVS, YDSURF%YSP_SGD%NLEVS,NCHEM_FLX,NCHEM_FLXO,NCHEM_DV/), NPROMA, KATTACH=JP_T1, &
  & YDGMV=YDGMV,YDGFL=YDGFL,YDSURF=YDSURF,LD_ATTACH_GFL_NPROMA_FIXED=.TRUE.)

CALL FIELD_T0%FIELD_CREATE(MAIN_FIELD_METADATA,  NGPTOT, &
 & (/ NFLEVG, NFLEVG+1, YDSURF%YSP_SBD%NLEVS, YDSURF%YSP_SGD%NLEVS,NCHEM_FLX,NCHEM_FLXO,NCHEM_DV/), NPROMA, KATTACH=JP_T0, &
  & YDGMV=YDGMV,YDGFL=YDGFL,YDSURF=YDSURF,LD_ATTACH_GFL_NPROMA_FIXED=.TRUE.,LDHDERS=.TRUE.,KDIM3S=(/NGFL_EXT,NGFL_EZDIAG/))

CALL FIELD_T9%FIELD_CREATE(MAIN_FIELD_METADATA,  NGPTOT, &
 & (/ NFLEVG, NFLEVG+1, YDSURF%YSP_SBD%NLEVS, YDSURF%YSP_SGD%NLEVS,NCHEM_FLX,NCHEM_FLXO,NCHEM_DV/), NPROMA, KATTACH=JP_T9, &
  & YDGMV=YDGMV,YDGFL=YDGFL,YDSURF=YDSURF,LD_ATTACH_GFL_NPROMA_FIXED=.TRUE., LDHDERS=.TRUE.)

IF(LPC_FULL .AND. .NOT. LTWOTL) THEN
  CALL FIELD_PC%FIELD_CREATE(MAIN_FIELD_METADATA,  NGPTOT, &
   & (/ NFLEVG, NFLEVG+1, YDSURF%YSP_SBD%NLEVS, YDSURF%YSP_SGD%NLEVS,NCHEM_FLX,NCHEM_FLXO,NCHEM_DV/), NPROMA, KATTACH=JP_PC, &
  & YDGMV=YDGMV,YDGFL=YDGFL,YDSURF=YDSURF,LD_ATTACH_GFL_NPROMA_FIXED=.TRUE.,LDHDERS=.FALSE.)
ENDIF
IF(LPC_FULL.AND.LSLAG.AND.(LEPHYS.OR.LMPHYS)) THEN
  CALL FIELD_PT%FIELD_CREATE(MAIN_FIELD_METADATA,  NGPTOT, &
   & (/ NFLEVG, NFLEVG+1, YDSURF%YSP_SBD%NLEVS, YDSURF%YSP_SGD%NLEVS,NCHEM_FLX,NCHEM_FLXO,NCHEM_DV/), NPROMA, KATTACH=JP_PT, &
  & YDGMV=YDGMV,YDGFL=YDGFL,YDSURF=YDSURF,LD_ATTACH_GFL_NPROMA_FIXED=.TRUE., LDHDERS=.FALSE.)
ENDIF

CALL FIELD_T0%GET_ACTIVE_FIELDS(IACTIVE)
IF (NPRINTLEV > 1) THEN
  DO JID=1,SIZE(IACTIVE)
    WRITE(NULOUT,*) 'ACTIVE FIELD ',JID,IACTIVE(JID)
  ENDDO
ENDIF

SELF%FIELD => SELF%FIELD_T0

END ASSOCIATE
END ASSOCIATE

END SUBROUTINE FIELDS_CONTAIN

SUBROUTINE FIELDS_FINAL(THIS)
  TYPE(FIELDS) :: THIS
  ! If we don't add this, we may get a internal compiler error
END SUBROUTINE

! ------------------------------------------------------------------------------

END MODULE FIELDS_MOD
