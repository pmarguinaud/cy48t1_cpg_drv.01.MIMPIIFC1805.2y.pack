MODULE IOSPECA_MOD

!**** *IOSPECA_MOD*  - SUSPECA & WRSPECA field selection

!     Author. 
!     ------- 
!      Philippe Marguinaud *METEO-FRANCE*
!      Original : 18-04-2012 (from wrspeca.F90 & suspeca.F90)

!     Modifications.
!     --------------
!      P.Marguinaud : 30-05-2012 : Handle multi-buffer
!      P.Marguinaud : 04-06-2012 : Fix LTWGRA issue
!      P.Marguinaud : 11-09-2012 : Use IOMULTIBUF_MOD, IOFLDDESC_MOD
!      P.Marguinaud : 10-10-2013 : Cleaning
!      T. Wilhelmsson and K. Yessad (Oct 2013) Geometry and setup refactoring.
!      P.Marguinaud : 10-10-2014 : Read coupling files from the IO server
!      P.Marguinaud : 04-10-2016 : Port to single precision
!      K. Yessad (Feb 2018): remove deep-layer formulations.
!-----------------------------------------------------------------------------

USE PARKIND1           , ONLY : JPIM, JPRB
USE YOMHOOK            , ONLY : LHOOK, DR_HOOK
USE SPECTRAL_FIELDS_MOD, ONLY : SPECTRAL_FIELD, ASSIGNMENT(=)
USE FA_MOD, ONLY : JPPRCM

USE IOMULTIBUF_MOD     , ONLY : IOMULTIBUF,          &
 &                              IOMULTIBUF_SIZE_IDX, &
 &                              IOMULTIBUF_INIT_IDX, &
 &                              IOMULTIBUF_INCR_IDX

USE IOFLDDESC_MOD      , ONLY : IOFLDDESC

USE YOMIO_SERV_MAP_PLAN, ONLY : IO_SERV_RECV_PLAN

IMPLICIT NONE


TYPE IOSPECA_CTX
  REAL(KIND=JPRB), POINTER :: RSPU (:,:) => NULL (), RSPV (:,:) => NULL ()
  REAL(KIND=JPRB), POINTER :: RSPT (:,:) => NULL ()
  REAL(KIND=JPRB), POINTER :: RSPSPD (:,:) => NULL (), RSPSVD (:,:) => NULL (), RSPSP (:) => NULL (), RSPNHX (:,:) => NULL ()
END TYPE IOSPECA_CTX

TYPE SUSPECA_MAP_CTX
  TYPE (IOSPECA_CTX)           :: YIOSP
  TYPE (IO_SERV_RECV_PLAN)     :: YIOSMPP
  INTEGER (KIND=JPIM), POINTER :: IVSETOFF (:) => NULL ()
  TYPE (IOFLDDESC),    POINTER :: YFLDSC (:)   => NULL ()
END TYPE SUSPECA_MAP_CTX

INTEGER (KIND=JPIM), PARAMETER :: NSPECACT_WRITE = 0, NSPECACT_READ = 1, &
                                & NSPECACT_WRITE_GP = 2, NSPECACT_READ_GP = 3

PRIVATE
PUBLIC :: IOSPECA_START, IOSPECA_COUNT, IOSPECA_SELECTF, IOSPECA_SELECTD,    &
        & IOSPECA_FINISH, IOSPECA_VSETOFF, IOSPECA_FLDDESC_SP2GP,            &
        & NSPECACT_WRITE, NSPECACT_READ, NSPECACT_WRITE_GP, NSPECACT_READ_GP,&
        & IOSPECA_UV2PFCF_GP, IOSPECA_PFCF2UV_GP, IOSPECA_CTX, SUSPECA_MAP_CTX

INTERFACE IOSPECA_SELECTF
  MODULE PROCEDURE IOSPECA_SELECTFX, IOSPECA_SELECTFY
END INTERFACE

SAVE

CONTAINS


SUBROUTINE IOSPECA_VSETOFF (KVSET, KFLDSCH, KVSETOFF)

USE YOMMP0, ONLY : NPRTRV

INTEGER (KIND=JPIM), INTENT (IN)  :: KVSET (:)
INTEGER (KIND=JPIM), INTENT (OUT), OPTIONAL :: KFLDSCH (NPRTRV)
INTEGER (KIND=JPIM), INTENT (OUT), OPTIONAL :: KVSETOFF (NPRTRV)

INTEGER (KIND=JPIM) :: IFLDSCH (NPRTRV)
INTEGER (KIND=JPIM) :: IVSETOFF (NPRTRV)

INTEGER (KIND=JPIM) :: JSETV

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_VSETOFF',0,ZHOOK_HANDLE)

DO JSETV = 1, NPRTRV
  IFLDSCH (JSETV)  = COUNT (KVSET == JSETV)
ENDDO

IVSETOFF (1) = 0 
DO JSETV = 2, NPRTRV
  IVSETOFF (JSETV) = IFLDSCH (JSETV-1) + IVSETOFF (JSETV-1)
ENDDO

IF (PRESENT (KFLDSCH))  KFLDSCH  = IFLDSCH
IF (PRESENT (KVSETOFF)) KVSETOFF = IVSETOFF

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_VSETOFF',1,ZHOOK_HANDLE)

END SUBROUTINE IOSPECA_VSETOFF

SUBROUTINE IOSPECA_START(YDGEOMETRY,YDGFL,YDML_GCONF,KACTION,YDCTX,YDSPEC)

USE MODEL_GENERAL_CONF_MOD , ONLY : MODEL_GENERAL_CONF_TYPE
USE GEOMETRY_MOD           , ONLY : GEOMETRY
USE YOMGFL                 , ONLY : TGFL
USE YOMLUN                 , ONLY : NULOUT 
USE YOMCT0                 , ONLY : LELAM, LSPRT, LNHDYN
USE YOMDYNA                , ONLY : YRDYNA

TYPE (GEOMETRY),      INTENT (IN)    :: YDGEOMETRY
TYPE (TGFL),          INTENT (INOUT) :: YDGFL
TYPE(MODEL_GENERAL_CONF_TYPE),INTENT(IN):: YDML_GCONF
INTEGER (KIND=JPIM),  INTENT (IN)    :: KACTION
TYPE (IOSPECA_CTX),   INTENT (INOUT) :: YDCTX
TYPE(SPECTRAL_FIELD), INTENT (INOUT) :: YDSPEC

#include "evduvgeo.intfb.h"
#include "specrt.intfb.h"
#include "especrt.intfb.h"
#include "spnh_conv_nhvar.intfb.h"

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_START',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP)
ASSOCIATE(NFLSUR=>YDDIMV%NFLSUR, &
 & NSPEC2=>YDDIM%NSPEC2)
SELECT CASE (KACTION)

  CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP) 

! Compute T from RT and Q

! Tv is saved in RSPT
! Compute T from Tv and q and fill SPT with T

    IF (LSPRT) THEN
      ALLOCATE (YDCTX%RSPT (YDGEOMETRY%YRDIMV%NFLSUR, YDGEOMETRY%YRDIM%NSPEC2))
      YDCTX%RSPT (1:YDGEOMETRY%YRDIMV%NFLSUR,1:YDGEOMETRY%YRDIM%NSPEC2) =&
     & YDSPEC%T (1:YDGEOMETRY%YRDIMV%NFLSUR,1:YDGEOMETRY%YRDIM%NSPEC2)
      IF (LELAM) THEN
        CALL ESPECRT (YDGEOMETRY, YDGFL,YDML_GCONF%YGFL, 1, YDSPEC)
      ELSE
        CALL SPECRT(YDGEOMETRY,YDGFL,YDML_GCONF%YGFL,1,YDSPEC)
      ENDIF
    ENDIF

! Compute PD,VD

    IF (LNHDYN) THEN
      ALLOCATE (YDCTX%RSPSPD (YDGEOMETRY%YRDIMV%NFLSUR,YDGEOMETRY%YRDIM%NSPEC2))
      ALLOCATE (YDCTX%RSPSVD (YDGEOMETRY%YRDIMV%NFLSUR,YDGEOMETRY%YRDIM%NSPEC2))
      IF (YRDYNA%LNHX) ALLOCATE (YDCTX%RSPNHX (YDGEOMETRY%YRDIMV%NFLSUR,YDGEOMETRY%YRDIM%NSPEC2))
 
! Copy to avoid overwriting
      YDCTX%RSPSPD (:,:) = YDSPEC%SPD (:,:)
      YDCTX%RSPSVD (:,:) = YDSPEC%SVD (:,:)
      IF (YRDYNA%LNHX) YDCTX%RSPNHX (:,:) = YDSPEC%NHX (:,:)
    
! Scaling
      CALL SPNH_CONV_NHVAR(YDGEOMETRY,YDML_GCONF,.TRUE.,YDSPEC)
    ENDIF
   
    IF (LELAM) THEN
   
      ALLOCATE (YDCTX%RSPU (YDGEOMETRY%YRDIMV%NFLSUR, YDGEOMETRY%YRDIM%NSPEC2),&
              & YDCTX%RSPV (YDGEOMETRY%YRDIMV%NFLSUR, YDGEOMETRY%YRDIM%NSPEC2))
                                                                                                                                 
      WRITE (NULOUT,*)' IOSPECA : VOR,DIV + MEAN U,V --> U.GEO,V.GEO '
   
      CALL EVDUVGEO (YDGEOMETRY, YDSPEC%VOR, YDSPEC%DIV, YDSPEC%UB, YDSPEC%VB, YDCTX%RSPU, YDCTX%RSPV)
   
    ENDIF

  CASE (NSPECACT_READ,NSPECACT_READ_GP)

    IF (LELAM) THEN
   
      ALLOCATE (YDCTX%RSPU (YDGEOMETRY%YRDIMV%NFLSUR, YDGEOMETRY%YRDIM%NSPEC2),&
              & YDCTX%RSPV (YDGEOMETRY%YRDIMV%NFLSUR, YDGEOMETRY%YRDIM%NSPEC2))

    ENDIF

END SELECT

END ASSOCIATE
END ASSOCIATE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_START',1,ZHOOK_HANDLE)

END SUBROUTINE IOSPECA_START

SUBROUTINE IOSPECA_COUNT(YDGEOMETRY,YDML_GCONF,KACTION,KFNUM,LDINOR,K3DINI,YDMCUF)

USE MODEL_GENERAL_CONF_MOD , ONLY : MODEL_GENERAL_CONF_TYPE
USE GEOMETRY_MOD           , ONLY : GEOMETRY
USE YOMMCUF                , ONLY : TMCUF
USE YOMDYNA                , ONLY : YRDYNA

TYPE (GEOMETRY),     INTENT (IN)           :: YDGEOMETRY
TYPE(MODEL_GENERAL_CONF_TYPE),INTENT(IN)   :: YDML_GCONF
INTEGER (KIND=JPIM), INTENT (IN)           :: KACTION
INTEGER (KIND=JPIM), INTENT (OUT)          :: KFNUM
LOGICAL,             INTENT (IN), OPTIONAL :: LDINOR
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL :: K3DINI
TYPE (TMCUF),        INTENT (IN), OPTIONAL :: YDMCUF

INTEGER (KIND=JPIM) :: JGFL
INTEGER (KIND=JPIM) :: I3DINI
LOGICAL :: LLINOR
INTEGER(KIND=JPIM)  :: INCUFNR
REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_COUNT',0,ZHOOK_HANDLE)

LLINOR = .TRUE.
IF (PRESENT (LDINOR)) LLINOR = LDINOR

I3DINI = 0
IF (PRESENT (K3DINI)) I3DINI = K3DINI

IF (PRESENT (YDMCUF)) THEN
  SELECT CASE (KACTION)
    CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP)
      INCUFNR = YDMCUF%NCUFNR
    CASE (NSPECACT_READ,NSPECACT_READ_GP)
      IF (YDMCUF%LREACUF) THEN
        INCUFNR = YDMCUF%NCUFNR
      ELSE
        INCUFNR = 0
      ENDIF
  END SELECT 
ELSE
  INCUFNR = 0
ENDIF


KFNUM = 0
! Orography :
IF (LLINOR) THEN
  KFNUM = KFNUM + 1
ENDIF

! Ps and 3D fields :
IF (I3DINI == 0) THEN 
  KFNUM = KFNUM + 1 + YDML_GCONF%YRDIMF%NF3D * YDGEOMETRY%YRDIMV%NFLEVG + INCUFNR
ENDIF

! Take out the "X" part of divergence when set
IF (YRDYNA%LNHX) THEN
  KFNUM = KFNUM - YDGEOMETRY%YRDIMV%NFLEVG
ENDIF

! Remore Spectral GFL not Required in output
DO JGFL = 1, YDML_GCONF%YGFL%NUMFLDS
  IF (YDML_GCONF%YGFL%YCOMP(JGFL)%LSP) THEN
    SELECT CASE (KACTION)
      CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP) 
        IF (.NOT. YDML_GCONF%YGFL%YCOMP(JGFL)%LREQOUT) KFNUM = KFNUM - YDGEOMETRY%YRDIMV%NFLEVG
      CASE (NSPECACT_READ,NSPECACT_READ_GP)
        IF (YDML_GCONF%YGFL%YCOMP(JGFL)%NREQIN /= 1) KFNUM = KFNUM - YDGEOMETRY%YRDIMV%NFLEVG
    END SELECT
  ENDIF
ENDDO

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_COUNT',1,ZHOOK_HANDLE)

END SUBROUTINE IOSPECA_COUNT

SUBROUTINE IOSPECA_FINISH (YDGEOMETRY, KACTION, YDCTX,YDSPEC)

USE GEOMETRY_MOD, ONLY : GEOMETRY
USE YOMLUN      , ONLY : NULOUT 
USE YOMCT0      , ONLY : LELAM, LSPRT, LNHDYN
USE YOMDYNA     , ONLY : YRDYNA

TYPE (GEOMETRY),       INTENT (IN)    :: YDGEOMETRY
INTEGER (KIND=JPIM),   INTENT (IN)    :: KACTION
TYPE (IOSPECA_CTX),    INTENT (INOUT) :: YDCTX
TYPE (SPECTRAL_FIELD), INTENT (INOUT) :: YDSPEC

#include "euvgeovd.intfb.h"

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_FINISH',0,ZHOOK_HANDLE)

SELECT CASE (KACTION)

  CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP)

    IF (LELAM) DEALLOCATE (YDCTX%RSPU, YDCTX%RSPV)
    
! Restore Tv in spectral arrays
    
    IF (LSPRT) THEN
      YDSPEC%T (1:YDGEOMETRY%YRDIMV%NFLSUR,1:YDGEOMETRY%YRDIM%NSPEC2) = &
     & YDCTX%RSPT (1:YDGEOMETRY%YRDIMV%NFLSUR,1:YDGEOMETRY%YRDIM%NSPEC2)
      DEALLOCATE (YDCTX%RSPT)
    ENDIF
    
! Restore NH model variables in spectral arrays
    
    IF (LNHDYN) THEN
      YDSPEC%SPD (:,:) = YDCTX%RSPSPD (:,:)
      YDSPEC%SVD (:,:) = YDCTX%RSPSVD (:,:)
      IF (YRDYNA%LNHX) YDSPEC%NHX (:,:) = YDCTX%RSPNHX (:,:)
    
      DEALLOCATE (YDCTX%RSPSPD)
      DEALLOCATE (YDCTX%RSPSVD)
      IF (YRDYNA%LNHX) DEALLOCATE (YDCTX%RSPNHX)
    ENDIF

  CASE (NSPECACT_READ,NSPECACT_READ_GP)

    IF (LELAM) THEN
      WRITE (NULOUT,*)' IOSPECA_FINISH : U.GEO,V.GEO --> VOR,DIV + MEAN U,V '
      CALL EUVGEOVD (YDGEOMETRY, YDCTX%RSPU, YDCTX%RSPV, YDSPEC%VOR, YDSPEC%DIV, YDSPEC%UB, YDSPEC%VB)
      DEALLOCATE (YDCTX%RSPU, YDCTX%RSPV)
    ENDIF

END SELECT

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_FINISH',1,ZHOOK_HANDLE)

END SUBROUTINE IOSPECA_FINISH

SUBROUTINE IOSPECA_SELECTFX(YDGEOMETRY,YGFL,YDDYN,KACTION,YDCTX,KFLD,KFLOFF,KSPOFF,YDFLDSC,PSPBUF,YDSPEC,YDMCUF)

USE YOMDYN      , ONLY : TDYN
USE YOM_YGFL    , ONLY : TYPE_GFLD
USE GEOMETRY_MOD, ONLY : GEOMETRY
USE YOMMCUF      , ONLY : TMCUF
TYPE (GEOMETRY)     ,INTENT (IN)    :: YDGEOMETRY
TYPE(TDYN)          ,INTENT (IN)    :: YDDYN
TYPE(TYPE_GFLD)     ,INTENT (IN)    :: YGFL
INTEGER (KIND=JPIM) ,INTENT (IN)    :: KACTION
TYPE (IOSPECA_CTX)  ,INTENT (INOUT) :: YDCTX
INTEGER (KIND=JPIM) ,INTENT (IN)    :: KFLD
INTEGER (KIND=JPIM) ,INTENT (IN)    :: KFLOFF
INTEGER (KIND=JPIM) ,INTENT (IN)    :: KSPOFF
TYPE (IOFLDDESC)    ,INTENT (IN)    :: YDFLDSC (:)
REAL (KIND=JPRB)    ,INTENT (INOUT), TARGET :: PSPBUF (:,:)
TYPE(SPECTRAL_FIELD),INTENT (INOUT) :: YDSPEC
TYPE(TMCUF)         ,INTENT (INOUT), OPTIONAL :: YDMCUF

TYPE (IOMULTIBUF) :: YLSPBUF (1)

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_SELECTFX',0,ZHOOK_HANDLE)

YLSPBUF(1)%P => PSPBUF

CALL IOSPECA_SELECTFY(YDGEOMETRY,YGFL,YDDYN,KACTION,YDCTX,KFLD,KFLOFF,KSPOFF,YDFLDSC,YLSPBUF,YDSPEC,YDMCUF)

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_SELECTFX',1,ZHOOK_HANDLE)

END SUBROUTINE IOSPECA_SELECTFX

SUBROUTINE IOSPECA_SELECTFY(YDGEOMETRY,YGFL,YDDYN,KACTION,YDCTX,KFLD,KFLOFF,KSPOFF,YDFLDSC,YDSPBUF,YDSPEC,YDMCUF)

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE YOMLUN       , ONLY : NULOUT 
USE YOMCT0       , ONLY : LELAM, NCONF
USE YOMMP0       , ONLY : NPRTRV
USE YOMDYN       , ONLY : TDYN
USE YOMFA        , ONLY : YFAPSI, YFAKHI, YFAT, YFAPD, YFAVD, YFASP, YFAUGEO, YFAOROG, &
 &                        YFAVGEO, YFAFSP1, YFAFSP2, YFAFSP3, YFAFSP4, YFAFSP5 
USE YOMVAR       , ONLY : LTWGRA
USE YOMSENS      , ONLY : LGRVOL
USE YOM_YGFL     , ONLY : TYPE_GFLD
USE YOMSP5       , ONLY : SPA5
USE YOMMCUF      , ONLY : TMCUF 

TYPE (GEOMETRY),      INTENT (IN)    :: YDGEOMETRY
TYPE(TDYN)           ,INTENT (IN)    :: YDDYN
TYPE(TYPE_GFLD)      ,INTENT (IN)    :: YGFL
INTEGER (KIND=JPIM),  INTENT (IN)    :: KACTION
TYPE (IOSPECA_CTX),   INTENT (INOUT) :: YDCTX
INTEGER (KIND=JPIM),  INTENT (IN)    :: KFLD          ! Number of fields on this proc
INTEGER (KIND=JPIM),  INTENT (IN)    :: KFLOFF        ! Offset in the list of global fields
INTEGER (KIND=JPIM),  INTENT (IN)    :: KSPOFF        ! Offset in spectral buffer
TYPE (IOFLDDESC),     INTENT (IN)    :: YDFLDSC (:)   ! Field descriptors, size = total number of fields, over all procs
TYPE (IOMULTIBUF),    INTENT (INOUT) :: YDSPBUF (:)   ! Buffer list; may be spectral/grid point, global/local
TYPE(SPECTRAL_FIELD), INTENT(INOUT), TARGET :: YDSPEC
TYPE(TMCUF),          INTENT (INOUT),OPTIONAL :: YDMCUF

#include "esperee.intfb.h"
#include "speree.intfb.h"
#include "reespe.intfb.h"
#include "ereespe.intfb.h"
#include "abor1.intfb.h"

REAL (KIND=JPRB), POINTER :: &
          & ZSPVOR (:,:), ZSPDIV (:,:), ZSPT(:,:), ZSPGFL (:,:,:), ZSPSP (:), &
          & ZSPOR (:), ZSPSPD (:,:), ZSPSVD (:,:)

REAL(KIND=JPRB), ALLOCATABLE :: ZSPBUFTSP(:), ZGDSP(:), ZGD5SP(:) ! NSPEC2,number of fields
REAL(KIND=JPRB) :: ZWGHT(YDGEOMETRY%YRDIMV%NFLEVL)
INTEGER (KIND=JPIM) :: JFLD, IFLDG, JGFL, JSP, IFLD
INTEGER (KIND=JPIM) :: ISPBUFY, JSPBUFY
REAL (KIND=JPRB) :: ZTMP
REAL (KIND=JPRB), POINTER :: ZSPBUF (:,:)
LOGICAL :: LLGP
INTEGER(KIND=JPIM)  :: INCUFNR

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_SELECTFY',0,ZHOOK_HANDLE)
!

LLGP = (KACTION == NSPECACT_WRITE_GP) .OR. (KACTION == NSPECACT_READ_GP)

ZSPBUF => NULL ()

IF (LLGP) THEN

  IF (SIZE (YDSPBUF) > 1)&
    & CALL ABOR1 ('IOSPECA_MOD:IOSPECA_SELECTFY: NSPECACT_WRITE_GP IS ONLY POSSIBLE WITH A SIMPLE BUFFER')
  ZSPBUF => YDSPBUF(1)%P

  IFLD = SIZE (ZSPBUF, 1)

ELSE

! Check number of fields

  CALL IOMULTIBUF_SIZE_IDX (YDSPBUF, IFLD)

ENDIF

IF (IFLD /= KFLD) THEN
  WRITE (NULOUT, *) "IOSPECA_SELECTFY: IFLD = ", IFLD, " KFLD = ", KFLD
  CALL ABOR1 ('IOSPECA_SELECTFY: FIELD NUMBER MISMATCH')
ENDIF

! Setup pointers; default is model state

ZSPVOR => YDSPEC%VOR
ZSPDIV => YDSPEC%DIV
ZSPT   => YDSPEC%T  
ZSPGFL => YDSPEC%GFL
ZSPSP  => YDSPEC%SP 
ZSPOR  => YDSPEC%OROG 
ZSPSPD => YDSPEC%SPD
ZSPSVD => YDSPEC%SVD

IF (PRESENT (YDMCUF)) THEN
  SELECT CASE (KACTION)
    CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP)
      INCUFNR = YDMCUF%NCUFNR
    CASE (NSPECACT_READ,NSPECACT_READ_GP)
      IF (YDMCUF%LREACUF) THEN
        INCUFNR = YDMCUF%NCUFNR
      ELSE
        INCUFNR = 0
      ENDIF
  END SELECT 
ELSE
  INCUFNR = 0
ENDIF

! Init iterator

IF (.NOT. LLGP)&
  & CALL IOMULTIBUF_INIT_IDX (YDSPBUF, ISPBUFY, JSPBUFY)

DO JFLD = 1, KFLD

! Increment field index

  IF (.NOT. LLGP)&
    & CALL IOMULTIBUF_INCR_IDX (YDSPBUF, ISPBUFY, JSPBUFY)

  IFLDG=KFLOFF+JFLD

  IF (YDFLDSC(IFLDG)%CSUFF == YFAOROG%CLNAME(5:)) THEN
!   Orography :
      IF (SIZE (YDSPEC%SP2D, 2) > 1) THEN
        CALL ACPY (ZSPOR)
      ENDIF

  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFASP%CLNAME(5:)) THEN

    SELECT CASE (KACTION)

      CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP) 

! Surface pressure :
        IF (LTWGRA) THEN
! Write gradient w.r.t. surface pressure dJ/dps=dJ/(ps.dLogps)
          WRITE(NULOUT,*) ' CONVERTING GRAD/LOGSP INTO GRAD/SP'
          ALLOCATE(ZSPBUFTSP(YDGEOMETRY%YRDIM%NSPEC2),ZGDSP(YDGEOMETRY%YRGEM%NGPTOT),ZGD5SP(YDGEOMETRY%YRGEM%NGPTOT))
          ZSPBUFTSP(1:YDGEOMETRY%YRDIM%NSPEC2)=ZSPSP(1:YDGEOMETRY%YRDIM%NSPEC2)
          IF (LELAM) THEN
            CALL ESPEREE (YDGEOMETRY, 1, 1, ZSPBUFTSP, ZGDSP)
          ELSE
            CALL SPEREE (YDGEOMETRY, 1, 1, ZSPBUFTSP, ZGDSP)
          ENDIF
          IF (NCONF/100 /= 1) THEN
            ZSPBUFTSP(1:YDGEOMETRY%YRDIM%NSPEC2)=SPA5%SP(1:YDGEOMETRY%YRDIM%NSPEC2)
            IF (LELAM) THEN
              CALL ESPEREE (YDGEOMETRY, 1,1, ZSPBUFTSP, ZGD5SP)
            ELSE
              CALL SPEREE (YDGEOMETRY, 1, 1, ZSPBUFTSP, ZGD5SP)
            ENDIF
          ELSE
! In variational, SP5SP is corrupted by COSJC and COSJG
! Use approximate Ps=1015hPa
!           ZGD5SP(1:YDGEOMETRY%YRGEM%NGPTOT)=LOG(YRVAB%VP00)
          ENDIF
          ZGDSP(1:YDGEOMETRY%YRGEM%NGPTOT)=ZGDSP(1:YDGEOMETRY%YRGEM%NGPTOT)/EXP(ZGD5SP(1:YDGEOMETRY%YRGEM%NGPTOT))
          IF (LELAM) THEN
            CALL EREESPE(YDGEOMETRY, 1,1,ZSPBUFTSP,ZGDSP)
          ELSE
            CALL REESPE(YDGEOMETRY, 1,1,ZSPBUFTSP,ZGDSP)
          ENDIF
          CALL ACPY (ZSPBUFTSP)
          DEALLOCATE(ZSPBUFTSP,ZGDSP,ZGD5SP)
        ELSE
          CALL ACPY (ZSPSP)
        ENDIF

      CASE (NSPECACT_READ,NSPECACT_READ_GP)

        CALL ACPY (ZSPSP)

    END SELECT


  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAFSP1%CLNAME(5:) .AND. INCUFNR >=1) THEN
!   Filtered ln Ps nr 1 for monitoring the coupling updates 
    CALL ACPY (YDMCUF%RMCUFFP (:,0,1))
  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAFSP2%CLNAME(5:) .AND. INCUFNR >=2) THEN
!   Filtered ln Ps nr 2 for monitoring the coupling updates 
    CALL ACPY (YDMCUF%RMCUFFP (:,0,2))
  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAFSP3%CLNAME(5:) .AND. INCUFNR >=3) THEN
!   Filtered ln Ps nr 3 for monitoring the coupling updates 
    CALL ACPY (YDMCUF%RMCUFFP (:,0,3))
  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAFSP4%CLNAME(5:) .AND. INCUFNR >=4) THEN
!   Filtered ln Ps nr 4 for monitoring the coupling updates 
    CALL ACPY (YDMCUF%RMCUFFP (:,0,4))
  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAFSP5%CLNAME(5:) .AND. INCUFNR >=5) THEN
!   Filtered ln Ps nr 5 for monitoring the coupling updates 
    CALL ACPY (YDMCUF%RMCUFFP (:,0,5))
  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAUGEO%CLNAME(1:12)) THEN
!   Wind/x momentum
    CALL ACPY (YDCTX%RSPU (YDFLDSC(IFLDG)%ILEVL,:))
  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAVGEO%CLNAME(1:12)) THEN
!   Wind/y momentum :
    CALL ACPY (YDCTX%RSPV (YDFLDSC(IFLDG)%ILEVL,:))
  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAPSI%CLNAME(1:12)) THEN
! Psi : 

    SELECT CASE (KACTION)

      CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP)

        IF (LTWGRA) THEN

          IF (LGRVOL) THEN
            ZWGHT(1:YDGEOMETRY%YRDIMV%NFLEVL)=1.0_JPRB/YDDYN%SIDELP(YDGEOMETRY%YRMP%MYLEVS(1:YDGEOMETRY%YRDIMV%NFLEVL))
          ELSE
            ZWGHT(1:YDGEOMETRY%YRDIMV%NFLEVL)=1.0_JPRB
          ENDIF

          DO JSP=1,YDGEOMETRY%YRDIM%NSPEC2
            ZTMP = ZSPDIV(YDFLDSC(IFLDG)%ILEVL,JSP)*YDGEOMETRY%YRLAP%RLAPDI(YDGEOMETRY%YRLAP%NVALUE(JSP))&
                 & *ZWGHT(YDFLDSC(IFLDG)%ILEVL)
            IF (LLGP) THEN
              ZSPBUF (JFLD, JSP+KSPOFF) = ZTMP
            ELSE
              YDSPBUF(ISPBUFY)%P(JSP+KSPOFF,JSPBUFY) = ZTMP
            ENDIF
          ENDDO

        ELSE

          DO JSP=1,YDGEOMETRY%YRDIM%NSPEC2
            ZTMP = ZSPDIV(YDFLDSC(IFLDG)%ILEVL,JSP)*YDGEOMETRY%YRLAP%RLAPIN(YDGEOMETRY%YRLAP%NVALUE(JSP))
            IF (LLGP) THEN
              ZSPBUF (JFLD, JSP+KSPOFF) = ZTMP
            ELSE
              YDSPBUF(ISPBUFY)%P(JSP+KSPOFF,JSPBUFY) = ZTMP
            ENDIF
          ENDDO

        ENDIF

      CASE (NSPECACT_READ,NSPECACT_READ_GP)

        DO JSP=1,YDGEOMETRY%YRDIM%NSPEC2
          IF (LLGP) THEN
            ZTMP = ZSPBUF (JFLD, JSP+KSPOFF)
          ELSE
            ZTMP = YDSPBUF(ISPBUFY)%P(JSP+KSPOFF,JSPBUFY)
          ENDIF
          ZSPDIV(YDFLDSC(IFLDG)%ILEVL,JSP)= ZTMP * YDGEOMETRY%YRLAP%RLAPDI(YDGEOMETRY%YRLAP%NVALUE(JSP))
        ENDDO

    END SELECT

  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAKHI%CLNAME(1:12)) THEN
! Khi :

    SELECT CASE (KACTION)
    
      CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP)

        DO JSP=1,YDGEOMETRY%YRDIM%NSPEC2
          ZTMP = ZSPVOR(YDFLDSC(IFLDG)%ILEVL,JSP)*YDGEOMETRY%YRLAP%RLAPIN(YDGEOMETRY%YRLAP%NVALUE(JSP))  
          IF (LLGP) THEN
            ZSPBUF (JFLD, JSP+KSPOFF) = ZTMP
          ELSE
            YDSPBUF(ISPBUFY)%P(JSP+KSPOFF,JSPBUFY) = ZTMP
          ENDIF
        ENDDO

      CASE (NSPECACT_READ,NSPECACT_READ_GP)

        DO JSP=1,YDGEOMETRY%YRDIM%NSPEC2
          IF (LLGP) THEN
            ZTMP = ZSPBUF (JFLD, JSP+KSPOFF)
          ELSE
            ZTMP = YDSPBUF(ISPBUFY)%P(JSP+KSPOFF,JSPBUFY)
          ENDIF
          YDSPEC%VOR(YDFLDSC(IFLDG)%ILEVL,JSP)= ZTMP * YDGEOMETRY%YRLAP%RLAPDI(YDGEOMETRY%YRLAP%NVALUE(JSP))
        ENDDO

    END SELECT

  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAT%CLNAME(1:12)) THEN
!   Temperature :
    CALL ACPY (ZSPT (YDFLDSC(IFLDG)%ILEVL,:))
  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAPD%CLNAME(1:12)) THEN
!   NH Pressure departure :
    CALL ACPY (ZSPSPD (YDFLDSC(IFLDG)%ILEVL,:))
  ELSEIF (YDFLDSC(IFLDG)%CSUFF == YFAVD%CLNAME(1:12)) THEN
!   NH vertical divergence :
    CALL ACPY (ZSPSVD (YDFLDSC(IFLDG)%ILEVL,:))
  ELSE
!   Other prognostic variables :

    DO JGFL = 1, YGFL%NUMFLDS

      IF (YGFL%YCOMP(JGFL)%LSP .AND. (YDFLDSC(IFLDG)%CSUFF == YGFL%YCOMP(JGFL)%CNAME(1:12))) THEN

        SELECT CASE (KACTION)
        
          CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP) 

            CALL ACPY (ZSPGFL (YDFLDSC(IFLDG)%ILEVL,:,YGFL%YCOMP(JGFL)%MPSP))

          CASE (NSPECACT_READ,NSPECACT_READ_GP)

            IF (YGFL%YCOMP (JGFL)%NREQIN == 1)&
              & CALL ACPY (ZSPGFL (YDFLDSC(IFLDG)%ILEVL,:,YGFL%YCOMP(JGFL)%MPSP))

        END SELECT

      ENDIF

    ENDDO

  ENDIF

ENDDO

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_SELECTFY',1,ZHOOK_HANDLE)

CONTAINS

SUBROUTINE ACPY (PSPEC)

REAL (KIND=JPRB), INTENT (INOUT) :: PSPEC (:)
INTEGER (KIND=JPIM) :: ISP

REAL (KIND=JPRB) :: ZHOOK_HANDLE

#define LHOOK .FALSE.
IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:ACPY',0,ZHOOK_HANDLE)

SELECT CASE (KACTION)

  CASE (NSPECACT_READ)

    DO ISP = 1, YDGEOMETRY%YRDIM%NSPEC2
      PSPEC (ISP) = YDSPBUF(ISPBUFY)%P(ISP+KSPOFF,JSPBUFY)
    ENDDO

  CASE (NSPECACT_READ_GP)

    DO ISP = 1, YDGEOMETRY%YRDIM%NSPEC2
      PSPEC (ISP) = ZSPBUF (JFLD, ISP+KSPOFF)
    ENDDO

  CASE (NSPECACT_WRITE)

    DO ISP = 1, YDGEOMETRY%YRDIM%NSPEC2
      YDSPBUF(ISPBUFY)%P(ISP+KSPOFF,JSPBUFY) = PSPEC (ISP)
    ENDDO

  CASE (NSPECACT_WRITE_GP)

    DO ISP = 1, YDGEOMETRY%YRDIM%NSPEC2
      ZSPBUF (JFLD, ISP+KSPOFF) = PSPEC (ISP)
    ENDDO

  CASE DEFAULT

    CALL ABOR1 ('IOSPECA_MOD: UNEXPECTED KACTION')

END SELECT 

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:ACPY',1,ZHOOK_HANDLE)
#undef LHOOK

END SUBROUTINE ACPY

END SUBROUTINE IOSPECA_SELECTFY

SUBROUTINE IOSPECA_FLDSORT (YDFLDSC)

TYPE (IOFLDDESC),    INTENT (INOUT) :: YDFLDSC (:)

INTEGER (KIND=JPIM) :: I, JFLD, JFLD1, JFLD2
INTEGER (KIND=JPIM) :: IFLDSPG, IFLEVG
INTEGER (KIND=JPIM) :: ILEVP10, ILEVL10
INTEGER (KIND=JPIM) :: ILEVG (SIZE (YDFLDSC))
LOGICAL :: LLEQ

INTEGER (KIND=JPIM) :: IKEY (SIZE (YDFLDSC))
INTEGER (KIND=JPIM) :: IORD (SIZE (YDFLDSC))

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('IOSPECA_MOD:IOSPECA_FLDSORT',0,ZHOOK_HANDLE)

IFLDSPG = SIZE (YDFLDSC)

! Number of digits in level index

IFLEVG = MAXVAL (YDFLDSC%ILEVG)

ILEVL10 = INT (LOG10 (REAL (IFLEVG))+1)
ILEVP10 = 1
DO I = 1, ILEVL10
  ILEVP10 = 10 * ILEVP10
ENDDO
 
!!! sort by KVSET,KLEVG in a single shot
!!! force surface fields to be at the end of sorted list
!!! removed !!!

!WHERE (YDFLDSC%ILEVG > 0)
  ILEVG = YDFLDSC%ILEVG
!ELSEWHERE
!  ILEVG = IFLEVG+1
!ENDWHERE

IKEY = YDFLDSC%IVSET * ILEVP10 + ILEVG
CALL QSORTI4 (IFLDSPG, IORD, IKEY)

YDFLDSC = YDFLDSC(IORD)

! sort by CDSUFF within homogeneous sets of KVSET,KLEVG

JFLD1 = 1
JFLD2 = 1
DO JFLD = 1, IFLDSPG
  
  LLEQ = (YDFLDSC(JFLD1)%IVSET  == YDFLDSC(JFLD)%IVSET ) .AND. (YDFLDSC(JFLD1)%ILEVG  == YDFLDSC(JFLD)%ILEVG )

  IF (LLEQ) THEN
    JFLD2 = JFLD
  ENDIF

  IF ((.NOT. LLEQ) .OR. (JFLD == IFLDSPG)) THEN
    CALL QSORTC (JFLD2-JFLD1+1, IORD (JFLD1:JFLD2), YDFLDSC(JFLD1:JFLD2)%CSUFF )
    IORD (JFLD1:JFLD2) = IORD (JFLD1:JFLD2) + JFLD1-1
  ENDIF

  IF (.NOT. LLEQ) THEN
    JFLD1 = JFLD
    JFLD2 = JFLD
  ENDIF

ENDDO

YDFLDSC = YDFLDSC(IORD)

IF (LHOOK) CALL DR_HOOK('IOSPECA_MOD:IOSPECA_FLDSORT',1,ZHOOK_HANDLE)

END SUBROUTINE IOSPECA_FLDSORT

SUBROUTINE IOSPECA_SELECTD(YDGEOMETRY,YDML_GCONF,KACTION,YDFLDSC,LDINOR,K3DINI,YDMCUF)

USE MODEL_GENERAL_CONF_MOD , ONLY : MODEL_GENERAL_CONF_TYPE
USE GEOMETRY_MOD           , ONLY : GEOMETRY
USE YOMLUN                 , ONLY : NULOUT 
USE YOMCT0                 , ONLY : LNHDYN, LELAM
USE YOMMP0                 , ONLY : NPRTRV
USE YOMFA                  , ONLY : YFAPSI, YFAKHI, YFAT, YFAPD, YFAVD, YFASP, YFAUGEO, YFAOROG, &
                                  & YFAVGEO, YFAFSP1, YFAFSP2, YFAFSP3, YFAFSP4, YFAFSP5, NVGRIB, NBITCS
USE YOMMCUF                , ONLY : TMCUF 
USE YOMOPH0                , ONLY : CNMCA
USE FA_MOD                 , ONLY : JPPRCM


TYPE (GEOMETRY),     INTENT (IN)    :: YDGEOMETRY
TYPE (TMCUF),OPTIONAL,INTENT (IN):: YDMCUF
TYPE(MODEL_GENERAL_CONF_TYPE),INTENT(IN):: YDML_GCONF
INTEGER (KIND=JPIM), INTENT (IN)    :: KACTION
TYPE (IOFLDDESC),    INTENT (OUT)   :: YDFLDSC (:)
LOGICAL,             INTENT (IN), OPTIONAL :: LDINOR
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL :: K3DINI

#include "abor1.intfb.h"

INTEGER (KIND=JPIM) :: IPT
INTEGER (KIND=JPIM) :: IFLDSPG
INTEGER (KIND=JPIM) :: JFLD
INTEGER (KIND=JPIM) :: JGFL
INTEGER (KIND=JPIM) :: I3DINI
LOGICAL             :: LLINOR
LOGICAL             :: LLREQ
INTEGER (KIND=JPIM) :: INCUFNR
INTEGER (KIND=JPIM) :: IREP, IPFAOVSZ

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_SELECTD',0,ZHOOK_HANDLE)

LLINOR = .TRUE.
IF (PRESENT (LDINOR)) LLINOR = LDINOR

I3DINI = 0
IF (PRESENT (K3DINI)) I3DINI = K3DINI

IF (PRESENT (YDMCUF)) THEN
  SELECT CASE (KACTION)
    CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP)
      INCUFNR = YDMCUF%NCUFNR
    CASE (NSPECACT_READ,NSPECACT_READ_GP)
      IF (YDMCUF%LREACUF) THEN
        INCUFNR = YDMCUF%NCUFNR
      ELSE
        INCUFNR = 0
      ENDIF
    CASE DEFAULT
      CALL ABOR1 ('IOSPECA_MOD: UNEXPECTED KACTION')
  END SELECT 
ELSE
  INCUFNR = 0
ENDIF

CALL FASGRA (IREP, CNMCA, IPFAOVSZ)

IFLDSPG = SIZE (YDFLDSC)

YDFLDSC%NFLSZ  = YDGEOMETRY%YRDIM%NSPEC2G
YDFLDSC%NSIZPK = YDGEOMETRY%YRDIM%NSPEC2G + JPPRCM * IPFAOVSZ
YDFLDSC%NGRIBL = NVGRIB
YDFLDSC%JBITS  = NBITCS

IPT=0

! Orography :
IF (LLINOR) THEN
  IPT=IPT+1
  YDFLDSC(IPT)%CPREF = YFAOROG%CLNAME(1:4)
  YDFLDSC(IPT)%CSUFF = YFAOROG%CLNAME(5:)
  YDFLDSC(IPT)%ILEVG = 0
  YDFLDSC(IPT)%ILEVL = 0
  YDFLDSC(IPT)%IVSET = YDGEOMETRY%YRMP%NBSETSP
! Field should not be packed
  YDFLDSC(IPT)%JBITS = 64
ENDIF

! Ps and 3D fields :
IF (I3DINI == 0) THEN
  IPT=IPT+1
  YDFLDSC(IPT)%CPREF=YFASP%CLNAME(1:4)
  YDFLDSC(IPT)%ILEVG=0
  YDFLDSC(IPT)%ILEVL=0
  YDFLDSC(IPT)%CSUFF=YFASP%CLNAME(5:)
  YDFLDSC(IPT)%IVSET=YDGEOMETRY%YRMP%NBSETSP

  CALL IBCPY (YFASP, YDFLDSC (IPT:IPT))

  IF (INCUFNR>=1) THEN
    IPT=IPT+1
    YDFLDSC(IPT)%CPREF=YFAFSP1%CLNAME(1:4)
    YDFLDSC(IPT)%ILEVG=0
    YDFLDSC(IPT)%ILEVL=0
    YDFLDSC(IPT)%CSUFF=YFAFSP1%CLNAME(5:)
    YDFLDSC(IPT)%IVSET=YDGEOMETRY%YRMP%NBSETSP
    CALL IBCPY (YFAFSP1, YDFLDSC (IPT:IPT))
  ENDIF
  IF (INCUFNR>=2) THEN
    IPT=IPT+1
    YDFLDSC(IPT)%CPREF=YFAFSP2%CLNAME(1:4)
    YDFLDSC(IPT)%ILEVG=0
    YDFLDSC(IPT)%ILEVL=0
    YDFLDSC(IPT)%CSUFF=YFAFSP2%CLNAME(5:)
    YDFLDSC(IPT)%IVSET=YDGEOMETRY%YRMP%NBSETSP
    CALL IBCPY (YFAFSP2, YDFLDSC (IPT:IPT))
  ENDIF
  IF (INCUFNR>=3) THEN
    IPT=IPT+1
    YDFLDSC(IPT)%CPREF=YFAFSP3%CLNAME(1:4)
    YDFLDSC(IPT)%ILEVG=0
    YDFLDSC(IPT)%ILEVL=0
    YDFLDSC(IPT)%CSUFF=YFAFSP3%CLNAME(5:)
    YDFLDSC(IPT)%IVSET=YDGEOMETRY%YRMP%NBSETSP
    CALL IBCPY (YFAFSP3, YDFLDSC (IPT:IPT))
  ENDIF
  IF (INCUFNR>=4) THEN
    IPT=IPT+1
    YDFLDSC(IPT)%CPREF=YFAFSP4%CLNAME(1:4)
    YDFLDSC(IPT)%ILEVG=0
    YDFLDSC(IPT)%ILEVL=0
    YDFLDSC(IPT)%CSUFF=YFAFSP4%CLNAME(5:)
    YDFLDSC(IPT)%IVSET=YDGEOMETRY%YRMP%NBSETSP
    CALL IBCPY (YFAFSP4, YDFLDSC (IPT:IPT))
  ENDIF
  IF (INCUFNR>=5) THEN
    IPT=IPT+1
    YDFLDSC(IPT)%CPREF=YFAFSP5%CLNAME(1:4)
    YDFLDSC(IPT)%ILEVG=0
    YDFLDSC(IPT)%ILEVL=0
    YDFLDSC(IPT)%CSUFF=YFAFSP5%CLNAME(5:)
    YDFLDSC(IPT)%IVSET=YDGEOMETRY%YRMP%NBSETSP
    CALL IBCPY (YFAFSP5, YDFLDSC (IPT:IPT))
  ENDIF
  IF (YDML_GCONF%YRDIMF%NF3D > 0) THEN
    YDFLDSC(IPT+1:)%CPREF='S   '
    DO JFLD=IPT+1, IFLDSPG
      YDFLDSC(JFLD)%ILEVG  = MOD(JFLD-(IPT+1),YDGEOMETRY%YRDIMV%NFLEVG) + 1
      YDFLDSC(JFLD)%IVSET  = YDGEOMETRY%YRMP%NBSETLEV(YDFLDSC(JFLD)%ILEVG)
      YDFLDSC(JFLD)%ILEVL  = YDFLDSC(JFLD)%ILEVG-YDGEOMETRY%YRMP%NPTRLL(YDFLDSC(JFLD)%IVSET)+1 
    ENDDO 
!   Psi & Khi or U & V :
    IF (LELAM) THEN
      YDFLDSC(IPT+1:IPT+YDGEOMETRY%YRDIMV%NFLEVG)%CSUFF=YFAUGEO%CLNAME(1:12)
      YDFLDSC(IPT+YDGEOMETRY%YRDIMV%NFLEVG+1:IPT+2*YDGEOMETRY%YRDIMV%NFLEVG)%CSUFF=YFAVGEO%CLNAME(1:12)
      CALL IBCPY (YFAUGEO, YDFLDSC(IPT+1:IPT+YDGEOMETRY%YRDIMV%NFLEVG))
      CALL IBCPY (YFAVGEO, YDFLDSC(IPT+YDGEOMETRY%YRDIMV%NFLEVG+1:IPT+2*YDGEOMETRY%YRDIMV%NFLEVG))
    ELSE
      YDFLDSC(IPT+1:IPT+YDGEOMETRY%YRDIMV%NFLEVG)%CSUFF=YFAPSI%CLNAME(1:12)
      YDFLDSC(IPT+YDGEOMETRY%YRDIMV%NFLEVG+1:IPT+2*YDGEOMETRY%YRDIMV%NFLEVG)%CSUFF=YFAKHI%CLNAME(1:12)
      CALL IBCPY (YFAPSI, YDFLDSC(IPT+1:IPT+YDGEOMETRY%YRDIMV%NFLEVG))
      CALL IBCPY (YFAKHI, YDFLDSC(IPT+YDGEOMETRY%YRDIMV%NFLEVG+1:IPT+2*YDGEOMETRY%YRDIMV%NFLEVG))
    ENDIF
    IPT=IPT+2*YDGEOMETRY%YRDIMV%NFLEVG
!   Temperature :
    YDFLDSC(IPT+1:IPT+YDGEOMETRY%YRDIMV%NFLEVG)%CSUFF=YFAT%CLNAME(1:12)
    CALL IBCPY (YFAT, YDFLDSC(IPT+1:IPT+YDGEOMETRY%YRDIMV%NFLEVG))
    IPT=IPT+YDGEOMETRY%YRDIMV%NFLEVG
!   Pressure departure & Vertical divergence:
    IF (LNHDYN) THEN
      YDFLDSC(IPT+1:IPT+YDGEOMETRY%YRDIMV%NFLEVG)%CSUFF=YFAPD%CLNAME(1:12)
      YDFLDSC(IPT+YDGEOMETRY%YRDIMV%NFLEVG+1:IPT+2*YDGEOMETRY%YRDIMV%NFLEVG)%CSUFF=YFAVD%CLNAME(1:12)
      CALL IBCPY (YFAPD, YDFLDSC(IPT+1:IPT+YDGEOMETRY%YRDIMV%NFLEVG))
      CALL IBCPY (YFAVD, YDFLDSC(IPT+YDGEOMETRY%YRDIMV%NFLEVG+1:IPT+2*YDGEOMETRY%YRDIMV%NFLEVG))
      IPT=IPT+2*YDGEOMETRY%YRDIMV%NFLEVG
    ENDIF
!   Other prognostic variables :
    DO JGFL=1, YDML_GCONF%YGFL%NUMFLDS
      IF (YDML_GCONF%YGFL%YCOMP(JGFL)%LSP) THEN
        LLREQ = .FALSE.
        SELECT CASE (KACTION)
          CASE (NSPECACT_WRITE,NSPECACT_WRITE_GP)
            LLREQ = YDML_GCONF%YGFL%YCOMP(JGFL)%LREQOUT
          CASE (NSPECACT_READ,NSPECACT_READ_GP)
            LLREQ = YDML_GCONF%YGFL%YCOMP(JGFL)%NREQIN == 1
          CASE DEFAULT
            CALL ABOR1 ('IOSPECA_MOD: UNEXPECTED KACTION')
        END SELECT
        IF (LLREQ) THEN
           YDFLDSC(IPT+1:IPT+YDGEOMETRY%YRDIMV%NFLEVG)%CSUFF=YDML_GCONF%YGFL%YCOMP(JGFL)%CNAME(1:12)
           IPT=IPT+YDGEOMETRY%YRDIMV%NFLEVG
        ENDIF   
      ENDIF
    ENDDO
  ENDIF
ENDIF

YDFLDSC%IOLEV = YDFLDSC%ILEVG + YDGEOMETRY%YRDIMV%NIOLEVG - YDGEOMETRY%YRDIMV%NFLEVG
YDFLDSC%LIOLV = .TRUE.
YDFLDSC%LSPEC = .TRUE.

IF (IPT /= IFLDSPG) THEN
  CALL ABOR1('IOSPECA_SELECTD : FIELDS DESCRIPTORS ARE UNCOMPLETE !')
ENDIF 

CALL IOSPECA_FLDSORT (YDFLDSC)

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_SELECTD',1,ZHOOK_HANDLE)

CONTAINS

SUBROUTINE IBCPY (YDFAD, YDFLDSC)

USE TYPE_FADS, ONLY : FAD

TYPE (FAD),       INTENT (IN)    :: YDFAD
TYPE (IOFLDDESC), INTENT (INOUT) :: YDFLDSC (:)

INTEGER (KIND=JPIM) :: JFLD

IF (YDFAD%NBITS > 0) THEN
  YDFLDSC (:)%JBITS = YDFAD%NBITS
ELSE
  YDFLDSC (:)%JBITS = NBITCS
ENDIF

END SUBROUTINE IBCPY

END SUBROUTINE IOSPECA_SELECTD

SUBROUTINE IOSPECA_FLDDESC_SP2GP (YDGEOMETRY, YDFLDSC_SP, YDFLDSC_GP, LDRNONLY)

USE GEOMETRY_MOD, ONLY : GEOMETRY
USE YOMFA       , ONLY : YFAOROG
USE YOMOPH0     , ONLY : CNMCA
USE FA_MOD      , ONLY : JPPRCM

TYPE (GEOMETRY),   INTENT (IN)    :: YDGEOMETRY
TYPE (IOFLDDESC),  INTENT (IN)    :: YDFLDSC_SP (:)
TYPE (IOFLDDESC),  INTENT (INOUT) :: YDFLDSC_GP (:)
LOGICAL, OPTIONAL, INTENT (IN)    :: LDRNONLY

INTEGER (KIND=JPIM) :: IFNUM
INTEGER (KIND=JPIM) :: JFLD
LOGICAL             :: LLRNONLY
INTEGER (KIND=JPIM) :: IREP, IPFAOVSZ

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_FLDDESC_SP2GP',0,ZHOOK_HANDLE)

CALL FASGRA (IREP, CNMCA, IPFAOVSZ)

LLRNONLY = .FALSE.
IF (PRESENT (LDRNONLY)) LLRNONLY = LDRNONLY

IFNUM = SIZE (YDFLDSC_SP)

YDFLDSC_GP = YDFLDSC_SP

IF (.NOT. LLRNONLY) THEN
  YDFLDSC_GP%LSPEC  = .FALSE.
  YDFLDSC_GP%NFLSZ  = YDGEOMETRY%YRGEM%NGPTOTG
  YDFLDSC_GP%NSIZPK = YDGEOMETRY%YRGEM%NGPTOTG + JPPRCM * IPFAOVSZ
ENDIF

DO JFLD = 1, IFNUM
! Orography :
  IF (YDFLDSC_GP(JFLD)%CPREF == YFAOROG%CLNAME(1:4) .AND. &
    & YDFLDSC_GP(JFLD)%CSUFF == YFAOROG%CLNAME(5:)) THEN
    YDFLDSC_GP(JFLD)%CPREF = 'SURF'
    YDFLDSC_GP(JFLD)%CSUFF = 'GEOPOTENTIEL'
  ENDIF
ENDDO

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_FLDDESC_SP2GP',1,ZHOOK_HANDLE)

END SUBROUTINE IOSPECA_FLDDESC_SP2GP

SUBROUTINE IOSPECA_PFCF2UV_GP (YDFLDSC_SP, YDFLDSC_GP, PGPBUFLU, PGPBUFLV, PGPBUFL)

! Replace Psi/Khi by wind momentum in PGPBUFL

USE YOMFA, ONLY : YFAPSI, YFAKHI, YFAUGEO, YFAVGEO

TYPE (IOFLDDESC), INTENT (IN)    :: YDFLDSC_SP (:)
TYPE (IOFLDDESC), INTENT (INOUT) :: YDFLDSC_GP (:)
REAL (KIND=JPRB), INTENT (IN),    OPTIONAL :: PGPBUFLU (:,:)   ! NGPTOT,NFLEVG
REAL (KIND=JPRB), INTENT (IN),    OPTIONAL :: PGPBUFLV (:,:)   ! NGPTOT,NFLEVG
REAL (KIND=JPRB), INTENT (INOUT), OPTIONAL :: PGPBUFL (:,:)    ! NGPTOT,number of fields

INTEGER (KIND=JPIM) :: JFLD
INTEGER (KIND=JPIM) :: IFNUM
INTEGER (KIND=JPIM) :: ILEVG

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_PFCF2UV_GP',0,ZHOOK_HANDLE)

IFNUM = SIZE (YDFLDSC_SP)

DO JFLD = 1, IFNUM
  ILEVG = YDFLDSC_SP(JFLD)%ILEVG
  IF (YDFLDSC_SP(JFLD)%CSUFF == YFAPSI%CLNAME(1:12)) THEN
! Psi -> Wind/x momentum
    YDFLDSC_GP(JFLD)%CSUFF = YFAUGEO%CLNAME(1:12)
    IF (PRESENT (PGPBUFL) .AND. PRESENT (PGPBUFLU)) &
      & PGPBUFL (:,JFLD) = PGPBUFLU (:,ILEVG)
  ELSEIF (YDFLDSC_SP(JFLD)%CSUFF == YFAKHI%CLNAME(1:12)) THEN
! Khi -> Wind/y momentum
    YDFLDSC_GP(JFLD)%CSUFF = YFAVGEO%CLNAME(1:12)
    IF (PRESENT (PGPBUFL) .AND. PRESENT (PGPBUFLV)) &
      & PGPBUFL (:,JFLD) = PGPBUFLV (:,ILEVG)
  ENDIF
ENDDO

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_PFCF2UV_GP',1,ZHOOK_HANDLE)

END SUBROUTINE IOSPECA_PFCF2UV_GP

SUBROUTINE IOSPECA_UV2PFCF_GP (YDFLDSC_GP, PGPBUFL, PGPBUFLU, PGPBUFLV)

USE YOMFA, ONLY : YFAUGEO, YFAVGEO

TYPE (IOFLDDESC), INTENT (IN)    :: YDFLDSC_GP (:)
REAL (KIND=JPRB), INTENT (IN)    :: PGPBUFL (:,:)    ! NGPTOT,number of fields
REAL (KIND=JPRB), INTENT (INOUT) :: PGPBUFLU (:,:)   ! NGPTOT,NFLEVG
REAL (KIND=JPRB), INTENT (INOUT) :: PGPBUFLV (:,:)   ! NGPTOT,NFLEVG

INTEGER (KIND=JPIM) :: JFLD
INTEGER (KIND=JPIM) :: IFNUM
INTEGER (KIND=JPIM) :: ILEVG

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_UV2PFCF_GP',0,ZHOOK_HANDLE)

IFNUM = SIZE (YDFLDSC_GP)

DO JFLD = 1, IFNUM
  ILEVG = YDFLDSC_GP(JFLD)%ILEVG
  IF (YDFLDSC_GP(JFLD)%CSUFF == YFAUGEO%CLNAME(1:12)) THEN
    PGPBUFLU (:,ILEVG) = PGPBUFL (:,JFLD)
  ELSEIF (YDFLDSC_GP(JFLD)%CSUFF == YFAVGEO%CLNAME(1:12)) THEN
    PGPBUFLV (:,ILEVG) = PGPBUFL (:,JFLD)
  ENDIF
ENDDO

IF (LHOOK) CALL DR_HOOK ('IOSPECA_MOD:IOSPECA_UV2PFCF_GP',1,ZHOOK_HANDLE)

END SUBROUTINE IOSPECA_UV2PFCF_GP

END MODULE IOSPECA_MOD

