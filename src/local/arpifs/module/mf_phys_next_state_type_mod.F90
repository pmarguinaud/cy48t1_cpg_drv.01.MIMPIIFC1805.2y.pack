MODULE MF_PHYS_NEXT_STATE_TYPE_MOD

USE PARKIND1, ONLY : JPIM, JPRB
USE FIELD_MODULE
IMPLICIT NONE

TYPE MF_PHYS_NEXT_STATE_TYPE

  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: U (:, :) => NULL ()
  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: V (:, :) => NULL ()
  REAL (KIND=JPRB), POINTER, CONTIGUOUS :: T (:, :) => NULL ()

  INTEGER :: IDUM

CONTAINS

  PROCEDURE :: INIT => MF_PHYS_NEXT_STATE_TYPE_INIT

END TYPE MF_PHYS_NEXT_STATE_TYPE

CONTAINS

SUBROUTINE MF_PHYS_NEXT_STATE_TYPE_INIT (SELF, YDCPG_SL1, YDVARS, YDMODEL)

USE YOMCT0, ONLY : LSLAG, LTWOTL
USE FIELD_VARIABLES_MOD, ONLY: FIELD_VARIABLES
USE CPG_TYPE_MOD, ONLY : CPG_SL1_TYPE
USE TYPE_MODEL  , ONLY : MODEL

CLASS (MF_PHYS_NEXT_STATE_TYPE)        :: SELF
TYPE (CPG_SL1_TYPE),    INTENT (INOUT), TARGET :: YDCPG_SL1
TYPE (FIELD_VARIABLES), INTENT (INOUT), TARGET :: YDVARS
TYPE(MODEL),            INTENT (IN)    :: YDMODEL

ASSOCIATE (YDDYN => YDMODEL%YRML_DYN%YRDYN)

IF (LSLAG) THEN

  ! Taken from cp_ptrslb1.F90
  
  IF (YDDYN%NWLAG == 4) THEN
    SELF%U => YDCPG_SL1%U0 (:,2:)
    SELF%V => YDCPG_SL1%V0 (:,2:)
  ELSE
    IF (YDDYN%NSPLTHOI /= 0) THEN
      SELF%U => YDCPG_SL1%UF9 (:,2:)
      SELF%V => YDCPG_SL1%VF9 (:,2:)
    ELSE
      SELF%U => YDCPG_SL1%U9 (:,2:)
      SELF%V => YDCPG_SL1%V9 (:,2:)
    ENDIF
  ENDIF
  ! * temperature
  IF (YDDYN%NTLAG == 4) THEN
    SELF%T => YDCPG_SL1%T0 (:,2:)
  ELSE
    IF (YDDYN%NSPLTHOI /= 0) THEN
      SELF%T => YDCPG_SL1%TF9 (:,2:)
    ELSE
      SELF%T => YDCPG_SL1%T9 (:,2:)
    ENDIF
  ENDIF
  ! * vertical divergence
  IF (YDDYN%NSVDLAG == 4) THEN
  ! KSLB1VD9 = MSLB1VD0
  ELSE
    IF (YDDYN%NSPLTHOI /= 0) THEN
  !   KSLB1VD9 = MSLB1VDF9
    ELSE
  !   KSLB1VD9 = MSLB1VD9
    ENDIF
  ENDIF
  ! * GFL arrays
  IF (YDDYN%LSPLTHOIGFL.OR.(YDDYN%NSPLTHOI /= 0)) THEN
  ! KSLB1GFL9= MSLB1GFLF9
  ELSE
  ! KSLB1GFL9= MSLB1GFL9
  ENDIF  

ELSE

  SELF%U => YDVARS%U%T1
  SELF%V => YDVARS%V%T1
  SELF%T => YDVARS%T%T1

ENDIF

END ASSOCIATE

END SUBROUTINE MF_PHYS_NEXT_STATE_TYPE_INIT

END MODULE MF_PHYS_NEXT_STATE_TYPE_MOD
