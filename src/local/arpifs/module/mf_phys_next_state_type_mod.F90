MODULE MF_PHYS_NEXT_STATE_TYPE_MOD

USE PARKIND1, ONLY : JPIM, JPRB
USE FIELD_MODULE
IMPLICIT NONE

TYPE MF_PHYS_NEXT_STATE_TYPE

  INTEGER :: IDUM

CONTAINS

  PROCEDURE :: INIT => MF_PHYS_NEXT_STATE_TYPE_INIT

END TYPE MF_PHYS_NEXT_STATE_TYPE

CONTAINS

SUBROUTINE MF_PHYS_NEXT_STATE_TYPE_INIT (SELF, YDCPG_SL1, YDVARS, YDMODEL)

USE FIELD_VARIABLES_MOD, ONLY: FIELD_VARIABLES
USE CPG_TYPE_MOD, ONLY : CPG_SL1_TYPE
USE TYPE_MODEL  , ONLY : MODEL

CLASS (MF_PHYS_NEXT_STATE_TYPE)        :: SELF
TYPE (CPG_SL1_TYPE),    INTENT (INOUT) :: YDCPG_SL1
TYPE (FIELD_VARIABLES), INTENT (INOUT) :: YDVARS
TYPE(MODEL),            INTENT (IN)    :: YDMODEL

ASSOCIATE (YDDYN => YDMODEL%YRML_DYN%YRDYN)

! Taken from cp_ptrslb1.F90

IF (YDDYN%NWLAG == 4) THEN
! KSLB1U9  = MSLB1U0
! KSLB1V9  = MSLB1V0
ELSE
  IF (YDDYN%NSPLTHOI /= 0) THEN
!   KSLB1U9  = MSLB1UF9
!   KSLB1V9  = MSLB1VF9
  ELSE
!   KSLB1U9  = MSLB1U9
!   KSLB1V9  = MSLB1V9
  ENDIF
ENDIF
! * temperature
IF (YDDYN%NTLAG == 4) THEN
! KSLB1T9  = MSLB1T0
ELSE
  IF (YDDYN%NSPLTHOI /= 0) THEN
!   KSLB1T9  = MSLB1TF9
  ELSE
!   KSLB1T9  = MSLB1T9
  ENDIF
ENDIF
! * vertical divergence
IF (YDDYN%NSVDLAG == 4) THEN
! KSLB1VD9 = MSLB1VD0
ELSE
  IF (YDDYN%NSPLTHOI /= 0) THEN
!   KSLB1VD9 = MSLB1VDF9
  ELSE
!   KSLB1VD9 = MSLB1VD9
  ENDIF
ENDIF
! * GFL arrays
IF (YDDYN%LSPLTHOIGFL.OR.(YDDYN%NSPLTHOI /= 0)) THEN
! KSLB1GFL9= MSLB1GFLF9
ELSE
! KSLB1GFL9= MSLB1GFL9
ENDIF  

END ASSOCIATE

END SUBROUTINE MF_PHYS_NEXT_STATE_TYPE_INIT

END MODULE MF_PHYS_NEXT_STATE_TYPE_MOD
