MODULE SC2PRG_MOD

!**** *SC2PRG_MOD*  - POINTER ATTRIBUTION TO A GRIDPOINT FIELD OR SET OF FIELDS

!     Purpose.
!     --------
!       To affect the pointer of a field or a set of fields and hence avoid any "assumed"
!       bounds array violation when a field or a set of field is not defined.

!**   Interface.
!     ----------
!        *CALL* *SC2PRGx(.....)*

!        Explicit arguments :
!        --------------------

!        Implicit arguments :
!        --------------------

!     Externals.
!     ----------

!     Reference.
!     ----------
!       Named in memory of glorious subroutines sc2rdg and sc2wrg 

!     Author.
!     -------
!      Ryad El Khatib *METEO-FRANCE* 05-Oct-2018

!     Modifications.
!     --------------

!     ------------------------------------------------------------------

USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK

USE YOMTRAJ   ,ONLY : TRAJ_PHYS_TYPE, TRAJ_SLAG_TYPE, TRAJ_SLAG_TYPE, &
 & TRAJ_CST_TYPE, TRAJ_PHYS_TLAD_TYPE, TRAJ_SRFC_TYPE

IMPLICIT NONE

SAVE

! A way to have a memory-saved address - Intel didn't like nullify()
REAL(KIND=JPRB), TARGET :: ZDUMM1(1)
REAL(KIND=JPRB), TARGET :: ZDUMM2(1,1)
REAL(KIND=JPRB), TARGET :: ZDUMM3(1,1,1)
REAL(KIND=JPRB), POINTER :: ZNULL1(:)     => NULL ()
REAL(KIND=JPRB), POINTER :: ZNULL2(:,:)   => NULL ()
REAL(KIND=JPRB), POINTER :: ZNULL3(:,:,:) => NULL ()
TYPE(TRAJ_PHYS_TYPE), POINTER :: FAKE_TRAJ_PHYS => NULL()
TYPE(TRAJ_SLAG_TYPE), POINTER :: FAKE_TRAJ_SLAG => NULL()
TYPE(TRAJ_CST_TYPE), POINTER :: FAKE_TRAJ_CST => NULL()
TYPE(TRAJ_PHYS_TLAD_TYPE), POINTER :: FAKE_TRAJ_PHYS_TLAD => NULL()
TYPE(TRAJ_SRFC_TYPE), POINTER :: FAKE_TRAJ_SRFC => NULL()

INTERFACE SC2PRG
MODULE PROCEDURE SC2PRG1A
MODULE PROCEDURE SC2PRG2A
MODULE PROCEDURE SC2PRG3A
MODULE PROCEDURE SC2PRGX1A
MODULE PROCEDURE SC2PRGX2A
MODULE PROCEDURE SC2PRGX3A
MODULE PROCEDURE SC2PRTRAJ_PHYS
MODULE PROCEDURE SC2PRTRAJ_SLAG
MODULE PROCEDURE SC2PRTRAJ_CST
MODULE PROCEDURE SC2PRTRAJ_PHYS_TLAD
MODULE PROCEDURE SC2PRTRAJ_SRFC
END INTERFACE

PRIVATE
PUBLIC :: SC2PRG

CONTAINS

SUBROUTINE SC2PRG1A(KBL,PG1A,PGPR,LDDUMM) 

INTEGER(KIND=JPIM),      INTENT(IN)  :: KBL
REAL(KIND=JPRB),TARGET,  INTENT(IN)  :: PG1A(:,:)
REAL(KIND=JPRB),POINTER :: PGPR(:)
LOGICAL, OPTIONAL,       INTENT(IN)  :: LDDUMM
LOGICAL :: LLDUMM

REAL (KIND=JPRB), POINTER :: ZPTR1 (:)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

LLDUMM = .FALSE.
IF (PRESENT (LDDUMM)) LLDUMM = LDDUMM

IF (LLDUMM) THEN
  ZPTR1 => ZDUMM1
ELSE
  ZPTR1 => ZNULL1
ENDIF

IF (SIZE(PG1A) == 0) THEN
  PGPR => ZPTR1
ELSEIF ( (LBOUND(PG1A,DIM=2) <= KBL) .AND. (KBL <= UBOUND(PG1A,DIM=2)) ) THEN
  PGPR => PG1A(:,KBL)
ELSE
  PGPR => ZPTR1
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRG1A

SUBROUTINE SC2PRG2A(KBL,PG2A,PGPR,LDDUMM) 

INTEGER(KIND=JPIM),      INTENT(IN)  :: KBL
REAL(KIND=JPRB),TARGET,  INTENT(IN)  :: PG2A(:,:,:)
REAL(KIND=JPRB),POINTER :: PGPR(:,:)
LOGICAL, OPTIONAL,       INTENT(IN)  :: LDDUMM
LOGICAL :: LLDUMM

REAL (KIND=JPRB), POINTER :: ZPTR2 (:,:)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

LLDUMM = .FALSE.
IF (PRESENT (LDDUMM)) LLDUMM = LDDUMM

IF (LLDUMM) THEN
  ZPTR2 => ZDUMM2
ELSE
  ZPTR2 => ZNULL2
ENDIF

IF (SIZE(PG2A) == 0) THEN
  PGPR => ZPTR2
ELSEIF ( (LBOUND(PG2A,DIM=3) <= KBL) .AND. (KBL <= UBOUND(PG2A,DIM=3)) ) THEN
  PGPR => PG2A(:,:,KBL)
ELSE
  PGPR => ZPTR2
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRG2A

SUBROUTINE SC2PRG3A(KBL,PG3A,PGPR,LDDUMM) 

INTEGER(KIND=JPIM),      INTENT(IN)  :: KBL
REAL(KIND=JPRB),TARGET,  INTENT(IN)  :: PG3A(:,:,:,:)
REAL(KIND=JPRB),POINTER :: PGPR(:,:,:)
LOGICAL, OPTIONAL,       INTENT(IN)  :: LDDUMM
LOGICAL :: LLDUMM

REAL (KIND=JPRB), POINTER :: ZPTR3 (:,:,:)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

LLDUMM = .FALSE.
IF (PRESENT (LDDUMM)) LLDUMM = LDDUMM

IF (LLDUMM) THEN
  ZPTR3 => ZDUMM3
ELSE
  ZPTR3 => ZNULL3
ENDIF

IF (SIZE(PG3A) == 0) THEN
  PGPR => ZPTR3
ELSEIF ( (LBOUND(PG3A,DIM=4) <= KBL) .AND. (KBL <= UBOUND(PG3A,DIM=4)) ) THEN
  PGPR => PG3A(:,:,:,KBL)
ELSE
  PGPR => ZPTR3
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRG3A

SUBROUTINE SC2PRGX1A(KINDEX,KBL,PG1A,PGPR,LDDUMM) 

! Adressing via an array of pointers

INTEGER(KIND=JPIM),      INTENT(IN)  :: KINDEX
INTEGER(KIND=JPIM),      INTENT(IN)  :: KBL(:)
REAL(KIND=JPRB),TARGET,  INTENT(IN)  :: PG1A(:,:)
REAL(KIND=JPRB),POINTER :: PGPR(:)
LOGICAL, OPTIONAL,       INTENT(IN)  :: LDDUMM
LOGICAL :: LLDUMM

REAL (KIND=JPRB), POINTER :: ZPTR1 (:)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

LLDUMM = .FALSE.
IF (PRESENT (LDDUMM)) LLDUMM = LDDUMM

IF (LLDUMM) THEN
  ZPTR1 => ZDUMM1
ELSE
  ZPTR1 => ZNULL1
ENDIF

IF (SIZE(PG1A) == 0) THEN
  PGPR => ZPTR1
ELSEIF (SIZE(KBL) == 0) THEN
  PGPR => ZPTR1
ELSEIF ( (LBOUND(KBL,DIM=1) <= KINDEX) .AND. (KINDEX <= UBOUND(KBL,DIM=1)) ) THEN
  IF ( (LBOUND(PG1A,DIM=2) <= KBL(KINDEX)) .AND. (KBL(KINDEX) <= UBOUND(PG1A,DIM=2)) ) THEN
    PGPR => PG1A(:,KBL(KINDEX))
  ELSE
    PGPR => ZPTR1
  ENDIF
ELSE
  PGPR => ZPTR1
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRGX1A

SUBROUTINE SC2PRGX2A(KINDEX,KBL,PG2A,PGPR,LDDUMM) 

! Adressing via an array of pointers

INTEGER(KIND=JPIM),      INTENT(IN)  :: KINDEX
INTEGER(KIND=JPIM),      INTENT(IN)  :: KBL(:)
REAL(KIND=JPRB),TARGET,  INTENT(IN)  :: PG2A(:,:,:)
REAL(KIND=JPRB),POINTER :: PGPR(:,:)
LOGICAL, OPTIONAL,       INTENT(IN)  :: LDDUMM
LOGICAL :: LLDUMM

REAL (KIND=JPRB), POINTER :: ZPTR2 (:,:)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

LLDUMM = .FALSE.
IF (PRESENT (LDDUMM)) LLDUMM = LDDUMM

IF (LLDUMM) THEN
  ZPTR2 => ZDUMM2
ELSE
  ZPTR2 => ZNULL2
ENDIF

IF (SIZE(PG2A) == 0) THEN
  PGPR => ZPTR2
ELSEIF (SIZE(KBL) == 0) THEN
  PGPR => ZPTR2
ELSEIF ( (LBOUND(KBL,DIM=1) <= KINDEX) .AND. (KINDEX <= UBOUND(KBL,DIM=1)) ) THEN
  IF ( (LBOUND(PG2A,DIM=3) <= KBL(KINDEX)) .AND. (KBL(KINDEX) <= UBOUND(PG2A,DIM=3)) ) THEN
    PGPR => PG2A(:,:,KBL(KINDEX))
  ELSE
    PGPR => ZPTR2
  ENDIF
ELSE
  PGPR => ZPTR2
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRGX2A

SUBROUTINE SC2PRGX3A(KINDEX,KBL,KSIZE,PG3A,PGPR,LDDUMM) 

! Adressing via an array of pointers

INTEGER(KIND=JPIM),      INTENT(IN)  :: KINDEX
INTEGER(KIND=JPIM),      INTENT(IN)  :: KBL(:)
INTEGER(KIND=JPIM),      INTENT(IN)  :: KSIZE
REAL(KIND=JPRB),TARGET,  INTENT(IN)  :: PG3A(:,:,:)
REAL(KIND=JPRB),POINTER :: PGPR(:,:,:)
LOGICAL, OPTIONAL,       INTENT(IN)  :: LDDUMM
LOGICAL :: LLDUMM

REAL (KIND=JPRB), POINTER :: ZPTR3 (:,:,:)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

LLDUMM = .FALSE.
IF (PRESENT (LDDUMM)) LLDUMM = LDDUMM

IF (LLDUMM) THEN
  ZPTR3 => ZDUMM3
ELSE
  ZPTR3 => ZNULL3
ENDIF

IF (SIZE(PG3A) == 0) THEN
  PGPR => ZPTR3
ELSEIF (SIZE(KBL) == 0) THEN
  PGPR => ZPTR3
ELSEIF ( (LBOUND(KBL,DIM=1) <= KINDEX) .AND. (KINDEX <= UBOUND(KBL,DIM=1)) ) THEN
  IF ( (LBOUND(PG3A,DIM=3) <= KBL(KINDEX)) .AND. (KBL(KINDEX)+KSIZE-1 <= UBOUND(PG3A,DIM=3)) ) THEN
    PGPR => PG3A(:,:,KBL(KINDEX):KBL(KINDEX)+KSIZE-1)
  ELSE
    PGPR => ZPTR3
  ENDIF
ELSE
  PGPR => ZPTR3
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRGX3A

SUBROUTINE SC2PRTRAJ_PHYS(KBL,PGTRAJ,PTRTRAJ) 

INTEGER(KIND=JPIM),           INTENT(IN) :: KBL
TYPE(TRAJ_PHYS_TYPE), TARGET, INTENT(IN) :: PGTRAJ(:)
TYPE(TRAJ_PHYS_TYPE), POINTER :: PTRTRAJ

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

IF (SIZE(PGTRAJ) == 0) THEN
  PTRTRAJ => FAKE_TRAJ_PHYS
ELSEIF ( (LBOUND(PGTRAJ,DIM=1) <= KBL) .AND. (KBL <= UBOUND(PGTRAJ,DIM=1)) ) THEN
  PTRTRAJ => PGTRAJ(KBL)
ELSE
  PTRTRAJ => FAKE_TRAJ_PHYS
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRTRAJ_PHYS

SUBROUTINE SC2PRTRAJ_SLAG(KBL,PGTRAJ,PTRTRAJ)

INTEGER(KIND=JPIM),           INTENT(IN) :: KBL
TYPE(TRAJ_SLAG_TYPE), TARGET, INTENT(IN) :: PGTRAJ(:)
TYPE(TRAJ_SLAG_TYPE), POINTER :: PTRTRAJ

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

IF (SIZE(PGTRAJ) == 0) THEN
  PTRTRAJ => FAKE_TRAJ_SLAG
ELSEIF ( (LBOUND(PGTRAJ,DIM=1) <= KBL) .AND. (KBL <= UBOUND(PGTRAJ,DIM=1)) ) THEN
  PTRTRAJ => PGTRAJ(KBL)
ELSE
  PTRTRAJ => FAKE_TRAJ_SLAG
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRTRAJ_SLAG

SUBROUTINE SC2PRTRAJ_CST(KBL,PGTRAJ,PTRTRAJ)

INTEGER(KIND=JPIM),           INTENT(IN) :: KBL
TYPE(TRAJ_CST_TYPE), TARGET, INTENT(IN) :: PGTRAJ(:)
TYPE(TRAJ_CST_TYPE), POINTER :: PTRTRAJ

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

IF (SIZE(PGTRAJ) == 0) THEN
  PTRTRAJ => FAKE_TRAJ_CST
ELSEIF ( (LBOUND(PGTRAJ,DIM=1) <= KBL) .AND. (KBL <= UBOUND(PGTRAJ,DIM=1)) ) THEN
  PTRTRAJ => PGTRAJ(KBL)
ELSE
  PTRTRAJ => FAKE_TRAJ_CST
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRTRAJ_CST

SUBROUTINE SC2PRTRAJ_PHYS_TLAD(KBL,PGTRAJ,PTRTRAJ)

INTEGER(KIND=JPIM),           INTENT(IN) :: KBL
TYPE(TRAJ_PHYS_TLAD_TYPE), TARGET, INTENT(IN) :: PGTRAJ(:)
TYPE(TRAJ_PHYS_TLAD_TYPE), POINTER :: PTRTRAJ

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

IF (SIZE(PGTRAJ) == 0) THEN
  PTRTRAJ => FAKE_TRAJ_PHYS_TLAD
ELSEIF ( (LBOUND(PGTRAJ,DIM=1) <= KBL) .AND. (KBL <= UBOUND(PGTRAJ,DIM=1)) ) THEN
  PTRTRAJ => PGTRAJ(KBL)
ELSE
  PTRTRAJ => FAKE_TRAJ_PHYS_TLAD
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRTRAJ_PHYS_TLAD

SUBROUTINE SC2PRTRAJ_SRFC(KBL,PGTRAJ,PTRTRAJ)

INTEGER(KIND=JPIM),           INTENT(IN) :: KBL
TYPE(TRAJ_SRFC_TYPE), TARGET, INTENT(IN) :: PGTRAJ(:)
TYPE(TRAJ_SRFC_TYPE), POINTER :: PTRTRAJ

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',0,ZHOOK_HANDLE)

IF (SIZE(PGTRAJ) == 0) THEN
  PTRTRAJ => FAKE_TRAJ_SRFC
ELSEIF ( (LBOUND(PGTRAJ,DIM=1) <= KBL) .AND. (KBL <= UBOUND(PGTRAJ,DIM=1)) ) THEN
  PTRTRAJ => PGTRAJ(KBL)
ELSE
  PTRTRAJ => FAKE_TRAJ_SRFC
ENDIF

IF (LHOOK) CALL DR_HOOK ('SC2PRG_MOD:SC2PRG',1,ZHOOK_HANDLE)
END SUBROUTINE SC2PRTRAJ_SRFC

END MODULE SC2PRG_MOD
