MODULE TRAJ_MAIN_MOD

!     Purpose.
!     --------
!       Manage main trajectory

!     Author.
!     -------
!        Y. Tremolet *ECMWF*
!        Original : 09-10-01

!     Modifications.
!     --------------
!        Modified : 02-09-16 G. Desroziers - also treat Aladin mean wind trajectory
!        O.Spaniel    : 03-04-15 cleaning-ordering of declaration
!        Modified : 03-03-31 C. Fischer - readapted Aladin mean wind to control_vectors
!        M.Hamrud      01-Oct-2003 CY28 Cleaning
!        G. Desroziers & C. Fischer: 04-06-08 Secure gridpoint copy to/from TRAJ_grids
!        Y.Tremolet    18-Mar-2004 Add lprttraj option for diagnostics
!        J.Haseler     11-Oct-2005 Generalise gridpoint trajectory contents
!        M.Hamrud  15-Jan-2006  Revised GPRCP
!        G. Desroziers and K. Yessad (sept 2005):
!         - split option LTRAJHR into LTRAJHR_ALTI and LTRAJHR_SURF.
!         - adapt option LTRAJHR to METEO-FRANCE configurations.
!        J.Haseler     27-Feb-2007 Simplify logic
!        Y.Tremolet    27-Nov-2008 Long window 4D-Var
!        N Wedi (Nov 2011) : bugfix
!        F. Vana  28-Nov-2013 : Redesigned trajectory handling
!        K. Yessad (July 2014): Move some variables.
!        M. Fisher  9 July 2015: Disentangle background from trajectory
!        A. Trojakova (May 2018): Fix for ALARO 3DVAR minimization using
!                                 spectral Q in the background field input.
!        E. Holm    27-Mar-2019: Write out BG different from FG if L_FGNOTBG
!        Y. Michel (June 2018) : Second fix for LAM when LSPRT=.TRUE.
!     ------------------------------------------------------------------

USE PARKIND1, ONLY : JPIM, JPRB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK
USE YOMLUN,   ONLY : NULOUT, NULERR
USE YOMCT0,   ONLY : LIFSTRAJ, LSPRT, NINTERPTRAJ, LARPEGEF_TRAJHR, LARPEGEF_TRAJBG, LELAM
USE YOMVAR,   ONLY : MUPTRA, FILTERFACTOR, FILTEREXPO, FILTERRESOL, L_FGNOTBG
USE ALGORITHM_STATE_MOD  , ONLY : GET_NUPTRA
USE YOMMODERR,ONLY : N_COUPLED_WINDOWS
USE YOMDIM,   ONLY : TDIM
USE YOMMP0,   ONLY : MYSETV
USE YOM_GRIB_CODES,  ONLY : NGRBVO, NGRBD, NGRBT, NGRBQ, NGRBO3, NGRBLNSP
USE YOMTRAJ,  ONLY : TRAJEC, NSMAX_TRAJ,&
 &                   LPRTTRAJ, LTRAJHR_ALTI,&
 &                   LTRAJHR, LTRAJGP, LREADGPTRAJ, NSTEPTRAJ, MSTART, NSPTRAJ, NGPTRAJ,&
 &                   MSTEPTRAJW, MSTEPTRAJR, MIOTRAJMAIN, TRAJ_SPEC_TMP0, LTRAJRESET,&
 &                   TRAJ_TYPE, MTYPE_MAIN3_TRAJ, MTYPE_MAIN2_TRAJ, MAIN_GRIB, MBACKGR_GRIB 
USE YOMGMV,   ONLY : TGMV
USE YOMCST,   ONLY : RD
USE YOMOPH0,  ONLY : CFNTRAJHRGRID, CFNTRAJBGGRID, CFNTRAJHRSPEC, CFNTRAJBGSPEC
USE SPECTRAL_FIELDS_MOD

IMPLICIT NONE

PRIVATE
PUBLIC ALLOCATE_TRAJ_MAIN, DEALLOCATE_TRAJ_MAIN,&
 & STORE_MAIN_TRAJ, READ_TRAJ_SPEC,READ_TRAJ_GRID,&
 & GET_TRAJ_SPEC, GET_TRAJ_GRID  

#include "dir_trans.h"
#include "edir_trans.h"
#include "inv_trans.h"
#include "einv_trans.h"

#include "abor1.intfb.h"
#include "copy_spa2spec.intfb.h"
#include "copy_spec2spa.intfb.h"
#include "read_spec.intfb.h"
#include "read_spec_fromfa.intfb.h"
#include "read_grid_traj.intfb.h"
#include "sugridu.intfb.h"
#include "suspec.intfb.h"
#include "write_grid_traj.intfb.h"
#include "write_spec.intfb.h"
#include "write_spec_traj.intfb.h"

!-----------------------------------------------------------------------
CONTAINS
!-----------------------------------------------------------------------

SUBROUTINE ALLOCATE_TRAJ_MAIN(YDGEOMETRY,YDGMV,YDGMV5,YDML_GCONF)

USE MODEL_GENERAL_CONF_MOD , ONLY : MODEL_GENERAL_CONF_TYPE
USE GEOMETRY_MOD           , ONLY : GEOMETRY

TYPE(GEOMETRY),INTENT(IN)    :: YDGEOMETRY
TYPE(TGMV)    ,INTENT(INOUT) :: YDGMV
TYPE(TGMV)    ,INTENT(INOUT) :: YDGMV5
TYPE(MODEL_GENERAL_CONF_TYPE),INTENT(IN) :: YDML_GCONF
INTEGER(KIND=JPIM) :: II, JSTEP, IFIRST, ILAST, IILAST
INTEGER(KIND=JPIM) :: J1,J2,J3,J4,JGFL
INTEGER(KIND=JPIM), ALLOCATABLE :: IGRIB(:)
REAL(KIND=JPRB) :: ZHOOK_HANDLE

! Spectral trajectory
! -------------------
IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:ALLOCATE_TRAJ_MAIN',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM, YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, &
  & YDMP=>YDGEOMETRY%YRMP, &
  & YDLAP=>YDGEOMETRY%YRLAP, YDRIP=>YDML_GCONF%YRRIP,YGFL=>YDML_GCONF%YGFL,YDDIMF=>YDML_GCONF%YRDIMF)

ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NMSMAX=>YDDIM%NMSMAX, NPROMA=>YDDIM%NPROMA, &
 & NUMP=>YDDIM%NUMP, &
 & NS3D=>YDDIMF%NS3D, &
 & NFLEVG=>YDDIMV%NFLEVG, NFLEVL=>YDDIMV%NFLEVL, &
 & YT5=>YDGMV5%YT5, &
 & YO3=>YGFL%YO3, &
 & MYMS=>YDLAP%MYMS, &
 & NALLMS=>YDMP%NALLMS, NPSURF=>YDMP%NPSURF, NPTRLL=>YDMP%NPTRLL, &
 & NPTRMS=>YDMP%NPTRMS, NUMLL=>YDMP%NUMLL, &
 & NSTART=>YDRIP%NSTART, NSTOP=>YDRIP%NSTOP)
IF (LTRAJHR.AND.LTRAJHR_ALTI) THEN
  IF (LREADGPTRAJ) THEN
    NSPTRAJ=3  ! Vor, Div, Tem
  ELSE
    NSPTRAJ=4  ! Vor, Div, Tem, Hum
    IF (YO3%LACTIVE) NSPTRAJ=NSPTRAJ+1
  ENDIF
ELSE
  NSPTRAJ=NS3D
ENDIF

ALLOCATE(IGRIB(NSPTRAJ+1))
IGRIB(1)=NGRBVO
IGRIB(2)=NGRBD
IGRIB(3)=NGRBT
IF(LTRAJHR)THEN
  IF (.NOT.LREADGPTRAJ) THEN
    IGRIB(4)=NGRBQ
    IF (YO3%LACTIVE) IGRIB(NSPTRAJ)=NGRBO3
  ENDIF
ELSE
  IGRIB(4)=NGRBQ
ENDIF
IGRIB(NSPTRAJ+1)=NGRBLNSP

IF (LTRAJGP.OR.LIFSTRAJ) THEN
  ALLOCATE(TRAJEC(MSTART-1)%SPEC(1))
  CALL ALLOCATE_SPEC(TRAJEC(MSTART-1)%SPEC(1),NFLEVL,NFLEVG,NUMP,MYMS,NSMAX_TRAJ,NMSMAX,&
   & NALLMS,NPTRMS,NUMLL,NPTRLL,NPSURF,NSPTRAJ,1,IGRIB)
  CALL ALLOCATE_SPEC(TRAJ_SPEC_TMP0       ,NFLEVL,NFLEVG,NUMP,MYMS,NSMAX_TRAJ,NMSMAX,&
   & NALLMS,NPTRMS,NUMLL,NPTRLL,NPSURF,NSPTRAJ,1,IGRIB)
  ! In this case we only need to allocate one time slot. It is however re-used
  ! at every step storing the spectral trajectory. Hence those steps need to be 
  ! pointing into the allocated memory.
  ! This should be enough to be done only for steps with MSTEPTRAJW(ii) > 0 but
  !  it costs nothing to do it for every step...
  DO II=NSTART+1,NSTOP
    TRAJEC(II)%SPEC => TRAJEC(MSTART-1)%SPEC
  ENDDO
ELSE
  IILAST=-999
  DO II=NSTART,NSTOP
    IF (MSTEPTRAJW(II) > 0 ) THEN
      IILAST=II
      ALLOCATE(TRAJEC(II)%SPEC(1))
      CALL ALLOCATE_SPEC(TRAJEC(II)%SPEC(1),NFLEVL,NFLEVG,NUMP,MYMS,NSMAX_TRAJ,NMSMAX,&
       & NALLMS,NPTRMS,NUMLL,NPTRLL,NPSURF,NSPTRAJ,1,IGRIB)
    ELSE
      TRAJEC(II)%SPEC => TRAJEC(IILAST)%SPEC
    ENDIF
  ENDDO
ENDIF
WRITE(NULOUT,*)'GREPTRAJ ARRAY TRAJEC%SPEC(1) ALLOCATED'

ALLOCATE(MIOTRAJMAIN(NSTEPTRAJ))
MIOTRAJMAIN(:) = -1
WRITE(NULOUT,9)'MIOTRAJMAIN',SIZE(MIOTRAJMAIN),SHAPE(MIOTRAJMAIN)
! Grid point trajectory
! ---------------------
NGPTRAJ=NFLEVG*YT5%NDIM+YT5%NDIMS+NFLEVG*YGFL%NDIM5
IF (LTRAJGP) THEN
  CALL GSTATS(1050,0)
  IILAST=-999
  DO J2=NSTART,NSTOP
    IF(MSTEPTRAJW(J2) > 0) THEN
      IILAST=J2
      ALLOCATE(TRAJEC(J2)%MAIN(NGPBLKS))
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J1)
      DO J1=1,NGPBLKS
        ALLOCATE(TRAJEC(J2)%MAIN(J1)%GFL(NPROMA,NFLEVG,YGFL%NDIM5))
        ALLOCATE(TRAJEC(J2)%MAIN(J1)%GMV(NPROMA,NFLEVG,YT5%NDIM))
        ALLOCATE(TRAJEC(J2)%MAIN(J1)%GMVS(NPROMA,YT5%NDIMS))
!       TRAJEC(J2)%MAIN(J1)%GFL(:,:,:)=HUGE(TRAJEC(J2)%MAIN(J1)%GFL)
        TRAJEC(J2)%MAIN(J1)%GMV(:,:,:)=HUGE(TRAJEC(J2)%MAIN(J1)%GMV)
        TRAJEC(J2)%MAIN(J1)%GMVS(:,:) =HUGE(TRAJEC(J2)%MAIN(J1)%GMVS)
        DO JGFL=1,YGFL%NDIM5
          IF (YGFL%YCOMP(JGFL)%LTRAJIO ) THEN
            TRAJEC(J2)%MAIN(J1)%GFL(:,:,JGFL)=HUGE(TRAJEC(J2)%MAIN(J1)%GFL)
          ELSE
            TRAJEC(J2)%MAIN(J1)%GFL(:,:,JGFL)=0.0_JPRB
          ENDIF
        ENDDO
      ENDDO
!$OMP END PARALLEL DO
    ELSE
      TRAJEC(J2)%MAIN => TRAJEC(IILAST)%MAIN(:)
    ENDIF
  ENDDO

  CALL GSTATS(1050,1)
ENDIF
DEALLOCATE(IGRIB)

9 FORMAT(1X,'GREPTRAJ ARRAY ',A14,' ALLOCATED ',8I8)

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:ALLOCATE_TRAJ_MAIN',1,ZHOOK_HANDLE)
END SUBROUTINE ALLOCATE_TRAJ_MAIN

!-----------------------------------------------------------------------

SUBROUTINE DEALLOCATE_TRAJ_MAIN(YDDIM,YDGMV,YDGMV5,KNSTART,KNSTOP)

TYPE(TDIM)        , INTENT(IN)    :: YDDIM
TYPE(TGMV)        , INTENT(INOUT) :: YDGMV
TYPE(TGMV)        , INTENT(INOUT) :: YDGMV5
INTEGER(KIND=JPIM), INTENT(IN)    :: KNSTART
INTEGER(KIND=JPIM), INTENT(IN)    :: KNSTOP 

INTEGER(KIND=JPIM) :: JJ, IFIRST, ILAST, J1, J2
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:DEALLOCATE_TRAJ_MAIN',0,ZHOOK_HANDLE)
ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS)
IF (LTRAJGP.OR.LIFSTRAJ) THEN
  DO JJ=KNSTART+1,KNSTOP
    IF (ASSOCIATED(TRAJEC(JJ)%SPEC)) NULLIFY (TRAJEC(JJ)%SPEC)
  ENDDO
  CALL DEALLOCATE_SPEC(TRAJEC(MSTART-1)%SPEC(1))
  CALL DEALLOCATE_SPEC(TRAJ_SPEC_TMP0)
  DEALLOCATE(TRAJEC(MSTART-1)%SPEC)
ELSE
  DO JJ=KNSTOP,KNSTART,-1
    IF (MSTEPTRAJW(JJ)>0) THEN
      CALL DEALLOCATE_SPEC(TRAJEC(JJ)%SPEC(1))
      DEALLOCATE(TRAJEC(JJ)%SPEC)
    ELSE
      NULLIFY(TRAJEC(JJ)%SPEC)
    ENDIF
    NULLIFY(TRAJEC(JJ)%SPEC)
  ENDDO
ENDIF
WRITE(NULOUT,*)'GREPTRAJ TRAJEC%SPEC(1) DEALLOCATED'

DEALLOCATE(MIOTRAJMAIN)

!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J1,J2)
DO J2=KNSTART,KNSTOP
  IF(MSTEPTRAJW(J2)>0) THEN
    DO J1=1,NGPBLKS
      IF (ASSOCIATED(TRAJEC(J2)%MAIN(J1)%GFL )) DEALLOCATE (TRAJEC(J2)%MAIN(J1)%GFL)
      IF (ASSOCIATED(TRAJEC(J2)%MAIN(J1)%GMV )) DEALLOCATE (TRAJEC(J2)%MAIN(J1)%GMV)
      IF (ASSOCIATED(TRAJEC(J2)%MAIN(J1)%GMVS)) DEALLOCATE (TRAJEC(J2)%MAIN(J1)%GMVS)
    ENDDO
    IF (ASSOCIATED(TRAJEC(J2)%MAIN)) DEALLOCATE(TRAJEC(J2)%MAIN)
  ELSE
    IF (ASSOCIATED(TRAJEC(J2)%MAIN)) NULLIFY(TRAJEC(J2)%MAIN)
  ENDIF
ENDDO
!$OMP END PARALLEL DO
WRITE(NULOUT,*)'GREPTRAJ TRAJ_MAIN DEALLOCATED'

END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:DEALLOCATE_TRAJ_MAIN',1,ZHOOK_HANDLE)
END SUBROUTINE DEALLOCATE_TRAJ_MAIN

!-----------------------------------------------------------------------

SUBROUTINE STORE_MAIN_TRAJ(YDGEOMETRY,YDGMV,YDGMV5,YDMODEL,YDSPEC,PGMV,PGMVS,PGFL,KSTEP,LDREADGPTRAJ,PTRAJEC,YD_BG)

USE TYPE_MODEL             , ONLY : MODEL
USE GEOMETRY_MOD           , ONLY : GEOMETRY
USE FIELDS_MOD             , ONLY : FIELDS, FIELDS_CREATE, FIELDS_DELETE
USE VARIABLES_MOD          , ONLY : VARIABLES, VARIABLES_CREATE, VARIABLES_DELETE

TYPE(GEOMETRY)      ,INTENT(INOUT) :: YDGEOMETRY
TYPE(TGMV)          ,INTENT(INOUT) :: YDGMV
TYPE(TGMV)          ,INTENT(INOUT) :: YDGMV5
TYPE(MODEL)         ,INTENT(INOUT) :: YDMODEL
TYPE(SPECTRAL_FIELD),INTENT(IN)    :: YDSPEC
REAL(KIND=JPRB)     ,INTENT(IN)    :: PGMV(:,:,:,:)
REAL(KIND=JPRB)     ,INTENT(IN)    :: PGMVS(:,:,:)
REAL(KIND=JPRB)     ,INTENT(IN)    :: PGFL(:,:,:,:)
INTEGER(KIND=JPIM)  ,INTENT(IN)    :: KSTEP
LOGICAL             ,INTENT(IN)    :: LDREADGPTRAJ
TYPE(TRAJ_TYPE)     ,INTENT(INOUT) :: PTRAJEC
TYPE(TRAJ_TYPE)     ,INTENT(INOUT) :: YD_BG

TYPE(FIELDS)    :: YL_BG
TYPE(VARIABLES) :: YL_VARS
REAL(KIND=JPRB), ALLOCATABLE :: ZSP(:,:), ZGP(:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZTRAJ_BUF(:,:,:)
REAL(KIND=JPRB) :: ZR(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)
INTEGER(KIND=JPIM) :: IVSETSC(YDGEOMETRY%YRDIMV%NFLEVG)
INTEGER(KIND=JPIM):: ISTEP,JSTEP,JGFL,IGP,IFLD
INTEGER(KIND=JPIM):: JKGLO,ICEND,IBL,JBL,JFLD,J
INTEGER(KIND=JPIM):: IGPX(YDMODEL%YRML_GCONF%YGFL%NUMFLDS)
CHARACTER(LEN=17) :: CLFILE
LOGICAL :: LLFIRST,LLAST
REAL(KIND=JPRB) :: ZHOOK_HANDLE

INTEGER(KIND=JPIM):: IFLDS,I2DFLDS,I3DFLDS,JJ

! Needs to be in this position because of bug in pgf90 5.2-4
#include "gprcp_qlirsg.intfb.h"

IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:STORE_MAIN_TRAJ',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, &
  & YDMP=>YDGEOMETRY%YRMP, YGFL=>YDMODEL%YRML_GCONF%YGFL,YDDIMF=>YDMODEL%YRML_GCONF%YRDIMF)
ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, NRESOL=>YDDIM%NRESOL, &
 & NSPEC2=>YDDIM%NSPEC2, &
 & NS1D=>YDDIMF%NS1D, NS3D=>YDDIMF%NS3D, &
 & NFLEVG=>YDDIMV%NFLEVG, NFLEVL=>YDDIMV%NFLEVL, &
 & NGPTOT=>YDGEM%NGPTOT, &
 & YCOMP=>YGFL%YCOMP, YQ=>YGFL%YQ, YO3=>YGFL%YO3, &
 & YT0=>YDGMV%YT0, &
 & YT5=>YDGMV5%YT5, &
 & NBSETLEV=>YDMP%NBSETLEV, NBSETSP=>YDMP%NBSETSP, &
 & NSTART=>YDMODEL%YRML_GCONF%YRRIP%NSTART, NSTOP=>YDMODEL%YRML_GCONF%YRRIP%NSTOP)
ISTEP=MSTEPTRAJW(KSTEP)
IF (ISTEP>0) THEN
  IF (ISTEP == 1) THEN
    LLFIRST = .TRUE.
  ELSE
    LLFIRST = .FALSE.
  ENDIF
  IF (LIFSTRAJ) THEN
    IF(MIOTRAJMAIN(ISTEP)== -1) THEN
      DO JSTEP=1,ISTEP-1
        IF(MIOTRAJMAIN(JSTEP) /= JSTEP)THEN
          WRITE(NULERR,*)'HOLE IN MAIN TRAJ',JSTEP,ISTEP,MIOTRAJMAIN(JSTEP)
         CALL ABOR1('STORE_MAIN_TRAJ:HOLE')
        ENDIF
      ENDDO
      LLAST=.TRUE.
      DO JSTEP=KSTEP+1,NSTOP
        IF(MSTEPTRAJW(JSTEP) > 0) LLAST=.FALSE.
      ENDDO

      IF (LDREADGPTRAJ) THEN
        I3DFLDS=0
        DO JGFL=1,YGFL%NUMFLDS
          IF (YCOMP(JGFL)%LTRAJIO ) I3DFLDS=I3DFLDS+1
        ENDDO
        IF (I3DFLDS == 0) THEN
          WRITE(NULERR,*) 'NO GRIDPOINT FIELDS TO WRITE TO TRAJECTORY'
          CALL ABOR1('STORE_MAIN_TRAJ:I3DFLDS=0')
        ENDIF

        CLFILE(1:17)=CFNTRAJHRGRID

        WRITE(CLFILE( 7: 8),'(I2.2)')GET_NUPTRA()
        WRITE(NULOUT,*)'Saving main trajectory in ',CLFILE,' at step ',ISTEP
        I2DFLDS=0
        IFLDS=NFLEVG*I3DFLDS+I2DFLDS
        ALLOCATE(ZGP(NPROMA,IFLDS,NGPBLKS))

        CALL GSTATS(1938,0)
        IGP=1
        DO JGFL=1,YGFL%NUMFLDS
          IF (YCOMP(JGFL)%LTRAJIO ) THEN
            IGPX(JGFL)=IGP
            IGP=IGP+NFLEVG
          ENDIF
        ENDDO
        CALL GSTATS(1938,1)
        CALL GSTATS(1465,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JBL,JGFL)
        DO JBL=1,NGPBLKS
          DO JGFL=1,YGFL%NUMFLDS
            IF (YCOMP(JGFL)%LTRAJIO ) THEN
              ZGP(:,IGPX(JGFL):IGPX(JGFL)+NFLEVG-1,JBL)=PGFL(:,:,YCOMP(JGFL)%MP,JBL)
            ENDIF
          ENDDO
        ENDDO
!$OMP END PARALLEL DO 
        CALL GSTATS(1465,1)

        CALL WRITE_GRID_TRAJ(YDGEOMETRY,YDMODEL%YRML_GCONF%YRRIP,TRIM(CLFILE),MAIN_GRIB,MTYPE_MAIN3_TRAJ,&
         & MTYPE_MAIN2_TRAJ,I3DFLDS,I2DFLDS,ZGP,YDSPEC%SP,NINTERPTRAJ,LLFIRST,LLAST)

        IF (ISTEP==1 .AND. GET_NUPTRA()==0) THEN
          IF (L_FGNOTBG) THEN
            CALL VARIABLES_CREATE(YL_VARS, .FALSE.,.FALSE.)
            CALL FIELDS_CREATE(YL_BG,YDGEOMETRY,YDMODEL,YL_VARS)
            CALL VARIABLES_DELETE(YL_VARS)
            CALL SUSPEC(YDGEOMETRY,YL_BG%YRGFL,YDMODEL%YRML_GCONF,YDMODEL%YRML_DYN%YRDYN,YDMODEL%YRML_LBC,YL_BG%YRSPEC,KFILE=12)
            CALL SUGRIDU(YDGEOMETRY,YDMODEL%YRML_PHY_SLIN%YREPHLI,YDMODEL%YRML_GCONF,YDMODEL%YRML_LBC,YL_BG%YRSPEC,YL_BG%YRGFL,12)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JBL,JGFL)
            DO JBL=1,NGPBLKS
              DO JGFL=1,YGFL%NUMFLDS
                IF (YCOMP(JGFL)%LTRAJIO ) THEN
                  ZGP(:,IGPX(JGFL):IGPX(JGFL)+NFLEVG-1,JBL)=YL_BG%YRGFL%GFL(:,:,YCOMP(JGFL)%MP,JBL)
                ENDIF
              ENDDO
            ENDDO
!$OMP END PARALLEL DO 
          ENDIF
          CLFILE(1:17)=CFNTRAJBGGRID
          DO JJ=0,MUPTRA-1
            WRITE(CLFILE( 7: 8),'(I2.2)')JJ
            WRITE(NULOUT,*)'Saving main background state in ',CLFILE,' at step ',ISTEP
            IF (L_FGNOTBG) THEN
              CALL WRITE_GRID_TRAJ(YDGEOMETRY,YDMODEL%YRML_GCONF%YRRIP,TRIM(CLFILE),MBACKGR_GRIB(JJ),MTYPE_MAIN3_TRAJ,&
               & MTYPE_MAIN2_TRAJ,I3DFLDS,I2DFLDS,ZGP,YL_BG%YRSPEC%SP,NINTERPTRAJ,LLFIRST,.TRUE.)
            ELSE
              CALL WRITE_GRID_TRAJ(YDGEOMETRY,YDMODEL%YRML_GCONF%YRRIP,TRIM(CLFILE),MBACKGR_GRIB(JJ),MTYPE_MAIN3_TRAJ,&
               & MTYPE_MAIN2_TRAJ,I3DFLDS,I2DFLDS,ZGP,YDSPEC%SP,NINTERPTRAJ,LLFIRST,.TRUE.)
            ENDIF
          ENDDO
        ENDIF

        DEALLOCATE(ZGP)

        MIOTRAJMAIN(ISTEP)=ISTEP
      ENDIF

      IF (NS3D>NSPTRAJ) CALL ABOR1('STORE_MAIN_TRAJ: NS3D>NSPTRAJ')

      ALLOCATE(ZTRAJ_BUF(NFLEVL,NSPEC2,NSPTRAJ))
      CALL GSTATS(1465,0)
      IF (LDREADGPTRAJ) THEN
        IF (LSPRT) THEN
          IFLD=NSPTRAJ-1
        ELSE
          IFLD=NSPTRAJ
        ENDIF
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
        DO J=1,NSPEC2
          ZTRAJ_BUF(:,J,1:IFLD)=YDSPEC%SP3D(:,J,1:IFLD)
        ENDDO
!$OMP END PARALLEL DO
      ELSE
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
        DO J=1,NSPEC2
          ZTRAJ_BUF(:,J,1:NS3D)=YDSPEC%SP3D(:,J,:)
        ENDDO
!$OMP END PARALLEL DO
      ENDIF
      CALL GSTATS(1465,1)

      IF (LSPRT.OR.(.NOT.LDREADGPTRAJ)) THEN
        ! Real temperature spectral fields are required for i/o.
        ! We use the fact that the grid-point array contains
        ! real temperature, and calculate spectral real temperature
        ! by performing a direct transform.

        ALLOCATE(ZSP(NFLEVL,NSPEC2))
        IVSETSC(:)=NBSETLEV(:)
        CALL DIR_TRANS(PSPSCALAR=ZSP, PGP=PGMV(:,:,YT0%MT,:),&
         & KRESOL=NRESOL, KPROMA=NPROMA, KVSETSC=IVSETSC)  
        CALL GSTATS(1465,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
        DO J=1,NSPEC2
          ZTRAJ_BUF(:,J,3)=ZSP(:,J)
        ENDDO
!$OMP END PARALLEL DO
        CALL GSTATS(1465,1)
        IF (.NOT.LDREADGPTRAJ) THEN
          IF (YQ%LGP) THEN
            CALL DIR_TRANS(PSPSCALAR=ZSP,PGP=PGFL(:,:,YQ%MP,:),&
             & KRESOL=NRESOL, KPROMA=NPROMA, KVSETSC=IVSETSC)  
            CALL GSTATS(1465,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
            DO J=1,NSPEC2
              ZTRAJ_BUF(:,J,4)=ZSP(:,J)
            ENDDO
!$OMP END PARALLEL DO
            CALL GSTATS(1465,1)
          ENDIF
          IF (YO3%LGP) THEN
            CALL DIR_TRANS(PSPSCALAR=ZSP,PGP=PGFL(:,:,YO3%MP,:),&
             & KRESOL=NRESOL, KPROMA=NPROMA, KVSETSC=IVSETSC)  
            CALL GSTATS(1465,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
            DO J=1,NSPEC2
              ZTRAJ_BUF(:,J,5)=ZSP(:,J)
            ENDDO
!$OMP END PARALLEL DO
            CALL GSTATS(1465,1)
          ENDIF
        ENDIF
      ENDIF
      DEALLOCATE(ZSP)
      
      ! Spectral filtering of trajectories potentially applied
      ! Am,n=Am,n/(1+fac-1)*((n*(n+1)**(exp/2)/(N*(N+1)**(exp/2)

      CLFILE(1:17)=CFNTRAJHRSPEC

      WRITE(CLFILE( 7: 8),'(I2.2)')GET_NUPTRA()
      !    write(clfile(18:20),'(I3.3)')istep
      ! Only Vor, Div, Tem are written out as spectral fields if LREADGPTRAJ
      CALL COPY_SPA2SPEC(YDGEOMETRY,NSPTRAJ,1,NS1D,ZTRAJ_BUF,YDSPEC%SP,YDSPEC%SP1D,PTRAJEC%SPEC(1))
      IF (FILTERFACTOR==1.0_JPRB .OR. PTRAJEC%SPEC(1)%NSMAX < FILTERRESOL) THEN
        WRITE(NULOUT,*)'GREPTRAJ Saving main trajectory in ',CLFILE,' at step ',ISTEP
        CALL WRITE_SPEC_TRAJ(YDGEOMETRY,YDMODEL%YRML_GCONF%YRRIP,TRIM(CLFILE),PTRAJEC%SPEC(1),LLFIRST,LLAST)
      ELSE
        WRITE(NULOUT,*)'GREPTRAJ Saving main trajectory in ',CLFILE,' at step ',ISTEP,&
       & ' spectral filtering applied with fac=',FILTERFACTOR,' and exponent=',FILTEREXPO
        CALL WRITE_SPEC(YDGEOMETRY,YDMODEL%YRML_GCONF%YRRIP,TRIM(CLFILE),PTRAJEC%SPEC(1),LLFIRST,PFACTOR=FILTERFACTOR,&
         & PEXPO=FILTEREXPO)
      ENDIF

      IF (ISTEP==1 .AND. GET_NUPTRA()==0) THEN
        IF (L_FGNOTBG) THEN
          ! Copy all spectral fields to ZTRAJ_BUF
          ! For the background we have just read in spectral real T (no Tv here)
          ! Not identical to the x_fg, where T comes from the model timestep pgmv
          ! and has undergone T_sp-->[T_gp-->Tv_gp-->Tv_sp]-->[Tv_gp-->T_gp]-->T_sp
          !                          suinif calls specrt      model pgmv       dir_trans 
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
          DO J=1,NSPEC2
            ZTRAJ_BUF(:,J,:)=YL_BG%YRSPEC%SP3D(:,J,:)
          ENDDO
!$OMP END PARALLEL DO
          IF (.NOT.LDREADGPTRAJ) THEN
            ALLOCATE(ZSP(NFLEVL,NSPEC2)) 
            IF (YQ%LGP) THEN
              CALL DIR_TRANS(PSPSCALAR=ZSP,PGP=YL_BG%YRGFL%GFL(:,:,YQ%MP,:),&
               & KRESOL=NRESOL, KPROMA=NPROMA, KVSETSC=IVSETSC)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
              DO J=1,NSPEC2
                ZTRAJ_BUF(:,J,4)=ZSP(:,J)
              ENDDO
!$OMP END PARALLEL DO
            ENDIF
            IF (YO3%LGP) THEN
              CALL DIR_TRANS(PSPSCALAR=ZSP,PGP=YL_BG%YRGFL%GFL(:,:,YO3%MP,:),&
               & KRESOL=NRESOL, KPROMA=NPROMA, KVSETSC=IVSETSC) 
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
              DO J=1,NSPEC2
                ZTRAJ_BUF(:,J,5)=ZSP(:,J)
              ENDDO
!$OMP END PARALLEL DO
            ENDIF
            DEALLOCATE(ZSP) 
          ENDIF
        ENDIF
        CLFILE(1:17)=CFNTRAJBGSPEC
        DO JJ=0,MUPTRA-1
          WRITE(CLFILE( 7: 8),'(I2.2)') JJ
          ! Only Vor, Div, Tem are written out as spectral fields if LREADGPTRAJ
          IF (L_FGNOTBG) THEN
            CALL COPY_SPA2SPEC(YDGEOMETRY,NSPTRAJ,1,NS1D,ZTRAJ_BUF,YL_BG%YRSPEC%SP,YL_BG%YRSPEC%SP1D,YD_BG%SPEC(JJ))            
          ELSE
            CALL COPY_SPA2SPEC(YDGEOMETRY,NSPTRAJ,1,NS1D,ZTRAJ_BUF,YDSPEC%SP,YDSPEC%SP1D,YD_BG%SPEC(JJ))
          ENDIF
          IF (FILTERFACTOR==1.0_JPRB .OR. YD_BG%SPEC(JJ)%NSMAX < FILTERRESOL) THEN
            WRITE(NULOUT,*)'GREPTRAJ Saving spectral background state UPTRA= ',JJ,' RESOLUTION= ',YD_BG%SPEC(JJ)%NSMAX
            WRITE(NULOUT,*)'GREPTRAJ Saving spectral background state in ',CLFILE,' at step ',ISTEP
            CALL WRITE_SPEC(YDGEOMETRY,YDMODEL%YRML_GCONF%YRRIP,TRIM(CLFILE),YD_BG%SPEC(JJ),LLFIRST)
          ELSE
            WRITE(NULOUT,*)'GREPTRAJ Saving spectral background state in ',CLFILE,' at step ',ISTEP,&
             & ' spectral filtering applied with fac=',FILTERFACTOR,' and exponent=',FILTEREXPO
            CALL WRITE_SPEC(YDGEOMETRY,YDMODEL%YRML_GCONF%YRRIP,TRIM(CLFILE),YD_BG%SPEC(JJ),LLFIRST,PFACTOR=FILTERFACTOR,PEXPO=FILTEREXPO)
          ENDIF
        ENDDO
        IF (L_FGNOTBG) THEN
          CALL FIELDS_DELETE(YL_BG)
        ENDIF
      ENDIF

      MIOTRAJMAIN(ISTEP)=ISTEP
      DEALLOCATE(ZTRAJ_BUF)

    ELSE
      WRITE(NULOUT,*)'GREPTRAJ Warning: Main traj at step,',KSTEP,ISTEP,&
       & 'already written'  
    ENDIF

  ELSE

    IF (LTRAJGP) THEN
      IF(NPROMA /= UBOUND(PGMV,1)) THEN
        WRITE(NULERR,*) NPROMA, UBOUND(PGMV,1)
        CALL ABOR1('STORE_MAIN_TRAJ:WRONG FIRST DIM. OF PGMV')
      ENDIF
      IF(NGPBLKS /= UBOUND(PGMV,4)) THEN
        WRITE(NULERR,*) NGPBLKS, UBOUND(PGMV,4)
        CALL ABOR1('STORE_MAIN_TRAJ:WRONG FOURTH DIM. OF PGMV')
      ENDIF
      IF(NPROMA /= UBOUND(PGMVS,1)) THEN
        WRITE(NULERR,*) NPROMA, UBOUND(PGMVS,1)
        CALL ABOR1('STORE_MAIN_TRAJ:WRONG FIRST DIM. OF PGMVS')
      ENDIF
      IF(NGPBLKS /= UBOUND(PGMVS,3)) THEN
        WRITE(NULERR,*) NGPBLKS, UBOUND(PGMV,3)
        CALL ABOR1('STORE_MAIN_TRAJ:WRONG THIRD DIM. OF PGMVS')
      ENDIF
      IF(NPROMA /= UBOUND(PGFL,1)) THEN
        WRITE(NULERR,*) NPROMA, UBOUND(PGFL,1)
        CALL ABOR1('STORE_MAIN_TRAJ:WRONG FIRST DIM. OF PGFL')
      ENDIF
      IF(NGPBLKS /= UBOUND(PGFL,4)) THEN
        WRITE(NULERR,*) NGPBLKS, UBOUND(PGFL,4)
        CALL ABOR1('STORE_MAIN_TRAJ:WRONG FOURTH DIM. OF PGFL')
      ENDIF
      CALL GSTATS(1052,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO,ICEND,IBL,JFLD,ZR)
      DO JKGLO=1,NGPTOT,NPROMA
        ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)
        IBL=(JKGLO-1)/NPROMA+1

        IF(.NOT.ASSOCIATED(PTRAJEC%MAIN(IBL)%GMV))&
         & CALL ABOR1('STORE_MAIN_TRAJ:TRAJEC%MAIN%GMV NOT ALLOCATED')  

        ! The loops below explicitly from 1 to ICEND prevent from uninitialized values
        ! from ICEND+1 to NPROMA
        DO JFLD=1,YT5%NDIM
          PTRAJEC%MAIN(IBL)%GMV(1:ICEND,1:NFLEVG,JFLD)=PGMV(1:ICEND,1:NFLEVG,JFLD,IBL)
        ENDDO
        DO JFLD=1,YT5%NDIMS
          PTRAJEC%MAIN(IBL)%GMVS(1:ICEND,JFLD)=PGMVS(1:ICEND,JFLD,IBL)
        ENDDO
        DO JFLD=1,YGFL%NDIM5
          PTRAJEC%MAIN(IBL)%GFL(1:ICEND,1:NFLEVG,JFLD)=PGFL(1:ICEND,1:NFLEVG,JFLD,IBL)
        ENDDO
        IF (LSPRT) THEN   
          ! TRAJEC%MAIN%GMV must contain Tv if LSPRT=.T.
          ! At this point PGMV contains real temperature, so it deserved to be 
          ! converted to Tv before storing.
          CALL GPRCP_QLIRSG(NPROMA,1,ICEND,NFLEVG,PQ=PGFL(:,:,YQ%MP,IBL),PR=ZR)
          PTRAJEC%MAIN(IBL)%GMV(1:ICEND,1:NFLEVG,YT5%MT)=ZR(1:ICEND,1:NFLEVG)*&
           & PTRAJEC%MAIN(IBL)%GMV(1:ICEND,1:NFLEVG,YT5%MT)/RD
        ENDIF
      ENDDO
!$OMP END PARALLEL DO
      CALL GSTATS(1052,1)
      IF (LPRTTRAJ) WRITE(NULOUT,*)'GREPTRAJ STORE_MAIN_TRAJ GRID istep=',ISTEP
    ENDIF
    IF(.NOT.LTRAJGP .OR. KSTEP==NSTART) THEN
      CALL COPY_SPA2SPEC(YDGEOMETRY,NS3D,1,NS1D,YDSPEC%SP3D,YDSPEC%SP,YDSPEC%SP1D,PTRAJEC%SPEC(1))
      IF (LPRTTRAJ) WRITE(NULOUT,*)'GREPTRAJ STORE_MAIN_TRAJ SPEC istep=',ISTEP
    ENDIF
  ENDIF
ENDIF

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:STORE_MAIN_TRAJ',1,ZHOOK_HANDLE)
END SUBROUTINE STORE_MAIN_TRAJ

!-----------------------------------------------------------------------

SUBROUTINE GET_TRAJ_SPEC(YDGEOMETRY,YDDIMF,YDTRAJEC,YDGMV,YDGMV5,YDSPEC,KSTEP,LDBACKGR)

USE YOMDIMF     , ONLY : TDIMF
USE GEOMETRY_MOD, ONLY : GEOMETRY

TYPE(GEOMETRY)      , INTENT(IN)    :: YDGEOMETRY
TYPE(TDIMF)         , INTENT(IN)    :: YDDIMF
TYPE(TRAJ_TYPE)     , INTENT(IN)    :: YDTRAJEC
TYPE(TGMV)          , INTENT(INOUT) :: YDGMV
TYPE(TGMV)          , INTENT(INOUT) :: YDGMV5
TYPE(SPECTRAL_FIELD), INTENT(INOUT) :: YDSPEC
INTEGER(KIND=JPIM)  , INTENT(IN)    :: KSTEP
LOGICAL, OPTIONAL   , INTENT(IN)    :: LDBACKGR

INTEGER(KIND=JPIM) :: ISTEP, IUPTRA
REAL(KIND=JPRB) :: ZHOOK_HANDLE
LOGICAL :: LLBACKGR

IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:GET_TRAJ_SPEC',0,ZHOOK_HANDLE)
ASSOCIATE(YDMP=>YDGEOMETRY%YRMP)
ASSOCIATE(NS3D=>YDDIMF%NS3D, NS1D=>YDDIMF%NS1D, &
 & NBSETSP=>YDMP%NBSETSP)

IF (LTRAJGP) THEN
  ISTEP=MSTART
  IF (ISTEP<1) CALL ABOR1('GET_TRAJ_SPEC: MSTART<1')
ELSE
  ISTEP=MSTEPTRAJR(KSTEP)
  IF (ISTEP<1) CALL ABOR1('GET_TRAJ_SPEC: istep<1')
ENDIF

! If LDBACKGR=.true. the background state is read 
IF (PRESENT(LDBACKGR)) THEN
  LLBACKGR=LDBACKGR
ELSE
  LLBACKGR=.FALSE.
ENDIF

IF (LLBACKGR) THEN
  IUPTRA = GET_NUPTRA()
ELSE
  IUPTRA = 1
ENDIF

IF (.NOT.LTRAJGP .OR. ISTEP==MSTART .OR. LLBACKGR) THEN
  CALL COPY_SPEC2SPA(YDGEOMETRY,NS3D,1,NS1D,YDTRAJEC%SPEC(IUPTRA),YDSPEC%SP3D,YDSPEC%SP,YDSPEC%SP1D)
  IF (LPRTTRAJ) WRITE(NULOUT,*)'GREPTRAJ GET_TRAJ_SPEC IUPTRA=',IUPTRA,' LLBACKGR=',LLBACKGR
ELSE
  WRITE(NULERR,*)'GET_TRAJ_SPEC: THIS CALL IS USELESS: ',LTRAJGP,ISTEP,MSTART,LLBACKGR
ENDIF

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:GET_TRAJ_SPEC',1,ZHOOK_HANDLE)
END SUBROUTINE GET_TRAJ_SPEC

!-----------------------------------------------------------------------

SUBROUTINE GET_TRAJ_GRID(YDGEOMETRY,YDML_GCONF,YDTRAJEC,YDGMV,YDGMV5,PGMV,PGMVS,PGFL,KUPTRA)

USE MODEL_GENERAL_CONF_MOD , ONLY : MODEL_GENERAL_CONF_TYPE
USE GEOMETRY_MOD           , ONLY : GEOMETRY

TYPE(GEOMETRY)  , INTENT(IN)    :: YDGEOMETRY
TYPE(MODEL_GENERAL_CONF_TYPE),INTENT(IN):: YDML_GCONF
TYPE(TRAJ_TYPE) , INTENT(IN)    :: YDTRAJEC
TYPE(TGMV)      , INTENT(INOUT) :: YDGMV
TYPE(TGMV)      , INTENT(INOUT) :: YDGMV5
REAL(KIND=JPRB) , INTENT(OUT)   :: PGMV(:,:,:,:)
REAL(KIND=JPRB) , INTENT(OUT)   :: PGMVS(:,:,:)
REAL(KIND=JPRB) , INTENT(OUT)   :: PGFL(:,:,:,:)
INTEGER(KIND=JPIM), INTENT(IN)    :: KUPTRA

INTEGER(KIND=JPIM) :: II, JJ, ILL, IST
LOGICAL :: LLDER, LLUVDER, LLVOR
REAL(KIND=JPRB), ALLOCATABLE :: ZSP(:,:), ZGP(:,:,:), ZSPVOR(:,:), ZSPDIV(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPEC(:,:,:), ZSP1D(:,:)
INTEGER(KIND=JPIM) :: IVSETSC(1+(NSPTRAJ-2)*YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB) :: ZHOOK_HANDLE
INTEGER(KIND=JPIM):: JKGLO,ICEND,IBL

IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:GET_TRAJ_GRID',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM, &
  & YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP, YDDIMF=>YDML_GCONF%YRDIMF)
ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, NRESOL=>YDDIM%NRESOL, &
 & NSPEC2=>YDDIM%NSPEC2, &
 & LUVDER=>YDDIMF%LUVDER, LVOR=>YDDIMF%LVOR, NS1D=>YDDIMF%NS1D, &
 & NFLEVG=>YDDIMV%NFLEVG, NFLEVL=>YDDIMV%NFLEVL, &
 & NGPTOT=>YDGEM%NGPTOT, &
 & NBSETLEV=>YDMP%NBSETLEV, NBSETSP=>YDMP%NBSETSP, &
 & YT5=>YDGMV5%YT5, YGFL=>YDML_GCONF%YGFL)

IF (LTRAJGP) THEN
  CALL GSTATS(1051,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO,ICEND,IBL)
  DO JKGLO=1,NGPTOT,NPROMA
    ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)
! The loops below explicitly from 1 to ICEND prevent from uninitialized values
! from ICEND+1 to NPROMA
    IBL=(JKGLO-1)/NPROMA+1
    IF (.NOT.ASSOCIATED(YDTRAJEC%MAIN(IBL)%GMV))&
      & CALL ABOR1('GET_TRAJ_GRID:YDTRAJEC%MAIN%GMV NOT ALLOCATED')
    PGMV (1:ICEND,:,1:YT5%NDIM,IBL)  =YDTRAJEC%MAIN(IBL)%GMV (1:ICEND,:,1:YT5%NDIM)
    PGMVS(1:ICEND,1:YT5%NDIMS,IBL)   =YDTRAJEC%MAIN(IBL)%GMVS(1:ICEND,1:YT5%NDIMS)
    PGFL (1:ICEND,:,1:YGFL%NDIM5,IBL)=YDTRAJEC%MAIN(IBL)%GFL (1:ICEND,:,1:YGFL%NDIM5)
  ENDDO
!$OMP END PARALLEL DO
  CALL GSTATS(1051,1)
  IF (LPRTTRAJ) WRITE(NULOUT,*)'GREPTRAJ GET_TRAJ_GRID GRID KUPTRA=',KUPTRA
ELSE
  CALL ABOR1('TRAJ_MAIN_MOD:NOT YET DONE/GFL')
  LLDER=.TRUE.
  LLUVDER=LUVDER.AND.LLDER
  LLVOR  =LVOR  .AND.LLDER

  ALLOCATE(ZSPEC(NFLEVL,NSPEC2,NSPTRAJ))
  ALLOCATE(ZSPVOR(NFLEVL,NSPEC2))
  ALLOCATE(ZSPDIV(NFLEVL,NSPEC2))
  ALLOCATE(ZSP(1+NFLEVL*(NSPTRAJ-2),NSPEC2))
  ALLOCATE(ZGP(NPROMA,NGPTRAJ,NGPBLKS))
  ALLOCATE(ZSP1D(NFLEVL,NS1D))

  ZGP(:,:,:)=0.0_JPRB

  CALL COPY_SPEC2SPA(YDGEOMETRY,NSPTRAJ,1,NS1D,YDTRAJEC%SPEC(KUPTRA),ZSPEC,ZSP(1,:),ZSP1D)
  ZSPVOR(:,:)=ZSPEC(:,:,1)
  ZSPDIV(:,:)=ZSPEC(:,:,2)
  IF(NBSETSP == MYSETV) THEN
    JJ=1
  ELSE
    JJ=0
  ENDIF
  CALL GSTATS(1895,0)
!cjfe!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(II,ILL)
  DO II=3,NSPTRAJ
    DO ILL=1,NFLEVL
      JJ=JJ+1
      ZSP(JJ,:)=ZSPEC(ILL,:,II)
    ENDDO
  ENDDO
!cjfe!$OMP END PARALLEL DO
  CALL GSTATS(1895,1)

  IVSETSC(1)=NBSETSP
  JJ=1
  CALL GSTATS(1053,0)
  DO II=3,NSPTRAJ
    IVSETSC(JJ+1:JJ+NFLEVG)=NBSETLEV(:)
    JJ=JJ+NFLEVG
  ENDDO
  CALL GSTATS(1053,1)

  IST=(NSPTRAJ-2)*NFLEVL
  IF(NBSETSP == MYSETV) IST=IST+1
  CALL INV_TRANS(PSPVOR=ZSPVOR, PSPDIV=ZSPDIV,&
   & PSPSCALAR=ZSP(1:IST,:), PGP=ZGP(:,:,:), KRESOL=NRESOL, KPROMA=NPROMA,&
   & LDSCDERS=LLDER,LDVORGP=LLVOR,LDDIVGP=LLDER,LDUVDER=LLUVDER,&
   & KVSETUV=NBSETLEV,KVSETSC=IVSETSC)  

!  PGRID(:,1:ngptraj,:)=ZGP(:,:,:)

  DEALLOCATE(ZSPEC)
  DEALLOCATE(ZSPVOR)
  DEALLOCATE(ZSPDIV)
  DEALLOCATE(ZSP)
  DEALLOCATE(ZGP)
  DEALLOCATE(ZSP1D)
  IF (LPRTTRAJ) WRITE(NULOUT,*)'GREPTRAJ GET_TRAJ_GRID SPEC KUPTRA=',KUPTRA
ENDIF

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:GET_TRAJ_GRID',1,ZHOOK_HANDLE)
END SUBROUTINE GET_TRAJ_GRID

!-----------------------------------------------------------------------

SUBROUTINE READ_TRAJ_GRID(YDGEOMETRY,YDML_GCONF,YDDYN,YDML_LBC,YDTRAJEC,YDMTRAJ,YDGFL,YDGMV,KSTEP,LDLASTRAJ,LDBACKGR)

USE GEOMETRY_MOD           , ONLY : GEOMETRY
USE MODEL_GENERAL_CONF_MOD , ONLY : MODEL_GENERAL_CONF_TYPE
USE YOMDYN                 , ONLY : TDYN
USE YEMLBC_MODEL             , ONLY : TELBC_MODEL
USE MTRAJ_MOD              , ONLY : MTRAJ
USE YOMGFL                 , ONLY : TGFL

TYPE(GEOMETRY)    , INTENT(INOUT) :: YDGEOMETRY  !! INOUT needed for call to READ_SPEC_FROMFA
TYPE(MODEL_GENERAL_CONF_TYPE),INTENT(IN):: YDML_GCONF
TYPE(TDYN)        , INTENT(IN)    :: YDDYN
TYPE(TELBC_MODEL)     , INTENT(IN)    :: YDML_LBC
TYPE(TRAJ_TYPE)   , INTENT(INOUT) :: YDTRAJEC
TYPE(TGFL)        , INTENT(INOUT) :: YDGFL
TYPE(TGMV)        , INTENT(INOUT) :: YDGMV
TYPE(MTRAJ)       , INTENT(INOUT) :: YDMTRAJ
INTEGER(KIND=JPIM), INTENT(IN)    :: KSTEP
LOGICAL           , INTENT(IN)    :: LDLASTRAJ
LOGICAL, OPTIONAL , INTENT(IN)    :: LDBACKGR

INTEGER(KIND=JPIM) :: JSTEP,JKGLO,IEND,IBL
INTEGER(KIND=JPIM) :: J1,J2,J3,J4
CHARACTER(LEN=20) :: CLFILE
REAL(KIND=JPRB), ALLOCATABLE :: ZTRAJGRID3(:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZTRAJGRID2(:,:,:)
INTEGER(KIND=JPIM) :: JGFL,IGP
INTEGER(KIND=JPIM) :: IDIM2,IDIM3,ISUB,IPERSUB,ISTEP
INTEGER(KIND=JPIM) :: IGRIBCD(YDML_GCONF%YGFL%NUMFLDS),IDUM(1)
LOGICAL :: LLNEW, LLBACKGR,LLCLOSE
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:READ_TRAJ_GRID',0,ZHOOK_HANDLE)
ASSOCIATE(YDGMV5=>YDMTRAJ%YRGMV5, &
  & YDDIM=>YDGEOMETRY%YRDIM, YDDIMV=>YDGEOMETRY%YRDIMV, YDGEM=>YDGEOMETRY%YRGEM, &
  & YDMP=>YDGEOMETRY%YRMP, YGFL=>YDML_GCONF%YGFL)

ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, &
 & NFLEVG=>YDDIMV%NFLEVG, &
 & NGPTOT=>YDGEM%NGPTOT, &
 & YCOMP=>YGFL%YCOMP)
! If LDBACKGR=.true. the background state is read 
IF (PRESENT(LDBACKGR)) THEN
  LLBACKGR=LDBACKGR
ELSE
  LLBACKGR=.FALSE.
ENDIF
LLCLOSE = LLBACKGR .OR. LDLASTRAJ
IF (LLBACKGR .AND. KSTEP /= 1) THEN
  WRITE(NULERR,*)'READ_TRAJ_GRID: LLBACKGR, KSTEP ',LLBACKGR, KSTEP
  CALL ABOR1('READ_TRAJ_GRID: If LDBACKGR kstep must be 1 ')
ENDIF

CLFILE='                    '
IF (LLBACKGR) THEN
  CLFILE(1:17)=CFNTRAJBGGRID
ELSE
  CLFILE(1:17)=CFNTRAJHRGRID
ENDIF
WRITE(CLFILE( 7: 8),'(I2.2)')GET_NUPTRA()

IF (N_COUPLED_WINDOWS>0 .AND. .NOT.LLBACKGR) THEN
  IPERSUB=(NSTEPTRAJ-1)/N_COUPLED_WINDOWS
  ISUB=N_COUPLED_WINDOWS-(KSTEP-1)/IPERSUB
  ISTEP=MOD(KSTEP-1,IPERSUB)+1
  IF (KSTEP==NSTEPTRAJ) THEN
    ISUB=1
    ISTEP=IPERSUB+1
  ENDIF
  WRITE(NULOUT,*)'READ_TRAJ_GRID: N_COUPLED_WINDOWS, NSTEPTRAJ=',N_COUPLED_WINDOWS, NSTEPTRAJ
  WRITE(NULOUT,*)'READ_TRAJ_GRID: kstep,ipersub,isub,istep=',KSTEP,IPERSUB,ISUB,ISTEP
  
  IF (IPERSUB*N_COUPLED_WINDOWS/=NSTEPTRAJ-1) CALL ABOR1('READ_TRAJ_GRID: Error ipersub')
  IF (ISUB<1 .OR. ISUB>N_COUPLED_WINDOWS) CALL ABOR1('READ_TRAJ_GRID: Error isub')
  IF (ISTEP<1 .OR. ISTEP>IPERSUB+1) CALL ABOR1('READ_TRAJ_GRID: Error istep')
  CLFILE='TRAJHRXX_YY/trajgrid'
  WRITE(CLFILE( 7: 8),'(I2.2)')GET_NUPTRA()
  WRITE(CLFILE(10:11),'(I2.2)')ISUB
ELSE
  ISTEP=KSTEP
ENDIF

IF (LLBACKGR) THEN
  WRITE(NULOUT,*)'Reading background gridpoint fields from -',CLFILE,'-'
ELSE
  WRITE(NULOUT,*)'Reading main gridpoint trajectory from ',CLFILE
ENDIF

IF (.NOT.LDLASTRAJ .AND. .NOT.LLBACKGR) THEN
  IF(MIOTRAJMAIN(KSTEP)== -1) THEN
    DO JSTEP=1,KSTEP-1
      IF(MIOTRAJMAIN(JSTEP) /= JSTEP)THEN
        WRITE(NULERR,*)'HOLE IN MAIN GRID TRAJ',JSTEP
        CALL ABOR1('READ_TRAJ_GRID:')
      ENDIF
    ENDDO
  ELSE
!   WRITE(NULERR,*)'GRID TRAJ. AT STEP ',KSTEP,'ALREADY READ'
!    CALL ABOR1('READ_TRAJ_GRID:')
  ENDIF
ENDIF

IF (LTRAJGP) THEN

  IDIM3=0
  DO JGFL=1,YGFL%NUMFLDS
    IF ( YCOMP(JGFL)%LTRAJIO ) THEN
      IDIM3=IDIM3+1
      IGRIBCD(IDIM3) = YCOMP(JGFL)%IGRBCODE
    ENDIF
  ENDDO
  IF (IDIM3 == 0) THEN
    WRITE(NULERR,*) 'NO GRIDPOINT FIELDS READ FROM TRAJECTORY'
    CALL ABOR1('READ_TRAJ_GRID:IDIM3=0')
  ENDIF

  LLNEW=(ISTEP==1)

  IDIM2=0
  ALLOCATE(ZTRAJGRID3(NPROMA,NFLEVG,IDIM3,NGPBLKS))
  ALLOCATE(ZTRAJGRID2(0,0,0))
  CALL GSTATS(1055,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J4,J3,J2,J1)
  DO J4=1,NGPBLKS
    DO J3=1,IDIM3
      DO J2=1,NFLEVG
        DO J1=1,NPROMA
          ZTRAJGRID3(J1,J2,J3,J4) = 0.0_JPRB
        ENDDO
      ENDDO
    ENDDO
  ENDDO
!$OMP END PARALLEL DO
  CALL GSTATS(1055,1)

  ! ky: option larpegef_trajhr=T not yet coded,
  !     and option larpegef_trajbg=T not yet coded.
  !     * LLBACKGR=T and larpegef_trajbg=T => read background ARPEGE file
  !       by calling READ_GRID_TRAJ_FROMFA (must call at least SUGRIDUA)
  !     * LLBACKGR=T and larpegef_trajbg=F => read background GRIB file
  !       by calling READ_GRID_TRAJ
  !     * LLBACKGR=F and larpegef_trajhr=T => read trajectory ARPEGE file
  !       by calling READ_GRID_TRAJ_FROMFA (must call at least SUGRIDUA)
  !     * LLBACKGR=F and larpegef_trajhr=F => read trajectory GRIB file
  !       by calling READ_GRID_TRAJ
  !     Missing cases (read ARPEGE files) to be implemented later
  !      (cf. 'nyc'-commented future code).
  !nyc LLARPEGEF= &
  !nyc  &(LARPEGEF_TRAJHR.AND.(.NOT.LLBACKGR)).OR.(LARPEGEF_TRAJBG.AND.LLBACKGR)
  !nyc IF (LLARPEGEF) THEN
  !nyc   CALL READ_GRID_TRAJ_FROMFA(CLFILE,...,LDBACKGR=LLBACKGR)
  !nyc ELSE
  CALL READ_GRID_TRAJ(YDGEOMETRY,TRIM(CLFILE),IGRIBCD,IDUM,IDIM3,IDIM2,&
   & ZTRAJGRID3,ZTRAJGRID2,LLNEW,LDBACKGR=LLBACKGR,LDCLOSE=LLCLOSE)
  !nyc ENDIF

  CALL GSTATS(1056,0)
  ! This seemingly unneccesary copy is because TRAJ_MAIN is real*4
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO,IEND,IBL,IGP,JGFL)
  DO JKGLO=1,NGPTOT,NPROMA
    IEND=MIN(NPROMA,NGPTOT-JKGLO+1)
    IBL=(JKGLO-1)/NPROMA+1
    IGP=1
    DO JGFL=1,YGFL%NUMFLDS
      IF ( YCOMP(JGFL)%LTRAJIO ) THEN
        YDTRAJEC%MAIN(IBL)%GFL(1:IEND,:,YCOMP(JGFL)%MP)=ZTRAJGRID3(1:IEND,:,IGP,IBL)
        IGP=IGP+1
      ENDIF
    ENDDO
  ENDDO
!$OMP END PARALLEL DO
  CALL GSTATS(1056,1)
  DEALLOCATE(ZTRAJGRID3)
  DEALLOCATE(ZTRAJGRID2)
  IF (LPRTTRAJ) THEN
    IF (LLBACKGR) THEN
      WRITE(NULOUT,*)'GREPTRAJ READ_TRAJ_GRID BACKGROUND GRID nuptra=',GET_NUPTRA()
    ELSE
      WRITE(NULOUT,*)'GREPTRAJ READ_TRAJ_GRID GRID istep=',KSTEP
    ENDIF
  ENDIF
ELSE
  IF (LLBACKGR) THEN
    ! ky: option larpegef_trajbg=T not yet coded.
    !     * LLBACKGR=T and larpegef_trajbg=T => read background ARPEGE file
    !       by calling READ_SPEC_FROMFA (must call at least SUSPEC)
    !     * LLBACKGR=T and larpegef_trajbg=F => read background GRIB file
    !       by calling READ_SPEC
    !     Missing cases (read ARPEGE files) to be implemented later.
    IF(.NOT.ASSOCIATED(YDTRAJEC%SPEC)) CALL ABOR1('TRAJ_MAIN_MOD:YDTRAJEC%SPEC NOT ALLOCATED')
    IF (LARPEGEF_TRAJBG) THEN
      ! ky: not yet validated.
      CALL READ_SPEC_FROMFA(YDGEOMETRY,YDGFL,YDML_GCONF,YDDYN,YDML_LBC,KSTEP,YDTRAJEC%SPEC(GET_NUPTRA()),LDBACKGR=LLBACKGR)
    ELSE
      CALL READ_SPEC(YDMP,TRIM(CLFILE),YDTRAJEC%SPEC(GET_NUPTRA()),ISTEP,LDBACKGR=LLBACKGR)
    ENDIF
  ELSE
    IF(.NOT.ASSOCIATED(YDTRAJEC%SPEC)) CALL ABOR1('TRAJ_MAIN_MOD:TRAJ_SPEC NOT ALLOCATED')
    IF (LARPEGEF_TRAJHR) THEN
      ! ky: not yet validated.
      CALL READ_SPEC_FROMFA(YDGEOMETRY,YDGFL,YDML_GCONF,YDDYN,YDML_LBC,KSTEP,YDTRAJEC%SPEC(1),LDBACKGR=LLBACKGR)
    ELSE
      CALL READ_SPEC(YDMP,TRIM(CLFILE),YDTRAJEC%SPEC(1),ISTEP,LDBACKGR=LLBACKGR)
    ENDIF
  ENDIF
ENDIF
!!!!IF (.NOT.LDLASTRAJ) MIOTRAJMAIN(KSTEP)=KSTEP

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:READ_TRAJ_GRID',1,ZHOOK_HANDLE)
END SUBROUTINE READ_TRAJ_GRID

!-----------------------------------------------------------------------

SUBROUTINE READ_TRAJ_SPEC(YDGEOMETRY,YDML_GCONF,YDDYN,YDML_LBC,YDTRAJEC,YDMTRAJ,YDGFL,YDGMV,KSTEP,LDLASTRAJ,LDBACKGR)

USE GEOMETRY_MOD           , ONLY : GEOMETRY
USE MODEL_GENERAL_CONF_MOD , ONLY : MODEL_GENERAL_CONF_TYPE
USE YOMDYN                 , ONLY : TDYN
USE YEMLBC_MODEL           , ONLY : TELBC_MODEL
USE MTRAJ_MOD              , ONLY : MTRAJ
USE YOMGFL                 , ONLY : TGFL

TYPE(GEOMETRY)    , INTENT(INOUT) :: YDGEOMETRY
TYPE(MODEL_GENERAL_CONF_TYPE),INTENT(IN):: YDML_GCONF
TYPE(TDYN)        , INTENT(IN)    :: YDDYN
TYPE(TELBC_MODEL) , INTENT(IN)    :: YDML_LBC
TYPE(TRAJ_TYPE)   , INTENT(INOUT) :: YDTRAJEC
TYPE(TGFL)        , INTENT(INOUT) :: YDGFL
TYPE(TGMV)        , INTENT(INOUT) :: YDGMV
TYPE(MTRAJ)       , INTENT(INOUT) :: YDMTRAJ
INTEGER(KIND=JPIM), INTENT(IN)    :: KSTEP
LOGICAL           , INTENT(IN)    :: LDLASTRAJ
LOGICAL, OPTIONAL , INTENT(IN)    :: LDBACKGR

INTEGER(KIND=JPIM) :: JSTEP, IST,JKGLO,IEND,IBL,JLEV,JL
REAL(KIND=JPRB) :: ZSP2D(1,YDGEOMETRY%YRDIM%NSPEC2), ZSP1D(YDGEOMETRY%YRDIMV%NFLEVL,YDML_GCONF%YRDIMF%NS1D)
LOGICAL :: LLDER, LLUVDER, LLVOR, LLBACKGR
CHARACTER(LEN=20) :: CLFILE
REAL(KIND=JPRB), ALLOCATABLE :: ZGMV(:,:,:,:),ZGMVS(:,:,:),ZGFL(:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZTRAJ_BUF(:,:,:)
REAL(KIND=JPRB) :: ZQ(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRDIM%NGPBLKS)
REAL(KIND=JPRB) :: ZR(YDGEOMETRY%YRDIM%NPROMA,YDGEOMETRY%YRDIMV%NFLEVG)

INTEGER(KIND=JPIM) :: IVSETSC(1)
INTEGER(KIND=JPIM) :: IOFF,IDIM3,ISTGMV,IENGMV,IDIMGMVS,ISTUV,IENUV,ISUB,IPERSUB,ISTEP
INTEGER(KIND=JPIM) :: J
REAL(KIND=JPRB) :: ZHOOK_HANDLE

! Needs to be in this position because of bug in pgf90 5.2-4
#include "gprcp_qlirsg.intfb.h"

IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:READ_TRAJ_SPEC',0,ZHOOK_HANDLE)
ASSOCIATE(YDGMV5=>YDMTRAJ%YRGMV5, YDDIM=>YDGEOMETRY%YRDIM, &
  & YDDIMV=>YDGEOMETRY%YRDIMV, YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP, &
  & YGFL=>YDML_GCONF%YGFL,YDDIMF=>YDML_GCONF%YRDIMF)

ASSOCIATE(NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, NRESOL=>YDDIM%NRESOL, &
 & NSPEC2=>YDDIM%NSPEC2, & 
 & NFLEVG=>YDDIMV%NFLEVG, NFLEVL=>YDDIMV%NFLEVL, &
 & LUVDER=>YDDIMF%LUVDER, NFTHER=>YDDIMF%NFTHER, &
 & LVOR=>YDDIMF%LVOR, NS1D=>YDDIMF%NS1D, &
 & NGPTOT=>YDGEM%NGPTOT, &
 & YT5=>YDGMV5%YT5, &
 & YQ=>YGFL%YQ, &
 & NBSETLEV=>YDMP%NBSETLEV, NBSETSP=>YDMP%NBSETSP)
! If LDBACKGR=.true. the background state is read 
IF (PRESENT(LDBACKGR)) THEN
  LLBACKGR=LDBACKGR
ELSE
  LLBACKGR=.FALSE.
ENDIF

IF (LLBACKGR .AND. KSTEP /= 1) THEN
  WRITE(NULERR,*)'READ_TRAJ_SPEC: LLBACKGR, KSTEP ',LLBACKGR, KSTEP
  CALL ABOR1('READ_TRAJ_SPEC: If LLBACKGR kstep must be 1 ')
ENDIF

CLFILE='                    '
IF (LLBACKGR) THEN
  CLFILE(1:17)=CFNTRAJBGSPEC
ELSE
  CLFILE(1:17)=CFNTRAJHRSPEC
ENDIF

WRITE(CLFILE( 7: 8),'(I2.2)')GET_NUPTRA()

IF (N_COUPLED_WINDOWS>0 .AND. .NOT.LLBACKGR) THEN
  IPERSUB=(NSTEPTRAJ-1)/N_COUPLED_WINDOWS
  ISUB=N_COUPLED_WINDOWS-(KSTEP-1)/IPERSUB
  ISTEP=MOD(KSTEP-1,IPERSUB)+1
  IF (KSTEP==NSTEPTRAJ) THEN
    ISUB=1
    ISTEP=IPERSUB+1
  ENDIF
  WRITE(NULOUT,*)'READ_TRAJ_SPEC: N_COUPLED_WINDOWS, NSTEPTRAJ=',N_COUPLED_WINDOWS, NSTEPTRAJ
  WRITE(NULOUT,*)'READ_TRAJ_SPEC: kstep,ipersub,isub,istep=',KSTEP,IPERSUB,ISUB,ISTEP
  
  IF (IPERSUB*N_COUPLED_WINDOWS/=NSTEPTRAJ-1) CALL ABOR1('READ_TRAJ_SPEC: Error ipersub')
  IF (ISUB<1 .OR. ISUB>N_COUPLED_WINDOWS) CALL ABOR1('READ_TRAJ_SPEC: Error isub')
  IF (ISTEP<1 .OR. ISTEP>IPERSUB+1) CALL ABOR1('READ_TRAJ_SPEC: Error istep')
  CLFILE='TRAJHRXX_YY/trajspec'
  WRITE(CLFILE( 7: 8),'(I2.2)')GET_NUPTRA()
  WRITE(CLFILE(10:11),'(I2.2)')ISUB
ELSE
  ISTEP=KSTEP
ENDIF

IF (.NOT.LDLASTRAJ .AND. .NOT. LLBACKGR) THEN
  IF(MIOTRAJMAIN(KSTEP)== -1) THEN
    DO JSTEP=1,KSTEP-1
      IF(MIOTRAJMAIN(JSTEP) /= JSTEP)THEN
        WRITE(NULERR,*)'HOLE IN MAIN SPEC TRAJ',JSTEP
        CALL ABOR1('READ_TRAJ_SPEC:')
      ENDIF
    ENDDO
  ELSE
    IF (LTRAJRESET) THEN
      WRITE(NULOUT,*)'GREPTRAJ Reading spectral trajectory at step ',KSTEP,' again.'
    ELSE
      WRITE(NULERR,*)'TRAJ. AT STEP ',KSTEP,'ALREADY READ'
      CALL ABOR1('READ_TRAJ_SPEC:')
    ENDIF
  ENDIF
ENDIF

IF (LTRAJGP) THEN

  IF (LLBACKGR) THEN
    IF(.NOT.ASSOCIATED(YDTRAJEC%SPEC)) CALL ABOR1('TRAJ_MAIN_MOD:YDTRAJ%SPEC NOT ALLOCATED')
    IF (LARPEGEF_TRAJBG) THEN
      CALL READ_SPEC_FROMFA(YDGEOMETRY,YDGFL,YDML_GCONF,YDDYN,YDML_LBC,KSTEP,YDTRAJEC%SPEC(GET_NUPTRA()),LDBACKGR=LLBACKGR)
    ELSE
      CALL READ_SPEC(YDMP,TRIM(CLFILE),YDTRAJEC%SPEC(GET_NUPTRA()),ISTEP,LDBACKGR=LLBACKGR)
    ENDIF
  ELSE
    IF (.NOT.LDLASTRAJ) THEN
      IF(.NOT.ASSOCIATED(YDTRAJEC%SPEC)) CALL ABOR1('TRAJ_MAIN_MOD:TRAJ_SPEC NOT ALLOCATED')
      IF (LARPEGEF_TRAJHR) THEN
        CALL READ_SPEC_FROMFA(YDGEOMETRY,YDGFL,YDML_GCONF,YDDYN,YDML_LBC,KSTEP,YDTRAJEC%SPEC(1),LDBACKGR=LLBACKGR)
      ELSE
        CALL READ_SPEC(YDMP,TRIM(CLFILE),YDTRAJEC%SPEC(1),ISTEP,LDBACKGR=LLBACKGR)
      ENDIF
  
      IF(KSTEP == MSTART) THEN
        TRAJ_SPEC_TMP0=YDTRAJEC%SPEC(1)
      ENDIF
    ELSE
      YDTRAJEC%SPEC(1)=TRAJ_SPEC_TMP0
      WRITE(NULOUT,*)'GREPTRAJ testing: kstep MSTART  ',KSTEP,MSTART
    ENDIF
  ENDIF


  ! Only Vor, Div, Tem are read in as spectral fields if LREADGPTRAJ

  ALLOCATE(ZTRAJ_BUF(NFLEVL,NSPEC2,NSPTRAJ))
  IF (LLBACKGR) THEN
    CALL COPY_SPEC2SPA(YDGEOMETRY,NSPTRAJ,1,NS1D,YDTRAJEC%SPEC(GET_NUPTRA()),ZTRAJ_BUF,ZSP2D,ZSP1D)
  ELSE
    CALL COPY_SPEC2SPA(YDGEOMETRY,NSPTRAJ,1,NS1D,YDTRAJEC%SPEC(1),ZTRAJ_BUF,ZSP2D,ZSP1D)
  ENDIF

! TRANSINV_MDL cannot be used because the number of fields in
! SP5HV is hard wired inside TRANSINV_MDL. In particular, if LGPQ
! and/or LGPO3, transforms would not be performed for these fields.

  LLDER=.TRUE.
  LLUVDER=LUVDER.AND.LLDER
  LLVOR  =LVOR  .AND.LLDER

  IF(NBSETSP == MYSETV) THEN
    IST=1
  ELSE
    IST=0
  ENDIF
  IVSETSC(1)=NBSETSP

  ISTUV=1
  IENUV=YT5%NDIMUV
  IDIMGMVS=YT5%NDIMS
  ISTGMV=YT5%NDIMUV+1
  IENGMV=YT5%NDIM
  IOFF=YGFL%NUMFLDS-YGFL%NUMSPFLDS
  IDIM3=YGFL%NUMSPFLDS
  IF(LLDER) IDIM3=IDIM3*3
  
  ALLOCATE(ZGMV(NPROMA,NFLEVG,IENGMV,NGPBLKS))
  ALLOCATE(ZGMVS(NPROMA,IDIMGMVS,NGPBLKS))
  ALLOCATE(ZGFL(NPROMA,NFLEVG,YGFL%NDIM5,NGPBLKS))
  ZGMV(:,:,ISTUV:IENUV,1:NGPBLKS)=0.0_JPRB
  ZGMVS(:,1:IDIMGMVS,1:NGPBLKS)=0.0_JPRB
  ZGMV(:,:,ISTGMV:IENGMV,1:NGPBLKS)=0.0_JPRB 
  IF (.NOT.LREADGPTRAJ) THEN
    ZGFL(:,:,IOFF+1:IOFF+IDIM3,NGPBLKS)=0.0_JPRB
    IF (LELAM) THEN 
      WRITE(NULOUT,*) "READ_TRAJ_SPEC : Call EINV_TRANS"
      CALL EINV_TRANS(&
       & PSPVOR=ZTRAJ_BUF(:,:,1),PSPDIV=ZTRAJ_BUF(:,:,2),PSPSC2=ZSP2D(1:IST,:),&
       & PSPSC3A=ZTRAJ_BUF(:,:,3:3+NFTHER-1),&
       & LDSCDERS=LLDER,LDVORGP=LLVOR,LDDIVGP=LLDER,LDUVDER=LLUVDER,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
       & KVSETSC3A=NBSETLEV,&
       & PGPUV=ZGMV(:,:,ISTUV:IENUV,:),&
       & PGP2 =ZGMVS(:,1:IDIMGMVS,:),&
       & PGP3A=ZGMV(:,:,ISTGMV:IENGMV,:),&
       & PMEANU=ZSP1D(:,1),PMEANV=ZSP1D(:,2))
    ELSE
      CALL INV_TRANS(&
       & PSPVOR=ZTRAJ_BUF(:,:,1),PSPDIV=ZTRAJ_BUF(:,:,2),PSPSC2=ZSP2D(1:IST,:),&
       & PSPSC3A=ZTRAJ_BUF(:,:,3:3+NFTHER-1),&
       & PSPSC3B=ZTRAJ_BUF(:,:,4:),&
       & LDSCDERS=LLDER,LDVORGP=LLVOR,LDDIVGP=LLDER,LDUVDER=LLUVDER,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
       & KVSETSC3A=NBSETLEV,KVSETSC3B=NBSETLEV,&
       & PGPUV=ZGMV(:,:,ISTUV:IENUV,:),&
       & PGP2 =ZGMVS(:,1:IDIMGMVS,:),&
       & PGP3A=ZGMV(:,:,ISTGMV:IENGMV,:),&
       & PGP3B=ZGFL(:,:,IOFF+1:IOFF+IDIM3,:))  
    ENDIF
  ELSE
    IF (LELAM) THEN
      WRITE(NULOUT,*) "READ_TRAJ_VEC : Call EINV_TRANS"
      CALL EINV_TRANS(&
       & PSPVOR=ZTRAJ_BUF(:,:,1),PSPDIV=ZTRAJ_BUF(:,:,2),PSPSC2=ZSP2D(1:IST,:),&
       & PSPSC3A=ZTRAJ_BUF(:,:,3:3+NFTHER-1),&
       & LDSCDERS=LLDER,LDVORGP=LLVOR,LDDIVGP=LLDER,LDUVDER=LLUVDER,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(:),&
       & KVSETSC3A=NBSETLEV,&
       & PGPUV=ZGMV(:,:,ISTUV:IENUV,:),&
       & PGP2 =ZGMVS(:,1:IDIMGMVS,:),&
       & PGP3A=ZGMV(:,:,ISTGMV:IENGMV,:),&
       & PMEANU=ZSP1D(:,1),PMEANV=ZSP1D(:,2))
    ELSE
      CALL INV_TRANS(&
       & PSPVOR=ZTRAJ_BUF(:,:,1),PSPDIV=ZTRAJ_BUF(:,:,2),PSPSC2=ZSP2D(1:IST,:),&
       & PSPSC3A=ZTRAJ_BUF(:,:,3:3+NFTHER-1),&
       & LDSCDERS=LLDER,LDVORGP=LLVOR,LDDIVGP=LLDER,LDUVDER=LLUVDER,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(:),&
       & KVSETSC3A=NBSETLEV,&
       & PGPUV=ZGMV(:,:,ISTUV:IENUV,:),&
       & PGP2 =ZGMVS(:,1:IDIMGMVS,:),&
       & PGP3A=ZGMV(:,:,ISTGMV:IENGMV,:))
    ENDIF
  ENDIF

  IF (LSPRT) THEN
    ! Convert both grid point and spectral trajectory temperature to Tv if LSPRT=.t.
    ! Ignore CLWC and CIWC effects
    IF (.NOT.LREADGPTRAJ) THEN
      CALL GSTATS(1059,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
      DO J=1,NGPBLKS
        ZQ(:,:,J)=ZGFL(:,:,YQ%MP,J)
      ENDDO
!$OMP END PARALLEL DO
      CALL GSTATS(1059,1)
    ELSE
      ! Humidity is read in from file in the call to the READ_TRAJ_GRID routine.
      ! This is done just before the call to this routine (READ_TRAJ_SPEC)
      IF (LLBACKGR) THEN
        CALL GSTATS(1059,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
        DO J=1,NGPBLKS
          ZQ(:,:,J)=YDTRAJEC%MAIN(J)%GFL(:,:,YQ%MP)
        ENDDO
!$OMP END PARALLEL DO
        CALL GSTATS(1059,1)
      ELSE
        CALL GSTATS(1059,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(J)
        DO J=1,NGPBLKS
          ! TRAJEC works with true timestep which is here NSTEP=kstep-1
          ZQ(:,:,J)=YDTRAJEC%MAIN(J)%GFL(:,:,YQ%MP)
        ENDDO
!$OMP END PARALLEL DO
        CALL GSTATS(1059,1)
      ENDIF
    ENDIF
    CALL GSTATS(1057,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) &
!$OMP&PRIVATE(JKGLO,IST,IEND,JLEV,JL,IBL,ZR)
    DO JKGLO=1,NGPTOT,NPROMA
      IST =1
      IEND=MIN(NPROMA,NGPTOT-JKGLO+1)
      IBL=(JKGLO-1)/NPROMA+1
      CALL GPRCP_QLIRSG (NPROMA,IST,IEND,NFLEVG,PQ=ZQ(:,:,IBL),PR=ZR)

      DO JLEV=1,NFLEVG
        DO JL=IST,IEND
          ZGMV(JL,JLEV,YT5%MT,IBL)=ZR(JL,JLEV)*&
           & ZGMV(JL,JLEV,YT5%MT,IBL)/RD
        ENDDO
      ENDDO
    ENDDO
!$OMP END PARALLEL DO
    CALL GSTATS(1057,1)
    !
    ! Replace T by Tv in ZTRAJ_BUF and TRAJEC%spec(1)
    IF (LELAM) THEN
        CALL EDIR_TRANS(PSPSCALAR=ZTRAJ_BUF(:,:,3),&
          & KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,&
          & PGP=ZGMV(:,:,YT5%MT,:))
    ELSE
        CALL DIR_TRANS(PSPSCALAR=ZTRAJ_BUF(:,:,3),&
          & KVSETSC=NBSETLEV,KRESOL=NRESOL,KPROMA=NPROMA,&
          & PGP=ZGMV(:,:,YT5%MT,:))
    ENDIF
    IF (LLBACKGR) THEN
      CALL COPY_SPA2SPEC(YDGEOMETRY,NSPTRAJ,1,NS1D,ZTRAJ_BUF,ZSP2D,ZSP1D,YDTRAJEC%SPEC(GET_NUPTRA()))
    ELSE
      CALL COPY_SPA2SPEC(YDGEOMETRY,NSPTRAJ,1,NS1D,ZTRAJ_BUF,ZSP2D,ZSP1D,YDTRAJEC%SPEC(1))
    ENDIF
  ENDIF

  CALL GSTATS(1058,0)
!This seemingly unneccesary copy is because TRAJ_MAIN is real*4
! If LSPRT TRAJEC%MAIN%GMV contains virtual temperature
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO,IEND,IBL)
  DO JKGLO=1,NGPTOT,NPROMA
    IEND=MIN(NPROMA,NGPTOT-JKGLO+1)
    IBL=(JKGLO-1)/NPROMA+1
    IF (LLBACKGR) THEN
      YDTRAJEC%MAIN(IBL)%GMV(1:IEND,:,ISTUV:IENUV)=ZGMV(1:IEND,:,ISTUV:IENUV,IBL)
      YDTRAJEC%MAIN(IBL)%GMVS(1:IEND,1:IDIMGMVS)=ZGMVS(1:IEND,1:IDIMGMVS,IBL)
      YDTRAJEC%MAIN(IBL)%GMV(1:IEND,:,ISTGMV:IENGMV)=ZGMV(1:IEND,:,ISTGMV:IENGMV,IBL)
      IF (.NOT.LREADGPTRAJ) THEN
        YDTRAJEC%MAIN(IBL)%GFL(1:IEND,:,IOFF+1:IOFF+IDIM3)=&
         & ZGFL(1:IEND,:,IOFF+1:IOFF+IDIM3,IBL)
      ENDIF
    ELSE
      ! TRAJEC works with true timestep which is here NSTEP=kstep-1
      YDTRAJEC%MAIN(IBL)%GMV(1:IEND,:,ISTUV:IENUV)  =ZGMV(1:IEND,:,ISTUV:IENUV,IBL)
      YDTRAJEC%MAIN(IBL)%GMVS(1:IEND,1:IDIMGMVS)    =ZGMVS(1:IEND,1:IDIMGMVS,IBL)
      YDTRAJEC%MAIN(IBL)%GMV(1:IEND,:,ISTGMV:IENGMV)=ZGMV(1:IEND,:,ISTGMV:IENGMV,IBL)
      IF (.NOT.LREADGPTRAJ) THEN
        YDTRAJEC%MAIN(IBL)%GFL(1:IEND,:,IOFF+1:IOFF+IDIM3)=&
         & ZGFL(1:IEND,:,IOFF+1:IOFF+IDIM3,IBL)
      ENDIF
    ENDIF
  ENDDO
!$OMP END PARALLEL DO
  CALL GSTATS(1058,1)

  DEALLOCATE(ZTRAJ_BUF)
  IF (LPRTTRAJ) THEN
    IF (LLBACKGR) THEN
      WRITE(NULOUT,*)'GREPTRAJ READ_TRAJ_SPEC BACKGROUND GRID nuptra=',GET_NUPTRA()
    ELSE
      WRITE(NULOUT,*)'GREPTRAJ READ_TRAJ_SPEC GRID istep=',KSTEP
    ENDIF
  ENDIF
  DEALLOCATE(ZGFL)
  DEALLOCATE(ZGMV)
  DEALLOCATE(ZGMVS)
ELSE
  IF (LLBACKGR) THEN
    IF(.NOT.ASSOCIATED(YDTRAJEC%SPEC)) CALL ABOR1('TRAJ_MAIN_MOD:YDTRAJEC%SPEC NOT ALLOCATED')
    IF (LARPEGEF_TRAJBG) THEN
      ! ky: not yet validated.
      CALL READ_SPEC_FROMFA(YDGEOMETRY,YDGFL,YDML_GCONF,YDDYN,YDML_LBC,KSTEP,YDTRAJEC%SPEC(GET_NUPTRA()),LDBACKGR=LLBACKGR)
    ELSE
      CALL READ_SPEC(YDMP,TRIM(CLFILE),YDTRAJEC%SPEC(GET_NUPTRA()),ISTEP,LDBACKGR=LLBACKGR)
    ENDIF
    IF (LPRTTRAJ) WRITE(NULOUT,*)'GREPTRAJ READ_TRAJ_SPEC BACKGROUND SPEC nuptra=',GET_NUPTRA()
  ELSE
    IF(.NOT.ASSOCIATED(YDTRAJEC%SPEC)) CALL ABOR1('TRAJ_MAIN_MOD:TRAJ_SPEC NOT ALLOCATED')
    IF (LARPEGEF_TRAJHR) THEN
      CALL READ_SPEC_FROMFA(YDGEOMETRY,YDGFL,YDML_GCONF,YDDYN,YDML_LBC,KSTEP,YDTRAJEC%SPEC(1),LDBACKGR=LLBACKGR)
    ELSE
      CALL READ_SPEC(YDMP,TRIM(CLFILE),YDTRAJEC%SPEC(1),ISTEP,LDBACKGR=LLBACKGR)
    ENDIF
    IF (LPRTTRAJ) WRITE(NULOUT,*)'GREPTRAJ READ_TRAJ_SPEC SPEC istep=',KSTEP
  ENDIF
ENDIF
IF (.NOT.LDLASTRAJ) MIOTRAJMAIN(KSTEP)=KSTEP

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('TRAJ_MAIN_MOD:READ_TRAJ_SPEC',1,ZHOOK_HANDLE)
END SUBROUTINE READ_TRAJ_SPEC
!-----------------------------------------------------------------------

END MODULE TRAJ_MAIN_MOD



