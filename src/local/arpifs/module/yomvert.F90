MODULE YOMVERT

USE PARKIND1 , ONLY : JPIM, JPRB, JPRD
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK
USE YOMCT0   , ONLY : LNHDYN
USE YOMCVER  , ONLY : LVERTFE, LVFE_ECMWF, LVFE_GW, LVFE_GW_HALF, NVFE_TYPE
USE YOMDYNA  , ONLY : LGWADV

IMPLICIT NONE

SAVE

!     ------------------------------------------------------------------

!*    * DEFINING THE VERTICAL COORDINATE: A and B

!     VP00  : REFERENCE PRESSURE FOR DEFINING VERTICAL COORDINATE
!     VALH  : (0:NFLEVG)
!     VBH   : (0:NFLEVG) : B of the vertical coordinate
!     VAH   : (0:NFLEVG) ;  =VALH*VP00
!     VC    : (NFLEVG)   ;  =VAH(J)*VBH(J-1)-VAH(J-1)*VBH(J)
!     VDELB : (NFLEVG)   ;  =VBH(J)-VBH(J-1)
!     VDELA : (NFLEVG)   ;  =VAH(J)-VAH(J-1)
!     VAF   : like VAH but at full levels.
!     VBF   : like VBH but at full levels.
!     VRATH : VBH(J)*VP00/(VAH(J)+VBH(J)*VP00) with bounding near the top; always 0 at the top.
!     VRATF : full level version of VRATH, with bounding near the top.
!     TOPPRES: REFERENCE "EVANESCENT" PRESSURE
!              TOPPRES allows to solve some calculations of singularities
!              when the top pressure of the model is zero (for ex. in
!              GPPREF, GPXYB, SUNHBMAT).

!     WE HAVE THEN FOR THE HALF LEVEL PRESSURE : VAH + VBH*(SURFACE PRESSURE)


!! scalar reference values moved out from type TVAB
REAL(KIND=JPRB)         :: VP00
REAL(KIND=JPRB)         :: TOPPRES

TYPE TVAB
  REAL(KIND=JPRB), ALLOCATABLE :: VALH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VBH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VC(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VAF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VBF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VDELA(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VDELB(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VRATH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VRATF(:)
END TYPE TVAB

!     ------------------------------------------------------------------

!*    * DEFINING THE VERTICAL COORDINATE: eta

!     VETAH : (0:NFLEVG) ; VERTICAL COORDINATE = VALH+VBH
!     VFE_ETAH : version of VETAH used for VFE operators.
!     VETAF : (0:NFLEVG+1) ; VERTICAL COORDINATE ON LAYERS.
!     VFE_ETAF : version of VETAF used for VFE operators.
!     VFE_RDETAH: VFE_RDETAH(jlev)=1/(VFE_ETAH(jlev)-VFE_ETAH(jlev-1))

TYPE TVETA
  REAL(KIND=JPRB), ALLOCATABLE :: VETAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VFE_ETAH(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VETAF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VFE_ETAF(:)
  REAL(KIND=JPRB), ALLOCATABLE :: VFE_RDETAH(:)
END TYPE TVETA

! -----------------------------------------------------------------------------

! * Finite element vertical discretisation 
! ----------------------------------------
! VFE_KNOT       : internal knots

! * Matricial operators related to vertical discretisation in finite elements
!   (to compute integrals or derivatives):
! -----------------------------------------------------------------------------
! * Integral operators on full levels
! RINTE    : without boundary conditions defined
! RINTBF00 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, X_{L+1}=0
!            output boundary conditions: KX_0=0
! RINTBF11 : with explicitely given top and bottom BC;
!            input boundary conditions: (dX/deta)_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: KX_0=0

! * First derivative operators on full levels
! RDERI    : without boundary conditions defined
! RDERB    = RDERBF00
! RDERBF00 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, X_{L+1}=X_L
!            output boundary conditions: none
! RDERBF01 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: DX_{L+1}=0
! RDERBF10 : with explicitely given top and bottom BC;
!            input boundary conditions: X_{L+1}=0, (dX/deta)_0=0
!            output boundary conditions: DX_0=0
! RDERBF11 : with explicitely given top and bottom BC;
!            input boundary conditions: (dX/deta)_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: DX_{L+1}=0

! * First derivative operators from full levels to half levels
! RDERBH00 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, X_L+1=X_L
!            output boundary conditions: none
! RDERBH01 : with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: none

! * Second derivative operators on full levels
! RDDERI   : without boundary conditions
! RDDERBF01: with explicitely given top and bottom BC;
!            input boundary conditions: X_0=0, (dX/deta)_{L+1}=0
!            output boundary conditions: DDX_{L+1}=0

! * Invertible matricial operators for transformations gw<->d
! RDERGW   : derivative operator 
! RINTGW   : integral operator 

! -----------------------------------------------------------------------------

TYPE TVFE
  REAL(KIND=JPRB),ALLOCATABLE :: VFE_KNOT(:)
  REAL(KIND=JPRB),ALLOCATABLE :: RINTE(:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RINTBF00 (:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RINTBF11 (:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: D_RINTE(:,:)
  REAL(KIND=JPRD),ALLOCATABLE :: D_RINTBF11 (:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDERI(:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDERB(:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDERBF00 (:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDERBF01 (:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDERBF10 (:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDERBF11 (:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDERBH00 (:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDERBH01 (:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDDERI(:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDDERBF01(:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RINTGW(:,:)
  REAL(KIND=JPRB),ALLOCATABLE :: RDERGW(:,:)
END TYPE TVFE

TYPE TVERTICAL_GEOM
  TYPE(TVAB) :: YRVAB 
  TYPE(TVETA):: YRVETA
  TYPE(TVFE) :: YRVFE 
END TYPE TVERTICAL_GEOM

CONTAINS 

SUBROUTINE ALLOC_COPY_VERTICAL_GEOM( THIS, YDVAB, YDVETA, YDVFE )
  IMPLICIT NONE
  TYPE(TVERTICAL_GEOM),INTENT(INOUT) :: THIS
  TYPE(TVAB)          ,INTENT(IN)    :: YDVAB
  TYPE(TVETA)         ,INTENT(IN)    :: YDVETA
  TYPE(TVFE)          ,INTENT(IN)    :: YDVFE
  
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VALH  , YDVAB%VALH  )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VAH   , YDVAB%VAH   )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VBH   , YDVAB%VBH   )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VC    , YDVAB%VC    )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VDELB , YDVAB%VDELB )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VRATH , YDVAB%VRATH )
  CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VRATF , YDVAB%VRATF )
  CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VETAH, YDVETA%VETAH)
  CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VETAF, YDVETA%VETAF)
  THIS%YRVAB%VALH   = YDVAB%VALH
  THIS%YRVAB%VBH    = YDVAB%VBH
  THIS%YRVAB%VAH    = YDVAB%VAH
  THIS%YRVAB%VC     = YDVAB%VC
  THIS%YRVAB%VDELB  = YDVAB%VDELB
  THIS%YRVAB%VRATH  = YDVAB%VRATH
  THIS%YRVAB%VRATF  = YDVAB%VRATF
  THIS%YRVETA%VETAH = YDVETA%VETAH
  THIS%YRVETA%VETAF = YDVETA%VETAF

  IF (LVERTFE) THEN
    CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VFE_ETAH     , YDVETA%VFE_ETAH     )
    CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VFE_ETAF     , YDVETA%VFE_ETAF     )
    CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VAF   , YDVAB%VAF   )
    CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VBF   , YDVAB%VBF   )
    CALL ALLOC_SIZEOF_1D(THIS%YRVAB%VDELA , YDVAB%VDELA )
    CALL ALLOC_SIZEOF_1D(THIS%YRVETA%VFE_RDETAH   , YDVETA%VFE_RDETAH   )
    THIS%YRVAB%VAF         = YDVAB%VAF
    THIS%YRVAB%VBF         = YDVAB%VBF
    THIS%YRVAB%VDELA       = YDVAB%VDELA
    THIS%YRVETA%VFE_ETAH   = YDVETA%VFE_ETAH
    THIS%YRVETA%VFE_ETAF   = YDVETA%VFE_ETAF
    THIS%YRVETA%VFE_RDETAH = YDVETA%VFE_RDETAH
    IF(.NOT.LVFE_ECMWF.AND.NVFE_TYPE>1)THEN
      CALL ALLOC_SIZEOF_1D(THIS%YRVFE%VFE_KNOT  ,  YDVFE%VFE_KNOT  )
      THIS%YRVFE%VFE_KNOT  =  YDVFE%VFE_KNOT
    ENDIF

!*       1.3   VFE INTEGRAL AND DERIVATIVE OPERATORS

    IF (LVFE_ECMWF) THEN
      CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RINTE     ,  YDVFE%RINTE     )
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%D_RINTE   ,  YDVFE%D_RINTE   )
      CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDERI     ,  YDVFE%RDERI     )
      CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDERB     ,  YDVFE%RDERB     )
      CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDDERI    ,  YDVFE%RDDERI    )
      THIS%YRVFE%RINTE     =  YDVFE%RINTE
      THIS%YRVFE%D_RINTE   =  YDVFE%D_RINTE
      THIS%YRVFE%RDERI     =  YDVFE%RDERI
      IF (LNHDYN) THEN
        CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDERB     ,  YDVFE%RDERB     )
        CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDDERI    ,  YDVFE%RDDERI    )
        THIS%YRVFE%RDERB     =  YDVFE%RDERB
        THIS%YRVFE%RDDERI    =  YDVFE%RDDERI
      ENDIF
    ELSE
      CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RINTBF11  ,  YDVFE%RINTBF11  )
      CALL D_ALLOC_SIZEOF_2D(THIS%YRVFE%D_RINTBF11,  YDVFE%D_RINTBF11)
      CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF00  ,  YDVFE%RDERBF00  )
      CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF01  ,  YDVFE%RDERBF01  )
      CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF10  ,  YDVFE%RDERBF10  )
      CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBF11  ,  YDVFE%RDERBF11  )
      THIS%YRVFE%RINTBF11  = YDVFE%RINTBF11 
      THIS%YRVFE%D_RINTBF11 = YDVFE%D_RINTBF11 
      THIS%YRVFE%RDERBF00  =  YDVFE%RDERBF00
      THIS%YRVFE%RDERBF01  =  YDVFE%RDERBF01
      THIS%YRVFE%RDERBF10  =  YDVFE%RDERBF10
      THIS%YRVFE%RDERBF11  =  YDVFE%RDERBF11
      IF (LNHDYN) THEN
        CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBH00  ,  YDVFE%RDERBH00  )
        CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDERBH01  ,  YDVFE%RDERBH01  )
        THIS%YRVFE%RDERBH00   =  YDVFE%RDERBH00
        THIS%YRVFE%RDERBH01   =  YDVFE%RDERBH01
        IF (LGWADV.AND.(LVFE_GW.OR.LVFE_GW_HALF)) THEN
          CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RINTBF00  ,  YDVFE%RINTBF00  )
          CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RINTGW   ,   YDVFE%RINTGW    )
          CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDERGW   ,   YDVFE%RDERGW    )
          THIS%YRVFE%RINTBF00  =  YDVFE%RINTBF00
          THIS%YRVFE%RINTGW = YDVFE%RINTGW
          THIS%YRVFE%RDERGW = YDVFE%RDERGW
        ENDIF
        CALL ALLOC_SIZEOF_2D(THIS%YRVFE%RDDERBF01 ,  YDVFE%RDDERBF01 )
        THIS%YRVFE%RDDERBF01 =  YDVFE%RDDERBF01
      ENDIF
    ENDIF
  ENDIF

END SUBROUTINE ALLOC_COPY_VERTICAL_GEOM 

SUBROUTINE DEALLOC_VERTICAL_GEOM( THIS )
  IMPLICIT NONE
  TYPE(TVERTICAL_GEOM),INTENT(INOUT) :: THIS
  
  !! YRVAB
  IF (ALLOCATED(THIS%YRVAB%VALH) ) DEALLOCATE(THIS%YRVAB%VALH  )
  IF (ALLOCATED(THIS%YRVAB%VBH)  ) DEALLOCATE(THIS%YRVAB%VBH   )
  IF (ALLOCATED(THIS%YRVAB%VAH)  ) DEALLOCATE(THIS%YRVAB%VAH   )
  IF (ALLOCATED(THIS%YRVAB%VC)   ) DEALLOCATE(THIS%YRVAB%VC    )
  IF (ALLOCATED(THIS%YRVAB%VAF)  ) DEALLOCATE(THIS%YRVAB%VAF   )
  IF (ALLOCATED(THIS%YRVAB%VBF)  ) DEALLOCATE(THIS%YRVAB%VBF   )
  IF (ALLOCATED(THIS%YRVAB%VDELA)) DEALLOCATE(THIS%YRVAB%VDELA )
  IF (ALLOCATED(THIS%YRVAB%VDELB)) DEALLOCATE(THIS%YRVAB%VDELB )
  IF (ALLOCATED(THIS%YRVAB%VRATH)) DEALLOCATE(THIS%YRVAB%VRATH )
  IF (ALLOCATED(THIS%YRVAB%VRATF)) DEALLOCATE(THIS%YRVAB%VRATF )

  !! YRVETA
  IF (ALLOCATED(THIS%YRVETA%VETAH)       ) DEALLOCATE(THIS%YRVETA%VETAH        )
  IF (ALLOCATED(THIS%YRVETA%VFE_ETAH)    ) DEALLOCATE(THIS%YRVETA%VFE_ETAH     )
  IF (ALLOCATED(THIS%YRVETA%VETAF)       ) DEALLOCATE(THIS%YRVETA%VETAF        )
  IF (ALLOCATED(THIS%YRVETA%VFE_ETAF)    ) DEALLOCATE(THIS%YRVETA%VFE_ETAF     )
  IF (ALLOCATED(THIS%YRVETA%VFE_RDETAH)  ) DEALLOCATE(THIS%YRVETA%VFE_RDETAH   )

  !! YRVFE
  IF (ALLOCATED(THIS%YRVFE%VFE_KNOT) ) DEALLOCATE(THIS%YRVFE%VFE_KNOT  )
  IF (ALLOCATED(THIS%YRVFE%RINTE)    ) DEALLOCATE(THIS%YRVFE%RINTE     )
  IF (ALLOCATED(THIS%YRVFE%RINTBF00) ) DEALLOCATE(THIS%YRVFE%RINTBF00  )
  IF (ALLOCATED(THIS%YRVFE%RINTBF11) ) DEALLOCATE(THIS%YRVFE%RINTBF11  )  
  IF (ALLOCATED(THIS%YRVFE%D_RINTE)    ) DEALLOCATE(THIS%YRVFE%D_RINTE     )
  IF (ALLOCATED(THIS%YRVFE%D_RINTBF11) ) DEALLOCATE(THIS%YRVFE%D_RINTBF11  )  
  IF (ALLOCATED(THIS%YRVFE%RDERI)    ) DEALLOCATE(THIS%YRVFE%RDERI     )
  IF (ALLOCATED(THIS%YRVFE%RDERB)    ) DEALLOCATE(THIS%YRVFE%RDERB     )
  IF (ALLOCATED(THIS%YRVFE%RDERBF00) ) DEALLOCATE(THIS%YRVFE%RDERBF00  )
  IF (ALLOCATED(THIS%YRVFE%RDERBF01) ) DEALLOCATE(THIS%YRVFE%RDERBF01  )
  IF (ALLOCATED(THIS%YRVFE%RDERBF10) ) DEALLOCATE(THIS%YRVFE%RDERBF10  )
  IF (ALLOCATED(THIS%YRVFE%RDERBF11) ) DEALLOCATE(THIS%YRVFE%RDERBF11  )
  IF (ALLOCATED(THIS%YRVFE%RDERBH00) ) DEALLOCATE(THIS%YRVFE%RDERBH00  )
  IF (ALLOCATED(THIS%YRVFE%RDERBH01) ) DEALLOCATE(THIS%YRVFE%RDERBH01  )
  IF (ALLOCATED(THIS%YRVFE%RDDERI)   ) DEALLOCATE(THIS%YRVFE%RDDERI    )
  IF (ALLOCATED(THIS%YRVFE%RDDERBF01)) DEALLOCATE(THIS%YRVFE%RDDERBF01 )
  IF (ALLOCATED(THIS%YRVFE%RINTGW)) DEALLOCATE(THIS%YRVFE%RINTGW)
  IF (ALLOCATED(THIS%YRVFE%RDERGW)) DEALLOCATE(THIS%YRVFE%RDERGW)

  
END SUBROUTINE DEALLOC_VERTICAL_GEOM 


!! helper routines
SUBROUTINE ALLOC_SIZEOF_1D(DEST,SOURCE)
  IMPLICIT NONE
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(OUT) ::  DEST(:)
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(IN)  ::  SOURCE(:)

  INTEGER(KIND=JPIM) :: DIM1_MIN, DIM1_MAX

  !! allocate array with proper bounds
  DIM1_MIN = LBOUND(SOURCE,1)
  DIM1_MAX = UBOUND(SOURCE,1)
  ALLOCATE( DEST(DIM1_MIN:DIM1_MAX) ) 

END SUBROUTINE ALLOC_SIZEOF_1D

SUBROUTINE ALLOC_SIZEOF_2D(DEST,SOURCE)
  IMPLICIT NONE
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(OUT) ::  DEST(:,:)
  REAL(KIND=JPRB), ALLOCATABLE, INTENT(IN)  ::  SOURCE(:,:)

  INTEGER(KIND=JPIM) :: DIM1_MIN, DIM1_MAX, DIM2_MIN, DIM2_MAX

  !! allocate array with proper bounds
  DIM1_MIN = LBOUND(SOURCE,1)
  DIM1_MAX = UBOUND(SOURCE,1)
  DIM2_MIN = LBOUND(SOURCE,2)
  DIM2_MAX = UBOUND(SOURCE,2)
  ALLOCATE( DEST(DIM1_MIN:DIM1_MAX, DIM2_MIN:DIM2_MAX) ) 

END SUBROUTINE ALLOC_SIZEOF_2D

SUBROUTINE D_ALLOC_SIZEOF_2D(DEST,SOURCE)
  IMPLICIT NONE
  REAL(KIND=JPRD), ALLOCATABLE, INTENT(OUT) ::  DEST(:,:)
  REAL(KIND=JPRD), ALLOCATABLE, INTENT(IN)  ::  SOURCE(:,:)

  INTEGER(KIND=JPIM) :: DIM1_MIN, DIM1_MAX, DIM2_MIN, DIM2_MAX

  !! allocate array with proper bounds
  DIM1_MIN = LBOUND(SOURCE,1)
  DIM1_MAX = UBOUND(SOURCE,1)
  DIM2_MIN = LBOUND(SOURCE,2)
  DIM2_MAX = UBOUND(SOURCE,2)
  ALLOCATE( DEST(DIM1_MIN:DIM1_MAX, DIM2_MIN:DIM2_MAX) ) 

END SUBROUTINE D_ALLOC_SIZEOF_2D

SUBROUTINE ALLOC_INIT_TVAB(KLEV,PVAH,PVBH,YDVAB)

  IMPLICIT NONE

  INTEGER(KIND=JPIM), INTENT(IN)    :: KLEV
  REAL(KIND=JPRB),    INTENT(IN)    :: PVAH(0:KLEV)
  REAL(KIND=JPRB),    INTENT(IN)    :: PVBH(0:KLEV)
  TYPE(TVAB),         INTENT(INOUT) :: YDVAB

  INTEGER(KIND=JPIM) :: JL
  REAL(KIND=JPRB) :: ZHOOK_HANDLE

  IF (LHOOK) CALL DR_HOOK('YOMVERT:ALLOC_INIT_TVAB',0,ZHOOK_HANDLE)

  ALLOCATE(YDVAB%VAH(0:KLEV))
  ALLOCATE(YDVAB%VBH(0:KLEV))
  ALLOCATE(YDVAB%VALH(0:KLEV))
  ALLOCATE(YDVAB%VC(KLEV))
  ALLOCATE(YDVAB%VDELA(KLEV))
  ALLOCATE(YDVAB%VDELB(KLEV))
  ALLOCATE(YDVAB%VAF(0:KLEV))
  ALLOCATE(YDVAB%VBF(0:KLEV))
  ALLOCATE(YDVAB%VRATH(0:KLEV))
  ALLOCATE(YDVAB%VRATF(KLEV))
  DO JL=0,KLEV
    YDVAB%VAH(JL)=PVAH(JL)
    YDVAB%VBH(JL)=PVBH(JL)
    YDVAB%VALH(JL)=YDVAB%VAH(JL)/VP00
  ENDDO
  DO JL=1,KLEV
    YDVAB%VC(JL)=YDVAB%VAH(JL)*YDVAB%VBH(JL-1)-YDVAB%VAH(JL-1)*YDVAB%VBH(JL)
    YDVAB%VAF(JL)=0.5_JPRB*(YDVAB%VAH(JL)+YDVAB%VAH(JL-1))
    YDVAB%VBF(JL)=0.5_JPRB*(YDVAB%VBH(JL)+YDVAB%VBH(JL-1))
    YDVAB%VDELA(JL)=YDVAB%VAH(JL)-YDVAB%VAH(JL-1)
    YDVAB%VDELB(JL)=YDVAB%VBH(JL)-YDVAB%VBH(JL-1)
  ENDDO
  YDVAB%VRATH(0)=0.0_JPRB 
  DO JL=1,KLEV
    YDVAB%VRATH(JL)=YDVAB%VBH(JL)*VP00/(YDVAB%VAH(JL)+YDVAB%VBH(JL)*VP00)
  ENDDO
  IF (KLEV>1) YDVAB%VRATH(1)=MIN(0.5_JPRB,YDVAB%VRATH(1))
  DO JL=1,KLEV
    YDVAB%VRATF(JL)=YDVAB%VBF(JL)*VP00/(YDVAB%VAF(JL)+YDVAB%VBF(JL)*VP00)
  ENDDO
  IF (KLEV>1) YDVAB%VRATF(1)=MIN(0.25_JPRB,YDVAB%VRATF(1))
  IF (KLEV>2) YDVAB%VRATF(2)=MIN(0.75_JPRB,YDVAB%VRATF(2))

  IF (LHOOK) CALL DR_HOOK('YOMVERT:ALLOC_INIT_TVAB',1,ZHOOK_HANDLE)

END SUBROUTINE ALLOC_INIT_TVAB

SUBROUTINE DEALLOC_TVAB(YDVAB)

  IMPLICIT NONE

  TYPE(TVAB),         INTENT(INOUT) :: YDVAB

  REAL(KIND=JPRB) :: ZHOOK_HANDLE

  IF (LHOOK) CALL DR_HOOK('YOMVERT:DEALLOC_TVAB',0,ZHOOK_HANDLE)

  DEALLOCATE(YDVAB%VAH)
  DEALLOCATE(YDVAB%VBH)
  DEALLOCATE(YDVAB%VALH)
  DEALLOCATE(YDVAB%VC)
  DEALLOCATE(YDVAB%VDELA)
  DEALLOCATE(YDVAB%VDELB)
  DEALLOCATE(YDVAB%VAF)
  DEALLOCATE(YDVAB%VBF)
  DEALLOCATE(YDVAB%VRATH)
  DEALLOCATE(YDVAB%VRATF)

  IF (LHOOK) CALL DR_HOOK('YOMVERT:DEALLOC_TVAB',1,ZHOOK_HANDLE)

END SUBROUTINE DEALLOC_TVAB

END MODULE YOMVERT
