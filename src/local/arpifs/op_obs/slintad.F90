SUBROUTINE SLINTAD(YDGEOMETRY,KPROMB,KTSLOT,YDSL,PLAT,PLON,YDGOM)

!**** *SLINTAD* - Horizontal interpolation of the model variables
!               from grid points to observation points by using
!               interpolation routines (adjoint)

!     Purpose.
!     -------
!           Feeding the tables GOMMV,GOSMV,GSMMV,GSSMV,GSCMV with the
!     variables at the observation points, from the model variables in
!     grid points. These tables are containing the quantity called Xmvo
!     in the scientific documentation.

!     Interface.
!     ---------
!        CALL SLINTAD(..)
!     where: 
!            KPROMB    : Length of work.                          (in)
!            KTSLOT    : Observation timeslot                     (in)
!            YDSL      : SL_STRUCT definition                     (inout)
!            PLAT      : Latitude of interpolation point.         (in)
!            PLON      : Longitude of interpolation point.        (in)
!            YDGOM     : GOM buffer.

!     Externals. See includes below.
!     ---------

!     Author: Drasko Vasiljevic
!     Date  : 92-05-19

!     Modifications
!     -------------
!     09-Jan-2007 F. Vana  : arguments update for ELASCAW
!     28-Aug-2007 F. Vana  : update of arguments of (E)LASCAW
!     07-Nov-2007 J. Masek : update of arguments of (E)LASCAW
!     20-Aug-2008 F. Vana  : Weights driven interpolation.
!     K. Yessad (Aug 2009): use RIPI, RSLD
!     K. Yessad (Jan 2010): revised code (first draft)
!     03-Nov-2009 H.Hersbach : Introduce KFIELDS; number of vertical+surf fields
!     F. Vana  22-Feb-2011: update of arguments for (E)LASCAW
!     G.Mozdzynski (Jan 2011): OOPS cleaning, use of derived type SL_STRUCT
!     G.Mozdzynski (Feb 2011): OOPS cleaning, use of derived type TCSGLEG
!     J.Hague      21-Mar-11 : YDGOM Derived type added
!     J.Hague      12-Aug-2011 YOBB1 part of YDGOM
!     A.Geer       09-Jan-2012 : Added nearest-neighbour; configurable by obstype
!     J Hague      02-May-2012 Updated for new_gom
!     G. Mozdzynski (May 2012): further cleaning
!     S. Malardel (Nov 2013): COMAD weights for SL interpolations
!     F. Vana  13-Feb-2014 Updated arguments for LASCAW
!     G. Mozdzynski (Feb 2015): improve halo debugging
!     B. Bochenek (Apr 2015): Phasing: update
!     N. Bormann (Feb 2016): Make latitude/longitude available
!     K. Yessad (March 2017): simplify level numbering in interpolator.
!     F. Vana    21-Nov-2017: Option LHOISLT
!     H Petithomme (Dec 2020): add WENO in LAM
!    -------------------------------------------------------------------

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE PARKIND1 , ONLY : JPIM, JPRB
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK
USE YOMCT0   , ONLY : LRPLANE
USE YOMMP0   , ONLY : LSLDEBUG
USE YOMCST   , ONLY : RPI
USE GOM_MOD  , ONLY : TYPE_GOM,  GINTERP, GOM_GET_INTERPOLATION_BUFFERS,&
  & TYPE_PRE_INTERP_ACCESS, GOM_PRE_INTERP_ACCESS
USE EINT_MOD , ONLY : SL_STRUCT, SLHALO_DEBUG

!    -------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)    ,INTENT(IN)    :: YDGEOMETRY
INTEGER(KIND=JPIM),INTENT(IN)    :: KPROMB
INTEGER(KIND=JPIM),INTENT(IN)    :: KTSLOT
TYPE(SL_STRUCT)   ,INTENT(INOUT) :: YDSL
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLAT(KPROMB,1) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PLON(KPROMB,1) 
TYPE(TYPE_GOM)    ,INTENT(IN)    :: YDGOM

!    -------------------------------------------------------------------

REAL(KIND=JPRB) ::    ZLSDEPI(YDSL%NDGSAH:YDSL%NDGENH)
REAL(KIND=JPRB) ::    ZLEV(KPROMB,1)
REAL(KIND=JPRB) ::    ZDSLAT(KPROMB,    1)
REAL(KIND=JPRB) ::    ZCSLA (KPROMB,    1,2:4)
REAL(KIND=JPRB) ::    ZDSLON(KPROMB,    1,0:3)
REAL(KIND=JPRB) ::    ZCSLO (KPROMB,    1,3,2)
INTEGER(KIND=JPIM) :: IL0S  (KPROMB,    1,0:3)
INTEGER(KIND=JPIM) :: ISTALAT(YDSL%NDGSAH:YDSL%NDGENH)
INTEGER(KIND=JPIM) :: IL0ULI(KPROMB,2,2)   ,IL0UDI(KPROMB,0:3,0:3)
INTEGER(KIND=JPIM) :: ITRANS(0:YDSL%NASLB1)
INTEGER(KIND=JPIM) :: IDEP(KPROMB,YDGEOMETRY%YRDIMV%NFLEVG)

INTEGER(KIND=JPIM) :: ISPLTHOI, IDIMK
INTEGER(KIND=JPIM) :: IEND, IFLDN, &
 & IGLGLO, IHOR, IHVI, ILFB, ILSB, IST, IWIS,&
 & J, J1, JGL, JL, JLAT, INT  

LOGICAL :: LLSLHD,LLSLHDQUAD,LLSLHD_OLD,LL3DTURB,LLSLHDHEAT
LOGICAL         :: LLCOMAD, LLCOMADH, LLCOMADV

REAL(KIND=JPRB) :: ZDEPI, ZPIS2

LOGICAL :: LLINTERP
REAL(KIND=JPRB),POINTER :: ZPRE(:,:), ZPOST(:)
INTEGER(KIND=JPIM) :: ID, JOBS, ILEN, INT_DEFAULT

TYPE(TYPE_PRE_INTERP_ACCESS) :: YLPRE

REAL(KIND=JPRB) :: ZHOOK_HANDLE

! unused arguments in call to LASCAW/ELASCAW
! a) input - array dimensions contracted
INTEGER(KIND=JPIM) :: IUN_VAUTF(1)
REAL(KIND=JPRB) :: ZUN_SLD(1,3)
REAL(KIND=JPRB) :: ZUN_SLDW(1)
REAL(KIND=JPRB) :: ZUN_3DTW(1)
REAL(KIND=JPRB) :: ZUN_VETAF(1)
REAL(KIND=JPRB) :: ZUN_VCUICO(1)
REAL(KIND=JPRB) :: ZUN_VSLD(1)
REAL(KIND=JPRB) :: ZUN_VSLDW(1)
REAL(KIND=JPRB) :: ZUN_KAPPA(1),ZUN_KAPPAT(1),ZUN_KAPPAM(1),ZUN_KAPPAH(1)
REAL(KIND=JPRB) :: ZUN_MADU(1),ZUN_MADV(1),ZUN_MADW(1)
REAL(KIND=JPRB) :: ZUN_GAMMA_WENO(1)
! b) output - array dimensions kept for safety
INTEGER(KIND=JPIM) :: IUN_LEV(KPROMB,1)
INTEGER(KIND=JPIM) :: IUN_LH0(KPROMB,1,0:3)
INTEGER(KIND=JPIM) :: IUN_NOWENO(KPROMB,1)
REAL(KIND=JPRB) :: ZUN_DLAMAD(KPROMB)
REAL(KIND=JPRB) :: ZUN_CLASLD(KPROMB,1,3)
REAL(KIND=JPRB) :: ZUN_CLAMAD(KPROMB,1,3)
REAL(KIND=JPRB) :: ZUN_DLOMAD (KPROMB,1,0:3)
REAL(KIND=JPRB) :: ZUN_CLOSLD(KPROMB,1,3,2)
REAL(KIND=JPRB) :: ZUN_CLOMAD(KPROMB,1,3,2)
REAL(KIND=JPRB) :: ZUN_CLASLT(KPROMB,1,3)
REAL(KIND=JPRB) :: ZUN_CLOSLT(KPROMB,1,3,2)
REAL(KIND=JPRB) :: ZUN_DVER(KPROMB,1)
REAL(KIND=JPRB) :: ZUN_DVERMAD(KPROMB,1)
REAL(KIND=JPRB) :: ZUN_VINTW(KPROMB,1,3)
REAL(KIND=JPRB) :: ZUN_VINTWSLD(KPROMB,1,3)
REAL(KIND=JPRB) :: ZUN_VINTWMAD(KPROMB,1,3)
REAL(KIND=JPRB) :: ZUN_VINTWSLT(KPROMB,1,3)
REAL(KIND=JPRB) :: ZUN_VINTWS(KPROMB,1,1:4)
REAL(KIND=JPRB) :: ZUN_VDERW(KPROMB,1,0,0)  ! case KHVI=0
REAL(KIND=JPRB) :: ZUN_HVW(KPROMB,1,0)      ! case KHVI=0
REAL(KIND=JPRB) :: ZUN_CW(KPROMB,1,3)

!    -------------------------------------------------------------------

#include "abor1.intfb.h"
#include "elascaw.intfb.h"
#include "laiddiobsad.intfb.h"
#include "laidliobsad.intfb.h"
#include "laidlicad.intfb.h"
#include "lascaw.intfb.h"

!    -------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('SLINTAD',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, YDHSLMER=>YDGEOMETRY%YRHSLMER, YDCSGLEG=>YDGEOMETRY%YRCSGLEG, &
& YDVSPLIP=>YDGEOMETRY%YRVSPLIP)
ASSOCIATE(R4JP=>YDGEM%R4JP)
!    -------------------------------------------------------------------
!*       1. PRESET INTERPOLATION AT OBS. POINTS
!           -----------------------------------

CALL GSTATS(1869,0)
IWIS = YDGOM%NOBSHOR
IF ( IWIS /= 201.AND. IWIS /= 203 ) THEN
  CALL ABOR1('SLINTAD: UNKNOWN INTERPOL. NO:')
ENDIF
IFLDN = 1
CALL GOM_PRE_INTERP_ACCESS(YDGOM,YLPRE)
IHOR = 0
IHVI = 0
ZDEPI=2.0_JPRB*RPI
ZPIS2=0.5_JPRB*RPI

DO JGL = MAX(YDSL%NDGSAG,YDSL%NDGSAL+YDSL%NFRSTLOFF-YDSL%NSLWIDE)-YDSL%NFRSTLOFF,&
   & MIN(YDSL%NDGENG,YDSL%NDGENL+YDSL%NFRSTLOFF+YDSL%NSLWIDE)-YDSL%NFRSTLOFF  
  IGLGLO=JGL+YDSL%NFRSTLOFF
  ZLSDEPI(JGL)=REAL(YDSL%NLOENG(IGLGLO),JPRB)/ZDEPI
ENDDO

DO JLAT=MAX(YDSL%NDGSAH,LBOUND(YDSL%NSLOFF,1)),MIN(YDSL%NDGENH,UBOUND(YDSL%NSLOFF,1))
  ISTALAT(JLAT)=YDSL%NSLOFF(JLAT)
ENDDO

ZLEV(:,:) = 0.0_JPRB

!    -------------------------------------------------------------------
!*       2. SET INTERPOLATION/BUFFER PARAMETERS
!           -----------------------------------

! deactivate computation of SLHD/COMAD weights
LLSLHD     =.FALSE.
LLSLHDQUAD =.FALSE.
LLSLHD_OLD =.FALSE.
LLCOMAD=.FALSE.
LLCOMADH=.FALSE.
LLCOMADV=.FALSE.

ISPLTHOI=0
LL3DTURB=.FALSE.
IDIMK=1

LLSLHDHEAT = .FALSE.
IF (LRPLANE) THEN
  CALL ELASCAW(YDVSPLIP,LLSLHDHEAT,YDSL,KPROMB,IDIMK,1,KPROMB,1,&
   & IFLDN,ISTALAT,IWIS,IHOR,1,IHVI,&
   & LLSLHD,LLSLHDQUAD,LLSLHD_OLD,LL3DTURB,&
   & LLCOMAD,LLCOMADH,LLCOMADV,ISPLTHOI,&
   & PLON,PLAT,ZLEV,&
   & ZUN_VETAF,IUN_VAUTF,&
   & ZUN_VCUICO,ZUN_VSLD,ZUN_VSLDW,ZUN_GAMMA_WENO,1,1.0_JPRB,&
   & ZUN_KAPPA,ZUN_KAPPAT,ZUN_KAPPAM,ZUN_KAPPAH,&
   & ZUN_MADU,ZUN_MADV,ZUN_MADW,&
   & ZDSLAT,ZUN_DLAMAD,ZCSLA,ZUN_CLASLD,ZUN_CLASLT,ZUN_CLAMAD,&
   & ZDSLON,ZUN_DLOMAD,ZCSLO,ZUN_CLOSLD,ZUN_CLOSLT,ZUN_CLOMAD,&
   & IL0S,IUN_LH0,IUN_LEV,IUN_NOWENO,ZUN_CW,&
   & ZUN_DVER,ZUN_DVERMAD,ZUN_VINTW,ZUN_VINTWSLD,ZUN_VINTWSLT,ZUN_VINTWMAD,ZUN_VINTWS,&
   & ZUN_VDERW,ZUN_HVW,IDEP)  
ELSE
  CALL LASCAW(YDVSPLIP,YDSL,KPROMB,IDIMK,1,KPROMB,1,&
   & IFLDN,ISTALAT,IWIS,IHOR,1,IHVI,&
   & LLSLHD,LLSLHDQUAD,LLSLHD_OLD,LLSLHDHEAT,LL3DTURB,&
   & LLCOMAD,LLCOMADH,LLCOMADV,ISPLTHOI,&
   & R4JP,ZPIS2,ZLSDEPI,YDCSGLEG%RLATI(YDSL%NDGSAH:),&
   & YDHSLMER%RIPI(YDSL%NDGSAH:YDSL%NDGENH,1),&
   & YDHSLMER%RIPI(YDSL%NDGSAH:YDSL%NDGENH,2),&
   & YDHSLMER%RIPI(YDSL%NDGSAH:YDSL%NDGENH,3),&
   & ZUN_SLD(1,1),ZUN_SLD(1,2),ZUN_SLD(1,3),&
   & ZUN_SLDW,ZUN_3DTW,&
   & PLON,PLAT,ZLEV,&
   & ZUN_VETAF,IUN_VAUTF,&
   & ZUN_VCUICO,ZUN_VSLD,ZUN_VSLDW,ZUN_GAMMA_WENO,1,1.0_JPRB,&
   & ZUN_KAPPA,ZUN_KAPPAT,ZUN_KAPPAM,ZUN_KAPPAH,&
   & ZUN_MADU,ZUN_MADV,ZUN_MADW,&
   & ZDSLAT,ZUN_DLAMAD,ZCSLA,ZUN_CLASLD,ZUN_CLASLT,ZUN_CLAMAD,&
   & ZDSLON,ZUN_DLOMAD,ZCSLO,ZUN_CLOSLD,ZUN_CLOSLT,ZUN_CLOMAD,&
   & IL0S,IUN_LH0,IUN_LEV,IUN_NOWENO,ZUN_CW,&
   & ZUN_DVER,ZUN_DVERMAD,ZUN_VINTW,ZUN_VINTWSLD,ZUN_VINTWSLT,ZUN_VINTWMAD,ZUN_VINTWS,&
   & ZUN_VDERW,ZUN_HVW)
ENDIF

DO J=0,YDSL%NASLB1
  ITRANS(J)=J
ENDDO

ILSB=MAX(YDSL%NDGSAG,YDSL%MYFRSTACTLAT-YDSL%NSLWIDE)-YDSL%NFRSTLOFF
ILFB=MIN(YDSL%NDGENG,YDSL%MYLSTACTLAT +YDSL%NSLWIDE)-YDSL%NFRSTLOFF
DO JL=ILSB,ILFB
  IF (YDSL%NLOENG(JL+YDSL%NFRSTLOFF) == YDSL%NSLONL(JL)) THEN
    IST =YDSL%NSLOFF(JL)-1
    IEND=YDSL%NSLOFF(JL)+YDSL%NLOENG(JL+YDSL%NFRSTLOFF)
    ITRANS(IST+1)=IEND
    ITRANS(IEND+1)=IST+2
    ITRANS(IEND+2)=IST+3
  ENDIF
ENDDO

IF( IWIS == 201) THEN
  INT_DEFAULT = GINTERP%BILINEAR_4POINT
  DO J1 = 1 , KPROMB
    IL0ULI(J1,1,1) = ITRANS(IL0S(J1,1,1)+1)
    IL0ULI(J1,1,2) = ITRANS(IL0S(J1,1,1)+2)
    IL0ULI(J1,2,1) = ITRANS(IL0S(J1,1,2)+1)
    IL0ULI(J1,2,2) = ITRANS(IL0S(J1,1,2)+2)
  ENDDO
  IF( LSLDEBUG .AND. YDSL%CVER=='OA' )THEN
    DO J1 = 1 , KPROMB
      YDSL%MASK_SL1(IL0ULI(J1,1,1))=1
      CALL SLHALO_DEBUG(YDSL,IL0ULI(J1,1,1))
      YDSL%MASK_SL1(IL0ULI(J1,1,2))=1
      CALL SLHALO_DEBUG(YDSL,IL0ULI(J1,1,2))
      YDSL%MASK_SL1(IL0ULI(J1,2,1))=1
      CALL SLHALO_DEBUG(YDSL,IL0ULI(J1,2,1))
      YDSL%MASK_SL1(IL0ULI(J1,2,2))=1
      CALL SLHALO_DEBUG(YDSL,IL0ULI(J1,2,2))
    ENDDO
  ENDIF
ELSEIF( IWIS == 203) THEN
  INT_DEFAULT = GINTERP%BIDIMENSIONAL_12POINT
  DO J1 = 1 , KPROMB
    IL0ULI(J1,1,1) = ITRANS(IL0S(J1,1,1)+1)
    IL0ULI(J1,1,2) = ITRANS(IL0S(J1,1,1)+2)
    IL0ULI(J1,2,1) = ITRANS(IL0S(J1,1,2)+1)
    IL0ULI(J1,2,2) = ITRANS(IL0S(J1,1,2)+2)
  ENDDO
  DO J1 = 1 , KPROMB
    IL0UDI(J1,0,0) = 0
    IL0UDI(J1,0,1) = ITRANS(IL0S(J1,1,0)+1)
    IL0UDI(J1,0,2) = ITRANS(IL0S(J1,1,0)+2)
    IL0UDI(J1,0,3) = 0
    IL0UDI(J1,1,0) = ITRANS(IL0S(J1,1,1)+0)
    IL0UDI(J1,1,1) = ITRANS(IL0S(J1,1,1)+1)
    IL0UDI(J1,1,2) = ITRANS(IL0S(J1,1,1)+2)
    IL0UDI(J1,1,3) = ITRANS(IL0S(J1,1,1)+3)
    IL0UDI(J1,2,0) = ITRANS(IL0S(J1,1,2)+0)
    IL0UDI(J1,2,1) = ITRANS(IL0S(J1,1,2)+1)
    IL0UDI(J1,2,2) = ITRANS(IL0S(J1,1,2)+2)
    IL0UDI(J1,2,3) = ITRANS(IL0S(J1,1,2)+3)
    IL0UDI(J1,3,0) = 0
    IL0UDI(J1,3,1) = ITRANS(IL0S(J1,1,3)+1)
    IL0UDI(J1,3,2) = ITRANS(IL0S(J1,1,3)+2)
    IL0UDI(J1,3,3) = 0
  ENDDO
  IF( LSLDEBUG .AND. YDSL%CVER=='OA' )THEN
    DO J1 = 1 , KPROMB
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,0,1))
      YDSL%MASK_SL1(IL0UDI(J1,0,2))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,0,2))
      YDSL%MASK_SL1(IL0UDI(J1,1,0))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,1,0))
      YDSL%MASK_SL1(IL0UDI(J1,1,1))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,1,1))
      YDSL%MASK_SL1(IL0UDI(J1,1,2))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,1,2))
      YDSL%MASK_SL1(IL0UDI(J1,1,3))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,1,3))
      YDSL%MASK_SL1(IL0UDI(J1,2,0))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,2,0))
      YDSL%MASK_SL1(IL0UDI(J1,2,1))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,2,1))
      YDSL%MASK_SL1(IL0UDI(J1,2,2))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,2,2))
      YDSL%MASK_SL1(IL0UDI(J1,2,3))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,2,3))
      YDSL%MASK_SL1(IL0UDI(J1,3,1))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,3,1))
      YDSL%MASK_SL1(IL0UDI(J1,3,2))=1
      CALL SLHALO_DEBUG(YDSL,IL0UDI(J1,3,2))
    ENDDO
  ENDIF
ENDIF
CALL GSTATS(1869,1)

DO JOBS = 1 , KPROMB
  ID=1
  LLINTERP=.TRUE.
  DO WHILE (LLINTERP)

    ! Find contiguous runs of fields for interpolation (important for
    ! performance here) and get access to the pre and post-interpolation buffers
    CALL GOM_GET_INTERPOLATION_BUFFERS(JOBS, YDGOM, ID, LLINTERP, ILEN, INT, ZPRE, ZPOST, LDAD=.TRUE.)
    IF (LLINTERP) THEN

      IF (INT==GINTERP%DEFAULT) INT=INT_DEFAULT

      ! Complete the interpolation
      SELECT CASE(INT)

      CASE (GINTERP%BILINEAR_4POINT)
        CALL LAIDLIOBSAD(YDSL%NASLB1, ILEN, ZDSLAT(JOBS,1), ZDSLON(JOBS,1,1:2), IL0ULI(JOBS,:,:),&
          & ZPRE, ZPOST)


      CASE (GINTERP%BIDIMENSIONAL_12POINT)
        CALL LAIDDIOBSAD(YDSL%NASLB1, ILEN,&
          & ZCSLA(JOBS,1,:), ZDSLON(JOBS,1,:), ZCSLO(JOBS,1,:,:), IL0UDI(JOBS,:,:),&
          & ZPRE, ZPOST)

      CASE (GINTERP%NEAREST_NEIGHBOUR)
        CALL LAIDLICAD(YDSL%NASLB1, ILEN, ZDSLAT(JOBS,1), ZDSLON(JOBS,1,1:2), IL0ULI(JOBS,:,:),&
          & ZPRE, ZPOST)

      CASE (GINTERP%SET_ONE)
        ZPOST=0.0_JPRB
      CASE (GINTERP%SET_ZERO)
        ZPOST=0.0_JPRB
      CASE (GINTERP%SET_LAT)
        ZPOST=0.0_JPRB
      CASE (GINTERP%SET_LON)
        ZPOST=0.0_JPRB
      CASE DEFAULT
        CALL ABOR1('SLINTAD: INTERPOLATION METHOD NOT SUPPORTED IN ADJOINT')
      END SELECT

    ENDIF
  ENDDO
ENDDO

!   ------------------------------------------------------------------
END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('SLINTAD',1,ZHOOK_HANDLE)
END SUBROUTINE SLINTAD
