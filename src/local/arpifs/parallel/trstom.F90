SUBROUTINE TRSTOM(YDGEOMETRY,PSPVORG,PSPDIVG,PSPTG,PSPSPDG,PSPSVDG,PSPSNHXG, &
 & PSPGFLG,PSPSPG,PSPAUXG,PSPSEL3DG,PSPSEL2DG,&
 & PSPVOR,PSPDIV,PSPT,PSPSPD,PSPSVD,PSPSNHX,&
 & PSPGFL,PSPSP,PSPAUX,PSPSEL3D,PSPSEL2D,&
 & LDSELECT3D,LDSELECT2D,LDFULLM,LDNEEDPS)  

!**** *trstom * - Transposition from vertical to horizontal spectral
!                 coefficients

!     Purpose.
!     --------
!              Transpose data from SPXXG arrays to SPxx arrays.
!              The semi-implicit calculations require vertical
!              columns of PSPT, PSPDIV, and restructured PSPSP.
!              This routine is called during the spectral computations.
!              This routine is the inverse of TRMTOS.

!**   Interface.
!     ----------
!        *call* *trstom(...)

!        Explicit arguments :
!        --------------------
!         PSPVORG     - vorticity columns
!         PSPDIVG     - divergence columns
!         PSPTG       - temperature columns
!         PSPSPDG     - NH pressure departure variable columns
!         PSPSVDG     - NH vertical divergence variable columns
!         PSPSNHXG    - NH "X" part divergence variable columns
!         PSPGFLG     - GFL columns
!         PSPSPG      - surface pressure
!         PSPAUX      - auxiliary field columns
!         PSPSEL3DG   - 3d fields
!         PSPSEL2DG   - 2d fields
!         PSPVOR      - distributed vorticity
!         PSPDIV      - distributed divergence
!         PSPT        - distributed temperature
!         PSPSPD      - distributed NH pressure departure variable
!         PSPSVD      - distributed NH vertical divergence variable
!         PSPSNHX     - distributed NH "X" part divergence variable
!         PSPGFL      - distributed humidity
!         PSPSP       - distributed surface pressure
!         PSPAUX      - distributed auxiliary field
!         PSPSEL3D    - 3d fields (only those indicated
!                       by LSELECT3D are updated)
!         PSPSEL2D    - 2d fields (only those indicated
!                       by LSELECT2D are updated)
!         LDSELECT3D  - .T.=> select this 3d field
!         LDSELECT2D  - .T.=> select this 2d field
!         LDFULLM     - .T. if full m-columns are used
!         LDNEEDPS    - .T. if all PE's recv Ps

!        Implicit arguments :
!        --------------------

!     Method.
!     -------
!        See documentation

!     Externals.
!     ----------

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!      MPP Group *ECMWF*
!      Original       : 95-10-01 

!     Modifications.
!     --------------
!      D.Salmond      : 01-11-23 LIMP_NOOLAP Option for non-overlapping
!                                message passing and buffer packing
!      M.Hamrud       : 03-10-01 CY28 Cleaning
!      M.Hamrud       : 03-12-01 CY28R1 Cleaning
!      K. Yessad      : 05-02-08 NH variables + cleaning
!      L. Isaksen     : 04-09-01 Optional arguments, more flexible
!      M. Fisher      : 05-08-22 Even more flexible (selected 2d,3d fields)
!      G. Mozdzynski  : 08-01-01 Cleanup
!      F. Vana + NEC  : 08-09-09 optimization
!      T. Wilhelmsson : 09-09-22 Add auxiliary field
!      T. Wilhelmsson and K. Yessad (Oct 2013) Geometry and setup refactoring.
!      R. El Khatib 02-Jul-2015 Optimization (partial)
!      R. El Khatib 10-Dec-2020 Optimization by overlaping packs/unpacks with comms
!     ------------------------------------------------------------------

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE PARKIND1     , ONLY : JPIM, JPRB
USE YOMHOOK      , ONLY : LHOOK, DR_HOOK
USE YOMCT0       , ONLY : LNHDYN
USE YOMDYNA      , ONLY : LNHX
USE YOMMP0       , ONLY : NPRTRN, NPRTRV, NPRCIDS, MYSETV, MYSETN, MYSETW, MYSETM
USE YOMTAG       , ONLY : MTAGSM
USE MPL_MODULE   , ONLY : MPL_SEND, MPL_RECV, MPL_WAIT, MPL_WAITANY, JP_NON_BLOCKING_STANDARD, JP_BLOCKING_STANDARD

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY),INTENT(IN)    :: YDGEOMETRY
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPVORG(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPDIVG(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPTG(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPSPDG(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPSVDG(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPSNHXG(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPGFLG(:,:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPSPG(:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPAUXG(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPSEL3DG(:,:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(IN)    :: PSPSEL2DG(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(OUT)   :: PSPVOR(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(OUT)   :: PSPDIV(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(OUT)   :: PSPT(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(OUT)   :: PSPSPD(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(OUT)   :: PSPSVD(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(OUT)   :: PSPSNHX(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(INOUT) :: PSPGFL(:,:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(OUT)   :: PSPSP(:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(OUT)   :: PSPAUX(:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(INOUT) :: PSPSEL3D(:,:,:) 
REAL(KIND=JPRB)   ,OPTIONAL, INTENT(INOUT) :: PSPSEL2D(:,:) 
LOGICAL           ,OPTIONAL, INTENT(IN)    :: LDSELECT3D(:)
LOGICAL           ,OPTIONAL, INTENT(IN)    :: LDSELECT2D(:)
LOGICAL           ,OPTIONAL, INTENT(IN)    :: LDFULLM 
LOGICAL           ,OPTIONAL, INTENT(IN)    :: LDNEEDPS 

!     ------------------------------------------------------------------

INTEGER(KIND=JPIM), EXTERNAL :: MYSENDSET,MYRECVSET
INTEGER(KIND=JPIM) :: IPTRSV(NPRTRN+1)
INTEGER(KIND=JPIM) :: ISENT    (NPRTRV-1)
INTEGER(KIND=JPIM) :: IRCVD    (NPRTRV-1)
INTEGER(KIND=JPIM) :: ISENDTOT (NPRTRV-1)
INTEGER(KIND=JPIM) :: IRECVTOT (NPRTRV-1)
INTEGER(KIND=JPIM) :: ISENDREQ (2*NPRTRV-1)
INTEGER(KIND=JPIM) :: IRECVREQ (2*NPRTRV-1)
INTEGER(KIND=JPIM) :: ISEND_START (NPRTRV-1)
INTEGER(KIND=JPIM) :: ISEND_LEVELS(NPRTRV-1)
INTEGER(KIND=JPIM) :: IBUFLEFT (NPRTRV-1)
INTEGER(KIND=JPIM) :: IMINIMUM (NPRTRV-1)
INTEGER(KIND=JPIM) :: INUMSPGFL,INUMSEL3D,INUMSEL2D


INTEGER(KIND=JPIM) :: INSFREC, IPOS, IRECV,&
 & IRECVSET, ISEND, ISENDSET, ISP, ISPEC2V, ILEVMIN,&
 & IL1, IL2, ILN, JL, JR, JROCB, JVERSP, ILEV, IISP,&
 & IBUFLENR, IBUFLENS, ISEL, JFIELD
INTEGER(KIND=JPIM) :: JPOS(NPRTRV-1)

LOGICAL :: LLRECV, LLVOR, LLDIV, LLT, LLSPD, LLSVD, LLGFL,&
         & LLSP, LLAUX, LLFULLM, LLNEEDPS, LLSEL3D, LLSEL2D, LLSNHX
INTEGER(KIND=JPIM) :: ISENDCOUNT,IRECVCOUNT,J,INSEND,INRECV
INTEGER(KIND=JPIM) :: JSEND(NPRTRV-1),JRECV(NPRTRV-1)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

!     ------------------------------------------------------------------

#include "abor1.intfb.h"
#include "set2pe.intfb.h"

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('TRSTOM',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP)
ASSOCIATE(NFLEVG=>YDDIMV%NFLEVG, NFLEVL=>YDDIMV%NFLEVL, &
 & NPTRLL=>YDMP%NPTRLL, &
 & NPSP=>YDMP%NPSP, NPSURF=>YDMP%NPSURF, &
 & NPTRSV=>YDMP%NPTRSV, NPTRSVF=>YDMP%NPTRSVF, NSPEC2V=>YDMP%NSPEC2V, &
 & NSPEC2VF=>YDMP%NSPEC2VF, NUMLL=>YDMP%NUMLL)

!     ------------------------------------------------------------------


IF(PRESENT(PSPVOR)) THEN
  IF(PRESENT(PSPVORG)) THEN
    LLVOR=.TRUE.
  ELSE
    CALL ABOR1('TRSTOM: PSPVOR PRESENT BUT PSPVORG MISSING')
  ENDIF
ELSE
  LLVOR=.FALSE.
ENDIF

IF(PRESENT(PSPDIV)) THEN
  IF(PRESENT(PSPDIVG)) THEN
    LLDIV=.TRUE.
  ELSE
    CALL ABOR1('TRSTOM: PSPDIV PRESENT BUT PSPDIVG MISSING')
  ENDIF
ELSE
  LLDIV=.FALSE.
ENDIF

IF(PRESENT(PSPT)) THEN
  IF(PRESENT(PSPTG)) THEN
    LLT=.TRUE.
  ELSE
    CALL ABOR1('TRSTOM: PSPT PRESENT BUT PSPTG MISSING')
  ENDIF
ELSE
  LLT=.FALSE.
ENDIF


IF(LNHDYN) THEN
  IF(PRESENT(PSPSPD)) THEN
    IF(PRESENT(PSPSPDG)) THEN
      LLSPD=.TRUE.
    ELSE
      CALL ABOR1('TRSTOM: PSPSPD PRESENT BUT PSPSPDG MISSING')
    ENDIF
  ELSE
    LLSPD=.FALSE.
  ENDIF
  IF(PRESENT(PSPSVD)) THEN
    IF(PRESENT(PSPSVDG)) THEN
      LLSVD=.TRUE.
    ELSE
      CALL ABOR1('TRSTOM: PSPSVD PRESENT BUT PSPSVDG MISSING')
    ENDIF
  ELSE
    LLSVD=.FALSE.
  ENDIF
ELSE
  LLSPD=.FALSE.
  LLSVD=.FALSE.
ENDIF

IF(LNHX) THEN
  IF(PRESENT(PSPSNHX)) THEN
    IF(PRESENT(PSPSNHXG)) THEN
      LLSNHX=.TRUE.
    ELSE
      CALL ABOR1('TRSTOM: PSPSNHX PRESENT BUT PSPSNHXG MISSING')
    ENDIF
  ELSE
    LLSNHX=.FALSE.
  ENDIF
ELSE
  LLSNHX=.FALSE.
ENDIF

IF(PRESENT(PSPGFL)) THEN
  INUMSPGFL=UBOUND(PSPGFL,3)
  IF (INUMSPGFL>0) THEN
    LLGFL=.TRUE.
    IF(PRESENT(PSPGFLG)) THEN
      IF (UBOUND(PSPGFLG,3) /= INUMSPGFL ) &
       & CALL ABOR1('TRSTOM: PSPGFLG AND PSPGFL NOT SAME NUMBER OF SP FIELDS')
    ELSE
      CALL ABOR1('TRSTOM: PSPGFL PRESENT BUT PSPGFLG MISSING')
    ENDIF
  ELSE
    LLGFL=.FALSE.
  ENDIF
ELSE
  LLGFL=.FALSE.
  INUMSPGFL=HUGE(INUMSPGFL)
ENDIF

IF(PRESENT(PSPSP)) THEN
  IF(PRESENT(PSPSPG)) THEN
    LLSP=.TRUE.
  ELSE
    CALL ABOR1('TRSTOM: PSPSP PRESENT BUT PSPSPG MISSING')
  ENDIF
ELSE
  LLSP=.FALSE.
ENDIF

IF(PRESENT(PSPAUX)) THEN
  IF(PRESENT(PSPAUXG)) THEN
    LLAUX=.TRUE.
  ELSE
    CALL ABOR1('TRSTOM: PSPAUX PRESENT BUT PSPAUXG MISSING')
  ENDIF
ELSE
  LLAUX=.FALSE.
ENDIF

IF (PRESENT(PSPSEL3D)) THEN
  LLSEL3D=.TRUE.
  IF (PRESENT(LDSELECT3D)) THEN
    IF (UBOUND(LDSELECT3D,1)/=UBOUND(PSPSEL3D,3)) THEN
      CALL ABOR1 ('PSPSEL3D AND LDSELECT3D HAVE DIFFERENT UPPER BOUNDS')
    ENDIF
  ELSE
    CALL ABOR1('TRSTOM: PSPSEL3D PRESENT BUT LDSELECT3D MISSING')  
  ENDIF

  INUMSEL3D=COUNT(LDSELECT3D)
  IF (PRESENT(PSPSEL3DG)) THEN
    IF (UBOUND(PSPSEL3DG,3)/=INUMSEL3D) THEN
      CALL ABOR1 ('PSPSEL3DG /= COUNT(LDSELECT3D)')
    ENDIF
  ELSE
    CALL ABOR1('TRSTOM: PSPSEL3D PRESENT BUT PSPSEL3DG MISSING')  
  ENDIF
ELSE
  INUMSEL3D=0
  LLSEL3D=.FALSE.
ENDIF

IF (PRESENT(PSPSEL2D)) THEN
  LLSEL2D=.TRUE.
  IF (PRESENT(LDSELECT2D)) THEN
    IF (UBOUND(LDSELECT2D,1)/=UBOUND(PSPSEL2D,2)) THEN
      CALL ABOR1 ('PSPSEL2D AND LDSELECT2D HAVE DIFFERENT UPPER BOUNDS')
    ENDIF
  ELSE
    CALL ABOR1('TRSTOM: PSPSEL2D PRESENT BUT LDSELECT2D MISSING')  
  ENDIF

  INUMSEL2D=COUNT(LDSELECT2D)
  IF (PRESENT(PSPSEL2DG)) THEN
    IF (UBOUND(PSPSEL2DG,2)/=INUMSEL2D) THEN
      CALL ABOR1 ('PSPSEL2DG /= COUNT(LDSELECT2D)')
    ENDIF
  ELSE
    CALL ABOR1('TRSTOM: PSPSEL2D PRESENT BUT PSPSEL2DG MISSING')  
  ENDIF
ELSE
  INUMSEL2D=0
  LLSEL2D=.FALSE.
ENDIF

IF (LLSP) THEN
  IISP=1
ELSE
  IISP=0
ENDIF
IF (IISP+INUMSEL2D>1) THEN
  CALL ABOR1 ('TRSTOM: NOT YET CODED FOR >1 2D FIELD')
ENDIF

IF(PRESENT(LDFULLM)) THEN
  LLFULLM=LDFULLM
ELSE
  LLFULLM=.FALSE.
ENDIF

IF(PRESENT(LDNEEDPS)) THEN
  LLNEEDPS=LDNEEDPS
! CHECK that PSPSP is properly ALLOCATED on ALL processors for LDNEEDPS
  IF(SIZE(PSPSP) /= SIZE(PSPDIV,DIM=2))THEN
    CALL ABOR1 ('TRSTOM: MUST HAVE PSPSP ALLOCATED for LDNEEDPS')
  ENDIF
ELSE
  LLNEEDPS=.FALSE.
ENDIF

IF (NPRTRN == 1) THEN

  ! * If all PE's have all levels only a plain copy is necessary

!$OMP PARALLEL DO PRIVATE(JL)
  DO JL=1,NFLEVG
    IF (LLVOR)  PSPVOR (JL,:)   = PSPVORG (JL,:)
    IF (LLDIV)  PSPDIV (JL,:)   = PSPDIVG (JL,:)
    IF (LLT)    PSPT   (JL,:)   = PSPTG   (JL,:)
    IF (LLSPD)  PSPSPD (JL,:)   = PSPSPDG (JL,:)
    IF (LLSVD)  PSPSVD (JL,:)   = PSPSVDG (JL,:)
    IF (LLSNHX) PSPSNHX(JL,:)   = PSPSNHXG(JL,:)
    IF (LLAUX)  PSPAUX (JL,:)   = PSPAUXG (JL,:)
    IF (LLGFL)  PSPGFL (JL,:,:) = PSPGFLG (JL,:,:)
  ENDDO
!$OMP END PARALLEL DO
  IF (NPSP ==1 .AND. LLSP) PSPSP(:) = PSPSPG(:)
  IF (LLSEL3D) THEN
    ISEL=0
    DO JFIELD=1,UBOUND(PSPSEL3D,3)
      IF (LDSELECT3D(JFIELD)) THEN
        ISEL=ISEL+1
        PSPSEL3D(1:NFLEVG,:,JFIELD) = PSPSEL3DG(1:NFLEVG,:,ISEL)
      ENDIF
    ENDDO
  ENDIF
  IF (NPSP==1 .AND. LLSEL2D) THEN
    ISEL=0
    DO JFIELD=1,UBOUND(PSPSEL2D,2)
      IF (LDSELECT2D(JFIELD)) THEN
        ISEL=ISEL+1
        PSPSEL2D(:,JFIELD) = PSPSEL2DG(:,ISEL)
      ENDIF
    ENDDO
  ENDIF

ELSE

  ! * message-passing is necessary

  IF (LLFULLM) THEN
    ISPEC2V=NSPEC2VF
    IPTRSV(:)=NPTRSVF(:)
  ELSE
    ISPEC2V=NSPEC2V
    IPTRSV(:)=NPTRSV(:)
  ENDIF

  ! * Set up tables

  IBUFLENR=0
  IBUFLENS=0
  ILEVMIN=ISPEC2V
  DO JROCB=1,NPRTRV-1
    JR=JROCB
    ISENDSET=MYSENDSET(NPRTRN,MYSETN,JR)
    IRECVSET=MYRECVSET(NPRTRV,MYSETV,JR)
    IPOS=0
    IF (LLVOR)   IPOS=IPOS+1
    IF (LLDIV)   IPOS=IPOS+1
    IF (LLT)     IPOS=IPOS+1
    IF (LLSPD)   IPOS=IPOS+1
    IF (LLSVD)   IPOS=IPOS+1
    IF (LLSNHX)  IPOS=IPOS+1
    IF (LLAUX)   IPOS=IPOS+1
    IF (LLGFL)   IPOS=IPOS+INUMSPGFL
    IF (LLSEL3D) IPOS=IPOS+INUMSEL3D

    IF ((NPSP == 1.AND.(LLSP.OR.LLSEL2D)) .OR. LLNEEDPS) THEN
      IISP=1 ! NB: This assumes only one 2D field needs transposing
    ELSE
      IISP=0
    ENDIF
    IF ((NPSURF(IRECVSET) == 1.AND.(LLSP.OR.LLSEL2D)) .OR. LLNEEDPS) THEN
      ILEV=1 ! NB: This assumes only one 2D field needs transposing
    ELSE
      ILEV=0
    ENDIF

    ISEND_START(JR)=1
    ! * number of levels for each wave
    ISEND_LEVELS(JR)=NPTRLL(ISENDSET+1)-NPTRLL(ISENDSET)
    ! * buffer must be able to contain at least a minimum of one wave:
    IMINIMUM(JR)=ISEND_LEVELS(JR)*IPOS
    IBUFLEFT(JR)=0
    IRECVTOT(JR)=(IPTRSV(IRECVSET+1)-IPTRSV(IRECVSET))*(NFLEVL*IPOS+IISP)
    IF (IPTRSV(MYSETN) < IPTRSV(MYSETN+1)) THEN
      ISENDTOT(JR)=ISPEC2V*((NPTRLL(ISENDSET+1)-NPTRLL(ISENDSET))*IPOS+ILEV)
    ELSE
      ISENDTOT(JR)=0
    ENDIF
    IRCVD(JR)=0
    ISENT(JR)=0
    IBUFLENR=MAX(IBUFLENR,IRECVTOT(JR))
    IBUFLENS=MAX(IBUFLENS,ISENDTOT(JR))
  ENDDO

  ISENDCOUNT=0
  IRECVCOUNT=0
  INSEND=0
  INRECV=0
  DO JR=1,NPRTRV-1
    ISENDCOUNT=MAX(ISENDCOUNT,ISENDTOT(JR))
    IRECVCOUNT=MAX(IRECVCOUNT,IRECVTOT(JR))
    IF(ISENDTOT(JR) > 0 )THEN
      INSEND=INSEND+1
      JSEND(INSEND)=JR
    ENDIF
    IF(IRECVTOT(JR) > 0 )THEN
      INRECV=INRECV+1
      JRECV(INRECV)=JR
    ENDIF
  ENDDO

  CALL STOM_COMM

ENDIF

END ASSOCIATE
END ASSOCIATE

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('TRSTOM',1,ZHOOK_HANDLE)

!     ------------------------------------------------------------------

CONTAINS

SUBROUTINE STOM_COMM

REAL(KIND=JPRB) :: ZCOMBUFS(-1:ISENDCOUNT,NPRTRV-1)
REAL(KIND=JPRB) :: ZCOMBUFR(-1:IRECVCOUNT,NPRTRV-1)
INTEGER(KIND=JPIM) :: IRSND, IRRCV, INR, JGFL
INTEGER(KIND=JPIM) :: J,JR,ISENDSET,IPOS,ISPNUM
INTEGER(KIND=JPIM) :: IRECVSET,IRECV_START,IRECV_END

! Use of blocking recv in transpostions (some networks do get flooded)
! 0 = full non-blocking (default)
! 1 = immediate sends, blocking receives
INTEGER(KIND=JPIM) :: ISPEC_SYNC_LEVEL = 0

REAL(KIND=JPRB) :: ZHOOK_HANDLE

!REK IF (LHOOK) CALL DR_HOOK('TRSTOM:STOM_COMM',0,ZHOOK_HANDLE)

ASSOCIATE(NFLEVL=>YDGEOMETRY%YRDIMV%NFLEVL, NFLEVG=>YDGEOMETRY%YRDIMV%NFLEVG, &
 & NPTRLL=>YDGEOMETRY%YRMP%NPTRLL, NPSP=>YDGEOMETRY%YRMP%NPSP, &
 & NPTRSV=>YDGEOMETRY%YRMP%NPTRSV, NPTRSVF=>YDGEOMETRY%YRMP%NPTRSVF, &
 & NSPEC2V=>YDGEOMETRY%YRMP%NSPEC2V, NPSURF=>YDGEOMETRY%YRMP%NPSURF, &
 & NUMLL=>YDGEOMETRY%YRMP%NUMLL, NSPEC2VF=>YDGEOMETRY%YRMP%NSPEC2VF)

! * Communicate with other processors

! * Recv loop .................................................

CALL GSTATS_BARRIER(766)

IF (ISPEC_SYNC_LEVEL == 0) THEN
  IRRCV=0
  CALL GSTATS(507,0)
  DO JR=1,NPRTRN-1
    IF (IRECVTOT(JR) > 0 )THEN
      IRECVSET=MYRECVSET(NPRTRV,MYSETV,JR)
      CALL SET2PE(IRECV,0,0,MYSETW,IRECVSET)
      INSFREC=IPTRSV(IRECVSET+1)-IPTRSV(IRECVSET)
      LLRECV=NUMLL(MYSETV) > 0.OR.((NPSP == 1.AND.(LLSP.OR.LLSEL2D)).OR.LLNEEDPS)
      IF (LLRECV.AND.INSFREC > 0) THEN
        IRRCV=IRRCV+1
        CALL MPL_RECV(ZCOMBUFR(:,JR),KSOURCE=NPRCIDS(IRECV),&
         & KMP_TYPE=JP_NON_BLOCKING_STANDARD,KREQUEST=IRECVREQ(IRRCV), &
         & KTAG=MTAGSM,CDSTRING='TRSTOM:')
      ENDIF
    ENDIF
  ENDDO
  CALL GSTATS(507,1)
ENDIF

CALL GSTATS_BARRIER2(766)

! * Pack and send loop .................................................

CALL GSTATS_BARRIER(766)

IRSND=0
DO J=1,INSEND
  JR=JSEND(J)
  ISENDSET=MYSENDSET(NPRTRN,MYSETN,JR)
  ZCOMBUFS(-1,JR)=ISEND_START(JR)
  IPOS=0
  ISPNUM=0
  CALL GSTATS(1110,0)
  CALL STOM_PACK(JR,ISENDSET,IPOS,ISPNUM,ISENDCOUNT,NPRTRV,ZCOMBUFS)
  CALL GSTATS(1110,1)
  ZCOMBUFS(0,JR)=ISPNUM
  JPOS(JR)=IPOS
  IF(IPOS > 0)THEN
    ISENDSET=MYSENDSET(NPRTRN,MYSETN,JR)
    CALL SET2PE(ISEND,0,0,MYSETM,ISENDSET)
    IRSND=IRSND+1
    CALL GSTATS(507,0)
    CALL MPL_SEND(ZCOMBUFS(-1:IPOS,JR),KDEST=NPRCIDS(ISEND), &
     & KMP_TYPE=JP_NON_BLOCKING_STANDARD,KREQUEST=ISENDREQ(IRSND), &
     & KTAG=MTAGSM,CDSTRING='TRSTOM:')
    CALL GSTATS(507,1)
  ENDIF
ENDDO

CALL GSTATS_BARRIER2(766)

! *  Transpose data used on local processor .................................................

IL1=NPTRLL(MYSETN)
IL2=IL1+NFLEVL-1
CALL GSTATS(1109,0)
!$OMP PARALLEL DO SCHEDULE(STATIC) &
!$OMP &PRIVATE(JVERSP,ISP,JFIELD,ISEL)
DO JVERSP=1,ISPEC2V
  ISP=IPTRSV(MYSETN)-1+JVERSP
  IL1=NPTRLL(MYSETN)
  IL2=IL1+NFLEVL-1
  IF (LLVOR)  PSPVOR (1:NFLEVL,ISP)   = PSPVORG (IL1:IL2,JVERSP)
  IF (LLDIV)  PSPDIV (1:NFLEVL,ISP)   = PSPDIVG (IL1:IL2,JVERSP)
  IF (LLT)    PSPT   (1:NFLEVL,ISP)   = PSPTG   (IL1:IL2,JVERSP)
  IF (LLSPD)  PSPSPD (1:NFLEVL,ISP)   = PSPSPDG (IL1:IL2,JVERSP)
  IF (LLSVD)  PSPSVD (1:NFLEVL,ISP)   = PSPSVDG (IL1:IL2,JVERSP)
  IF (LLSNHX) PSPSNHX(1:NFLEVL,ISP)   = PSPSNHXG(IL1:IL2,JVERSP)
  IF (LLAUX)  PSPAUX (1:NFLEVL,ISP)   = PSPAUXG (IL1:IL2,JVERSP)
  IF (LLGFL)  PSPGFL (1:NFLEVL,ISP,:) = PSPGFLG (IL1:IL2,JVERSP,:)

  IF ((NPSP == 1.AND.LLSP) .OR. LLNEEDPS)  PSPSP(ISP)=PSPSPG(JVERSP)
  IF (NPSP == 1.AND.LLSEL2D) THEN
    ISEL=0
    DO JFIELD=1,UBOUND(PSPSEL2D,2)
      IF (LDSELECT2D(JFIELD)) THEN
        ISEL=ISEL+1
        PSPSEL2D(ISP,JFIELD) = PSPSEL2DG(JVERSP,ISEL)
      ENDIF
    ENDDO
  ENDIF

  IF (LLSEL3D) THEN
    ISEL=0
    DO JFIELD=1,UBOUND(PSPSEL3D,3)
      IF (LDSELECT3D(JFIELD)) THEN
        ISEL=ISEL+1
        PSPSEL3D(1:NFLEVL,ISP,JFIELD) = PSPSEL3DG(IL1:IL2,JVERSP,ISEL)
      ENDIF
    ENDDO
  ENDIF
ENDDO
!$OMP END PARALLEL DO
CALL GSTATS(1109,1)

! * Recv and unpack loop .................................................

CALL GSTATS_BARRIER(766)

IF (ISPEC_SYNC_LEVEL == 0) THEN

  DO J=1,INRECV
    IF (J > IRRCV) THEN
      CALL ABOR1('TRSTOM: ORPHEAN UNPACK CASE !?') ! I believe this should never happen. REK
    ELSE
      CALL GSTATS(508,0)
      CALL MPL_WAITANY(KREQUEST=IRECVREQ(1:IRRCV),KINDEX=INR,CDSTRING='TRMTOS: WAIT FOR RECEIVES')
      CALL GSTATS(508,1)
      JR=JRECV(INR)
    ENDIF
    IRECVSET=MYRECVSET(NPRTRV,MYSETV,JR)
    IRECV_START=ZCOMBUFR(-1,JR)
    IRECV_END  =ZCOMBUFR( 0,JR)
    IPOS=0
    ISPNUM=0
    CALL GSTATS(1111,0)
    CALL STOM_UNPACK(JR,IRECVSET,IPOS,IRECV_START,IRECV_END,ISPNUM,IRECVCOUNT,NPRTRV,ZCOMBUFR)
    CALL GSTATS(1111,1)
  ENDDO

ELSE

  DO JR=1,NPRTRN-1
    IF (IRECVTOT(JR) > 0 )THEN
      IRECVSET=MYRECVSET(NPRTRV,MYSETV,JR)
      CALL SET2PE(IRECV,0,0,MYSETW,IRECVSET)
      INSFREC=IPTRSV(IRECVSET+1)-IPTRSV(IRECVSET)
      LLRECV=NUMLL(MYSETV) > 0.OR.((NPSP == 1.AND.(LLSP.OR.LLSEL2D)).OR.LLNEEDPS)
      IF (LLRECV.AND.INSFREC > 0) THEN
        CALL GSTATS(507,0)
        CALL MPL_RECV(ZCOMBUFR(:,JR),KSOURCE=NPRCIDS(IRECV),&
         & KMP_TYPE=JP_BLOCKING_STANDARD, &
         & KTAG=MTAGSM,CDSTRING='TRSTOM:')
        CALL GSTATS(507,1)
        IRECV_START=ZCOMBUFR(-1,JR)
        IRECV_END  =ZCOMBUFR( 0,JR)
        IPOS=0
        ISPNUM=0
        CALL GSTATS(1111,0)
        CALL STOM_UNPACK(JR,IRECVSET,IPOS,IRECV_START,IRECV_END,ISPNUM,IRECVCOUNT,NPRTRV,ZCOMBUFR)
        CALL GSTATS(1111,1)
      ENDIF
    ENDIF
  ENDDO

ENDIF

CALL GSTATS_BARRIER2(766)

! * Wait completion of sends .................................................

CALL GSTATS_BARRIER(766)

CALL GSTATS(507,0)
IF(IRSND > 0)THEN
  CALL MPL_WAIT(KREQUEST=ISENDREQ(1:IRSND),CDSTRING='TRSTOM: WAIT FOR SENDS')
ENDIF
CALL GSTATS(507,1)

CALL GSTATS_BARRIER2(766)

END ASSOCIATE
!REK IF (LHOOK) CALL DR_HOOK('TRSTOM:STOM_COMM',1,ZHOOK_HANDLE)

END SUBROUTINE STOM_COMM

SUBROUTINE STOM_PACK(KJR,KSENDSET,KPOS,KSPNUM,ISENDCOUNT,NPRTRV,PCOMBUFS)

INTEGER(KIND=JPIM),INTENT(IN)    :: KJR
INTEGER(KIND=JPIM),INTENT(IN)    :: KSENDSET
INTEGER(KIND=JPIM),INTENT(INOUT) :: KPOS
INTEGER(KIND=JPIM),INTENT(INOUT) :: KSPNUM
INTEGER(KIND=JPIM),INTENT(IN)    :: ISENDCOUNT
INTEGER(KIND=JPIM),INTENT(IN)    :: NPRTRV
REAL(KIND=JPRB), INTENT(INOUT)   :: PCOMBUFS(-1:ISENDCOUNT,NPRTRV-1)

INTEGER(KIND=JPIM) :: JSP,JGFL,ISEL,JFIELD,IL1,IL2,ILN, IPOS, ISPNUM, ILEN(ISPEC2V)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('TRSTOM:STOM_PACK',0,ZHOOK_HANDLE)

ASSOCIATE(NFLEVL=>YDGEOMETRY%YRDIMV%NFLEVL, NFLEVG=>YDGEOMETRY%YRDIMV%NFLEVG, &
 & NPTRLL=>YDGEOMETRY%YRMP%NPTRLL, NPSP=>YDGEOMETRY%YRMP%NPSP, &
 & NPTRSV=>YDGEOMETRY%YRMP%NPTRSV, NPTRSVF=>YDGEOMETRY%YRMP%NPTRSVF, &
 & NSPEC2V=>YDGEOMETRY%YRMP%NSPEC2V, NPSURF=>YDGEOMETRY%YRMP%NPSURF, &
 & NUMLL=>YDGEOMETRY%YRMP%NUMLL, NSPEC2VF=>YDGEOMETRY%YRMP%NSPEC2VF)

IF ((NPSURF(KSENDSET) == 1.AND.(LLSP.OR.LLSEL2D)).OR.LLNEEDPS) THEN
  IF (ISENT(KJR) == 0) THEN
    IF (LLSP.OR.LLNEEDPS) THEN
      PCOMBUFS(KPOS+1:KPOS+ISPEC2V,KJR)=PSPSPG(1:ISPEC2V)
      KPOS=KPOS+ISPEC2V
    ENDIF
    IF (LLSEL2D) THEN
      ISEL=0
      DO JFIELD=1,UBOUND(PSPSEL2D,2)
        IF (LDSELECT2D(JFIELD)) THEN
          ISEL=ISEL+1
          PCOMBUFS(KPOS+1:KPOS+ISPEC2V,KJR)=PSPSEL2DG(1:ISPEC2V,ISEL)
          KPOS=KPOS+ISPEC2V ! Assumes only one field selected
        ENDIF
      ENDDO
    ENDIF
    ! * tell receiver that this message contains the extra field
    PCOMBUFS(-1,KJR)=0
    IBUFLEFT(KJR)=IBUFLEFT(KJR)-ISPEC2V
  ENDIF
ENDIF

IL1=NPTRLL(KSENDSET)
IL2=NPTRLL(KSENDSET+1)-1
ILN=IL2-IL1+1
DO JSP=1,ISPEC2V
  ILEN(JSP)=0
  ISPNUM=KSPNUM+JSP
  IF (ISPNUM >= ISEND_START(KJR)) THEN
    IF (LLVOR)  ILEN(JSP)=ILEN(JSP)+ILN
    IF (LLDIV)  ILEN(JSP)=ILEN(JSP)+ILN
    IF (LLT)    ILEN(JSP)=ILEN(JSP)+ILN
    IF (LLSPD)  ILEN(JSP)=ILEN(JSP)+ILN
    IF (LLSVD)  ILEN(JSP)=ILEN(JSP)+ILN
    IF (LLSNHX) ILEN(JSP)=ILEN(JSP)+ILN
    IF (LLAUX)  ILEN(JSP)=ILEN(JSP)+ILN
    IF (LLGFL) THEN
      DO JGFL=1,INUMSPGFL
        ILEN(JSP)=ILEN(JSP)+ILN
      ENDDO
    ENDIF
    IF (LLSEL3D) THEN
      DO JFIELD=1,UBOUND(PSPSEL3D,3)
        IF (LDSELECT3D(JFIELD)) THEN
          ILEN(JSP)=ILEN(JSP)+ILN
        ENDIF
      ENDDO
    ENDIF
    IBUFLEFT(KJR)=IBUFLEFT(KJR)-IMINIMUM(KJR)
  ENDIF
ENDDO

!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JSP,IPOS,ISPNUM,JGFL,ISEL,JFIELD)
DO JSP=1,ISPEC2V
  IF (JSP==1) THEN
    IPOS=KPOS
  ELSE
    IPOS=KPOS+SUM(ILEN(1:JSP-1))
  ENDIF
  ISPNUM=KSPNUM+JSP
  IF (ISPNUM >= ISEND_START(KJR)) THEN
    IF (LLVOR)  PCOMBUFS(IPOS+1:IPOS+ILN,KJR)=PSPVORG(IL1:IL2,JSP)
    IF (LLVOR)  IPOS=IPOS+ILN
    IF (LLDIV)  PCOMBUFS(IPOS+1:IPOS+ILN,KJR)=PSPDIVG(IL1:IL2,JSP)
    IF (LLDIV)  IPOS=IPOS+ILN
    IF (LLT)    PCOMBUFS(IPOS+1:IPOS+ILN,KJR)=PSPTG(IL1:IL2,JSP)
    IF (LLT)    IPOS=IPOS+ILN
    IF (LLSPD)  PCOMBUFS(IPOS+1:IPOS+ILN,KJR)=PSPSPDG(IL1:IL2,JSP)
    IF (LLSPD)  IPOS=IPOS+ILN
    IF (LLSVD)  PCOMBUFS(IPOS+1:IPOS+ILN,KJR)=PSPSVDG(IL1:IL2,JSP)
    IF (LLSVD)  IPOS=IPOS+ILN
    IF (LLSNHX) PCOMBUFS(IPOS+1:IPOS+ILN,KJR)=PSPSNHXG(IL1:IL2,JSP)
    IF (LLSNHX) IPOS=IPOS+ILN
    IF (LLAUX)  PCOMBUFS(IPOS+1:IPOS+ILN,KJR)=PSPAUXG(IL1:IL2,JSP)
    IF (LLAUX)  IPOS=IPOS+ILN
    IF (LLGFL) THEN
      DO JGFL=1,INUMSPGFL
        PCOMBUFS(IPOS+1:IPOS+ILN,KJR)=PSPGFLG(IL1:IL2,JSP,JGFL)
        IPOS=IPOS+ILN
      ENDDO
    ENDIF
    IF (LLSEL3D) THEN
      ISEL=0
      DO JFIELD=1,UBOUND(PSPSEL3D,3)
        IF (LDSELECT3D(JFIELD)) THEN
          ISEL=ISEL+1
          PCOMBUFS(IPOS+1:IPOS+ILN,KJR) = PSPSEL3DG(IL1:IL2,JSP,ISEL)
          IPOS=IPOS+ILN
        ENDIF
      ENDDO
    ENDIF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

KPOS=KPOS+SUM(ILEN(1:ISPEC2V))
KSPNUM=KSPNUM+ISPEC2V

END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('TRSTOM:STOM_PACK',1,ZHOOK_HANDLE)
END SUBROUTINE STOM_PACK

!     ------------------------------------------------------------------

SUBROUTINE STOM_UNPACK(KJR,KRECVSET,KPOS,KRECV_START,KRECV_END,KSPNUM,IRECVCOUNT,NPRTRV,PCOMBUFR)

INTEGER(KIND=JPIM),INTENT(IN)    :: KJR
INTEGER(KIND=JPIM),INTENT(IN)    :: KRECVSET
INTEGER(KIND=JPIM),INTENT(INOUT) :: KPOS
INTEGER(KIND=JPIM),INTENT(INOUT) :: KRECV_START
INTEGER(KIND=JPIM),INTENT(IN)    :: KRECV_END
INTEGER(KIND=JPIM),INTENT(INOUT) :: KSPNUM
INTEGER(KIND=JPIM),INTENT(IN)    :: IRECVCOUNT
INTEGER(KIND=JPIM),INTENT(IN)    :: NPRTRV
REAL(KIND=JPRB), INTENT(IN)      :: PCOMBUFR(-1:IRECVCOUNT,NPRTRV-1)

INTEGER(KIND=JPIM) :: JSP,JGFL,JFIELD, IST, IEN, ILN, ISPNUM, IPOS
INTEGER(KIND=JPIM), ALLOCATABLE :: ILEN(:)
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('TRSTOM:STOM_UNPACK',0,ZHOOK_HANDLE)

ASSOCIATE(NFLEVL=>YDGEOMETRY%YRDIMV%NFLEVL, NFLEVG=>YDGEOMETRY%YRDIMV%NFLEVG, &
 & NPTRLL=>YDGEOMETRY%YRMP%NPTRLL, NPSP=>YDGEOMETRY%YRMP%NPSP, &
 & NPTRSV=>YDGEOMETRY%YRMP%NPTRSV, NPTRSVF=>YDGEOMETRY%YRMP%NPTRSVF, &
 & NSPEC2V=>YDGEOMETRY%YRMP%NSPEC2V, NPSURF=>YDGEOMETRY%YRMP%NPSURF, &
 & NUMLL=>YDGEOMETRY%YRMP%NUMLL, NSPEC2VF=>YDGEOMETRY%YRMP%NSPEC2VF)

IST=IPTRSV(KRECVSET)
IEN=IPTRSV(KRECVSET+1)-1
ILN=IEN-IST+1
ALLOCATE(ILEN(IST:IEN))

IF (KRECV_START == 0 ) THEN
  ! * buffer contains extra surface spectral field
  IF (LLSP) THEN
    PSPSP(IST:IEN)=PCOMBUFR(KPOS+1:KPOS+ILN,KJR)
    KPOS=KPOS+ILN
    KRECV_START = 1
  ENDIF
  IF (LLSEL2D) THEN
    DO JFIELD=1,UBOUND(PSPSEL2D,2)
      IF (LDSELECT2D(JFIELD)) THEN
        PSPSEL2D(IST:IEN,JFIELD) = PCOMBUFR(KPOS+1:KPOS+ILN,KJR)
        KPOS=KPOS+ILN !NB: Assumes only one 3d field selected
      ENDIF
    ENDDO
    KRECV_START = 1
  ENDIF
ENDIF

DO JSP=IST,IEN
  ILEN(JSP)=0
  ISPNUM=KSPNUM+JSP-IST+1
  IF (ISPNUM >= KRECV_START .AND. ISPNUM <= KRECV_END) THEN
    IF (LLVOR)  ILEN(JSP)=ILEN(JSP)+NFLEVL
    IF (LLDIV)  ILEN(JSP)=ILEN(JSP)+NFLEVL
    IF (LLT)    ILEN(JSP)=ILEN(JSP)+NFLEVL
    IF (LLSPD)  ILEN(JSP)=ILEN(JSP)+NFLEVL
    IF (LLSVD)  ILEN(JSP)=ILEN(JSP)+NFLEVL
    IF (LLSNHX) ILEN(JSP)=ILEN(JSP)+NFLEVL
    IF (LLAUX)  ILEN(JSP)=ILEN(JSP)+NFLEVL
    IF (LLGFL) THEN
      DO JGFL=1,INUMSPGFL
        ILEN(JSP)=ILEN(JSP)+NFLEVL
      ENDDO
    ENDIF
    IF (LLSEL3D) THEN
      DO JFIELD=1,UBOUND(PSPSEL3D,3)
        IF (LDSELECT3D(JFIELD)) THEN
          ILEN(JSP)=ILEN(JSP)+NFLEVL
        ENDIF
      ENDDO
    ENDIF
  ENDIF
ENDDO

!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JSP,IPOS,ISPNUM,JGFL,JFIELD)
DO JSP=IST,IEN
  IF (JSP==IST) THEN
    IPOS=KPOS
  ELSE
    IPOS=KPOS+SUM(ILEN(IST:JSP-1))
  ENDIF
  ISPNUM=KSPNUM+JSP-IST+1
  IF (ISPNUM >= KRECV_START .AND. ISPNUM <= KRECV_END) THEN
    IF (LLVOR)  PSPVOR(1:NFLEVL,JSP)=PCOMBUFR(IPOS+1:IPOS+NFLEVL,KJR)
    IF (LLVOR)  IPOS=IPOS+NFLEVL
    IF (LLDIV)  PSPDIV(1:NFLEVL,JSP)=PCOMBUFR(IPOS+1:IPOS+NFLEVL,KJR)
    IF (LLDIV)  IPOS=IPOS+NFLEVL
    IF (LLT)    PSPT(1:NFLEVL,JSP)=PCOMBUFR(IPOS+1:IPOS+NFLEVL,KJR)
    IF (LLT)    IPOS=IPOS+NFLEVL
    IF (LLSPD)  PSPSPD(1:NFLEVL,JSP)=PCOMBUFR(IPOS+1:IPOS+NFLEVL,KJR)
    IF (LLSPD)  IPOS=IPOS+NFLEVL
    IF (LLSVD)  PSPSVD(1:NFLEVL,JSP)=PCOMBUFR(IPOS+1:IPOS+NFLEVL,KJR)
    IF (LLSVD)  IPOS=IPOS+NFLEVL
    IF (LLSNHX) PSPSNHX(1:NFLEVL,JSP)=PCOMBUFR(IPOS+1:IPOS+NFLEVL,KJR)
    IF (LLSNHX) IPOS=IPOS+NFLEVL
    IF (LLAUX)  PSPAUX(1:NFLEVL,JSP)=PCOMBUFR(IPOS+1:IPOS+NFLEVL,KJR)
    IF (LLAUX)  IPOS=IPOS+NFLEVL
    IF (LLGFL) THEN
      DO JGFL=1,INUMSPGFL
        PSPGFL(1:NFLEVL,JSP,JGFL)=PCOMBUFR(IPOS+1:IPOS+NFLEVL,KJR)
        IPOS=IPOS+NFLEVL
      ENDDO
    ENDIF
    IF (LLSEL3D) THEN
      DO JFIELD=1,UBOUND(PSPSEL3D,3)
        IF (LDSELECT3D(JFIELD)) THEN
          PSPSEL3D(1:NFLEVL,JSP,JFIELD) = PCOMBUFR(IPOS+1:IPOS+NFLEVL,KJR)
          IPOS=IPOS+NFLEVL
        ENDIF
      ENDDO
    ENDIF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

KPOS=KPOS+SUM(ILEN(IST:IEN))
KSPNUM=MIN(KSPNUM+ILN,KRECV_END)

END ASSOCIATE

IF (LHOOK) CALL DR_HOOK('TRSTOM:STOM_UNPACK',1,ZHOOK_HANDLE)
END SUBROUTINE STOM_UNPACK

!     ------------------------------------------------------------------
END SUBROUTINE TRSTOM
