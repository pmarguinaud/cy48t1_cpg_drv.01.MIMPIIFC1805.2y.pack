SUBROUTINE MF_PHYS (YDGEOMETRY, YDCPG_BNDS, YDCPG_OPTS, YDCPG_MISC, YDCPG_GPAR, YDCPG_PHY0,    &
& YDCPG_PHY9, YDMF_PHYS, YDCPG_DYN0, YDCPG_DYN9, YDMF_PHYS_SURF, YDCPG_SL1, YDCPG_SL2, YDVARS, &
& YDMODEL, YDFIELDS, LDCONFX, PDTPHY, PGPSDT2D, PGFL, PGMVT1, PGFLT1, PTRAJ_PHYS, YDDDH)

USE PARKIND1, ONLY : JPIM, JPRB
USE YOMHOOK, ONLY : LHOOK, DR_HOOK

USE GEOMETRY_MOD       , ONLY : GEOMETRY
USE CPG_OPTS_TYPE_MOD   , ONLY : CPG_BNDS_TYPE, CPG_OPTS_TYPE
USE MF_PHYS_TYPE_MOD   , ONLY : MF_PHYS_TYPE
USE CPG_TYPE_MOD       , ONLY : CPG_DYN_TYPE, CPG_PHY_TYPE, CPG_MISC_TYPE, &
                              & CPG_TND_TYPE, CPG_TMP_TYPE, CPG_DDH_TYPE, &
                              & CPG_SL1_TYPE, CPG_SL2_TYPE, CPG_GPAR_TYPE
USE MF_PHYS_SURFACE_TYPE_MOD,ONLY : MF_PHYS_SURF_TYPE
USE FIELD_VARIABLES_MOD, ONLY : FIELD_VARIABLES
USE TYPE_MODEL         , ONLY : MODEL
USE FIELDS_MOD         , ONLY : FIELDS
USE YOMTRAJ            , ONLY : TRAJ_PHYS_TYPE, TRAJ_SLAG_TYPE
USE DDH_MIX            , ONLY : TYP_DDH, SETDDH, CLEANDDH
USE YOMSPSDT           , ONLY : YSPPT
USE YOMCT0             , ONLY : LNHQE, LTWOTL
USE MF_PHYS_BASE_STATE_TYPE_MOD &
                       , ONLY : MF_PHYS_BASE_STATE_TYPE
USE MF_PHYS_NEXT_STATE_TYPE_MOD &
                       , ONLY : MF_PHYS_NEXT_STATE_TYPE


IMPLICIT NONE

TYPE(GEOMETRY),         INTENT(IN)    :: YDGEOMETRY
TYPE(CPG_BNDS_TYPE),    INTENT(IN)    :: YDCPG_BNDS
TYPE(CPG_OPTS_TYPE),    INTENT(IN)    :: YDCPG_OPTS
TYPE(CPG_MISC_TYPE),    INTENT(INOUT) :: YDCPG_MISC
TYPE(CPG_GPAR_TYPE),    INTENT(INOUT) :: YDCPG_GPAR
TYPE(CPG_PHY_TYPE),     INTENT(INOUT) :: YDCPG_PHY0
TYPE(CPG_PHY_TYPE),     INTENT(INOUT) :: YDCPG_PHY9
TYPE(MF_PHYS_TYPE),     INTENT(INOUT) :: YDMF_PHYS
TYPE(CPG_DYN_TYPE),     INTENT(IN)    :: YDCPG_DYN0
TYPE(CPG_DYN_TYPE),     INTENT(IN)    :: YDCPG_DYN9
TYPE(MF_PHYS_SURF_TYPE),INTENT(INOUT) :: YDMF_PHYS_SURF
TYPE(CPG_SL1_TYPE),     INTENT(INOUT) :: YDCPG_SL1
TYPE(CPG_SL2_TYPE),     INTENT(INOUT) :: YDCPG_SL2
TYPE(FIELD_VARIABLES),  INTENT(INOUT) :: YDVARS
TYPE(MODEL),            INTENT(IN)    :: YDMODEL
TYPE(FIELDS),           INTENT(IN)    :: YDFIELDS
LOGICAL,                INTENT(IN)    :: LDCONFX
REAL(KIND=JPRB),        INTENT(IN)    :: PDTPHY
REAL(KIND=JPRB),        INTENT(IN)   , OPTIONAL :: PGPSDT2D(YDCPG_OPTS%KLON,YSPPT%YGPSDT(1)%NG2D)
REAL(KIND=JPRB),        INTENT(INOUT), OPTIONAL :: PGFL(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG,YDMODEL%YRML_GCONF%YGFL%NDIM)
REAL(KIND=JPRB),        INTENT(INOUT), OPTIONAL :: PGMVT1(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG,YDFIELDS%YRGMV%YT1%NDIM)
REAL(KIND=JPRB),        INTENT(INOUT), OPTIONAL :: PGFLT1(YDCPG_OPTS%KLON,YDCPG_OPTS%KFLEVG,YDMODEL%YRML_GCONF%YGFL%NDIM1)
TYPE (TRAJ_PHYS_TYPE),  INTENT(INOUT), OPTIONAL :: PTRAJ_PHYS
TYPE(TYP_DDH),          INTENT(INOUT), OPTIONAL :: YDDDH

#include "apl_arome.intfb.h"
#include "aplpar.intfb.h"
#include "apl_arpege.intfb.h"
#include "aplsim.intfb.h"
#include "mf_phys_prep.intfb.h"
#include "mf_phys_init.intfb.h"
#include "mf_phys_nhqe_part1.intfb.h"
#include "mf_phys_nhqe_part2.intfb.h"


REAL (KIND=JPRB) :: ZNHQ_TT0L (YDCPG_OPTS%KLON, 1:YDCPG_OPTS%KFLEVG)
REAL (KIND=JPRB) :: ZNHQ_TT9  (YDCPG_OPTS%KLON, 1:YDCPG_OPTS%KFLEVG)
REAL (KIND=JPRB) :: ZNHQ_TT0  (YDCPG_OPTS%KLON, 1:YDCPG_OPTS%KFLEVG)
REAL (KIND=JPRB) :: ZNHQ_TT0M (YDCPG_OPTS%KLON, 1:YDCPG_OPTS%KFLEVG)

TYPE (MF_PHYS_BASE_STATE_TYPE) :: YLMF_PHYS_BASE_STATE
TYPE (MF_PHYS_NEXT_STATE_TYPE) :: YLMF_PHYS_NEXT_STATE

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('MF_PHYS', 0, ZHOOK_HANDLE)

!*       4.4.1   Call MF unlagged physics (predictor only if PC scheme).

CALL MF_PHYS_PREP (YDGEOMETRY, YDCPG_BNDS, YDCPG_OPTS, YDMODEL%YRML_PHY_MF%YRARPHY, YDCPG_DYN0, &
& YDCPG_DYN9, YDCPG_PHY0, YDCPG_PHY9, YDVARS)

CALL MF_PHYS_INIT (YDCPG_BNDS, YDCPG_OPTS, YDMF_PHYS, YDCPG_MISC)

!=SKIP
! In the NHQE model, APLPAR enters with Tt and grad(Tt), where Tt = T * exp(-(R/cp) log(pre/prehyd)).
! But calculations of APLPAR must use T and grad(T).
! So we do a conversion Tt -> T.
IF (LNHQE) THEN
  CALL MF_PHYS_NHQE_PART1 (YDGEOMETRY, YDCPG_BNDS, YDCPG_OPTS, ZNHQ_TT0, ZNHQ_TT0L, ZNHQ_TT0M, &
  & ZNHQ_TT9, YDVARS, YDMODEL, PGFL)
ENDIF
!=END SKIP


!=SERIAL
CALL YLMF_PHYS_BASE_STATE%INIT (YDCPG_DYN0, YDCPG_DYN9, YDCPG_PHY0, YDCPG_PHY9, YDVARS, &
& YDMF_PHYS_SURF, PGFL=PGFL, YDMODEL=YDMODEL)

CALL YLMF_PHYS_NEXT_STATE%INIT (YDCPG_SL1, YDGEOMETRY, YDVARS, YDMODEL)
!=END SERIAL

IF (YDMODEL%YRML_PHY_MF%YRSIMPHL%LSIMPH) THEN

  CALL APLSIM(YLMF_PHYS_BASE_STATE, YLMF_PHYS_NEXT_STATE, YDGEOMETRY, YDCPG_BNDS, YDCPG_OPTS, &
  & YDCPG_MISC, YDCPG_PHY0, YDMF_PHYS, YDCPG_DYN0, YDMF_PHYS_SURF, YDVARS, YDMODEL, PDTPHY,   &
  & PTRAJ_PHYS)

ELSEIF (YDMODEL%YRML_PHY_MF%YRARPHY%LMPA) THEN
!=SKIP
  CALL APL_AROME(YLMF_PHYS_BASE_STATE, YLMF_PHYS_NEXT_STATE, YDGEOMETRY, YDCPG_BNDS, YDCPG_OPTS,        &
  & YDCPG_MISC, YDCPG_GPAR, YDCPG_PHY0, YDCPG_PHY9, YDMF_PHYS, YDCPG_DYN0, YDCPG_DYN9,                  &
  & YDMF_PHYS_SURF, YDCPG_SL1, YDVARS, YDFIELDS%YRGMV, YDFIELDS%YRSURF, YDFIELDS%YRCFU, YDFIELDS%YRXFU, &
  & YDMODEL, LDCONFX, PDTPHY, PGFL, PGPSDT2D, PGMVT1, PGFLT1, PTRAJ_PHYS, YDDDH)
!=END SKIP
ELSEIF (YDMODEL%YRML_PHY_MF%YRARPHY%LAPL_ARPEGE) THEN
!=SKIP
  CALL APL_ARPEGE (YLMF_PHYS_BASE_STATE, YLMF_PHYS_NEXT_STATE, YDGEOMETRY, YDCPG_BNDS, YDCPG_OPTS,                 &
  & YDCPG_MISC, YDCPG_GPAR, YDCPG_PHY0, YDMF_PHYS, YDCPG_DYN0, YDMF_PHYS_SURF, YDCPG_SL2, YDVARS, YDFIELDS%YRSURF, &
  & YDFIELDS%YRCFU, YDFIELDS%YRXFU, YDMODEL, LDCONFX, PDTPHY, YDDDH)
!=END SKIP
ELSE
!=SKIP
  CALL APLPAR (YLMF_PHYS_BASE_STATE, YLMF_PHYS_NEXT_STATE, YDGEOMETRY, YDCPG_BNDS, YDCPG_OPTS,       &
  & YDCPG_MISC, YDCPG_GPAR, YDCPG_PHY0, YDMF_PHYS, YDCPG_DYN0, YDMF_PHYS_SURF, YDCPG_SL1, YDCPG_SL2, &
  & YDVARS, YDFIELDS%YRGMV, YDFIELDS%YRSURF, YDFIELDS%YRCFU, YDFIELDS%YRXFU, YDMODEL, LDCONFX,       &
  & PDTPHY, PGFL, PGMVT1, PGFLT1, PTRAJ_PHYS, YDDDH)
!=END SKIP
ENDIF

!=SKIP
! Restore Tt and grad(Tt) for NHQE model.
IF (LNHQE) THEN
  CALL MF_PHYS_NHQE_PART2 (YDGEOMETRY, YDCPG_BNDS, YDCPG_OPTS, ZNHQ_TT0, ZNHQ_TT0L, ZNHQ_TT0M, &
  & ZNHQ_TT9, YDVARS)
ENDIF
!=END SKIP

IF (LHOOK) CALL DR_HOOK('MF_PHYS', 1, ZHOOK_HANDLE)

END SUBROUTINE
