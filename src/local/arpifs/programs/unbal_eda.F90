PROGRAM UNBAL_EDA

!      UNBAL_EDA - Calculate ensemble bg variances of Unbalanced 
!                  components of analysis control vector (UCDV,UCTP,UCLN)


!     Interface:  UNBAL_EDA.ex filein(ensemble) fileout(stdev/var) Ensemble_Size Balance(UNBAL/TOTAL) output type(STD/tVAR)'
!     ---------
 
!     Author: Massimo Bonavita

!     ------
!     Modifications.
!     --------------
!      Original   11-
!      2015-05-26  E Holm  Add cubic, cubic octahedral, more resolutions and FFTW.
!      2015-11-10  M. Bonavita Fixed wrong grib headers
!      2016-02-02  E. Holm  Simpler variance calculation loop requiring less memory.
!     ------------------------------------------------------------------

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE PARKIND1  , ONLY : JPIM, JPRB, JPRD
USE YOMHOOK   , ONLY : LHOOK, DR_HOOK
USE YOMCST    , ONLY : SETUP_CONSTANTS,RA,ROMEGA,RPI
USE YOMVERT   , ONLY : VP00, TOPPRES 
USE YOMCT0    , ONLY : LNHDYN, LECMWF
USE YOMDIMF   , ONLY : TDIMF
USE YOMDYNA   , ONLY : YRDYNA
USE YOMDYNCORE, ONLY : RT00_DYN, RPLRG
USE YOM_GRIB_CODES   , ONLY : NGRBVO, NGRBD, NGRBT, NGRBLNSP, NGRBO3,&
 & NGRBUCTP, NGRBUCLN, NGRBUCDV
USE YOMJG     , ONLY : JB_STRUCT
USE YOMLUN    , ONLY : NULOUT, NULNAM 
USE YOMMP0    , ONLY : NPRCIDS, MYPROC, MYSETN, MYSETV, MYSETW, NPRTRV, NPRTRN
USE IOSTREAM_MIX,ONLY: INI_IOSTREAM
USE YOMTAG    , ONLY : MTAGMS, MTAGFCE
USE SPECTRAL_FIELDS_MOD
USE OML_MOD   , ONLY : OML_INIT, OML_INIT_LOCK
USE MPL_MODULE
USE GRIB_API

USE INTDYN_MOD, ONLY : YYTXYB, SUINTDYN

USE YOMERRTRAP ! from ifsaux


!     ------------------------------------------------------------------
 
IMPLICIT NONE
 
! Should be defined in GRIB_API module
INTEGER, EXTERNAL :: IARGC
INTEGER, PARAMETER :: GRIB_SECTION_PRODUCT =  1
INTEGER, PARAMETER :: GRIB_SECTION_GRID    =  2
INTEGER, PARAMETER :: GRIB_SECTION_LOCAL   =  4
INTEGER, PARAMETER :: GRIB_SECTION_DATA    =  8
INTEGER, PARAMETER :: GRIB_SECTION_BITMAP  = 16

!!TYPE(TYPE_JB_STRUCT) :: YDJBS
!!TYPE(TYPE_JB_STRUCT) :: JB_STRUCT

INTEGER(KIND=JPIM) :: J, J1, J2, JFIELD, JLEV, INM, IG, IM, JN, JFIE,&
& IPTJB, IFL, JMEMBER, JDATE, INFCDIFFS, IGPBLKS, IOMASTER, JMLOC, JIR, IPTJBVO, IPTJBT,&
& ITRUNC_PS, NB_PV, IC, ISTART, JLAT, JLON
INTEGER(KIND=JPIM), PARAMETER :: JPKS=KIND(1.0_JPRB)
INTEGER(KIND=JPIM), PARAMETER :: JPKD=KIND(1.0_JPRB)
INTEGER(KIND=JPIM),ALLOCATABLE :: ITRUNC(:,:),ITRUNC_MODEL(:,:)

INTEGER(KIND=JPIM), ALLOCATABLE :: IVSETSC2(:)

INTEGER(KIND=JPIM) :: IIGRIB2D(100),IIGRIB3D(100)

REAL(KIND=JPRB),ALLOCATABLE :: ZSPA3(:,:,:),ZSPA2(:,:)

REAL(KIND=JPRB),ALLOCATABLE :: ZZP(:,:), ZDIV(:,:),&
& ZSP3VAR_EPSILON(:,:,:), ZSP2VAR_EPSILON(:,:),&
& ZSP2MEM_EPSILON(:,:,:), ZSP2MEMR_EPSILON(:,:), ZSP3MEM_EPSILON(:,:,:,:),&
& ZSP3MEAN(:,:,:), ZSP2MEAN(:,:)

REAL(KIND=JPRB),ALLOCATABLE :: ZGP3VAR_EPSILON(:,:,:,:), ZGP2VAR_EPSILON(:,:,:),&
& ZGP3MEM_EPSILON(:,:,:,:), ZGP2MEM_EPSILON(:,:,:)

REAL(KIND=JPRB),ALLOCATABLE :: ZTRUNC_MODEL(:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZPS(:),ZPSTD(:),ZPSSOURCE(:,:)
REAL(KIND=JPRB),ALLOCATABLE :: ZFILT(:)
REAL(KIND=JPRB),ALLOCATABLE :: PV(:)
REAL(KIND=JPRB) :: ZPREF
!!REAL(KIND=JPRB) :: ZPA2JB(NSPEC2,YRDIMF%NS2D)
REAL(KIND=JPRB) :: ZHOOK_HANDLE


!Local Variables
INTEGER(KIND=JPIM),PARAMETER :: JPMLAT=2048
REAL(KIND=JPRB) :: ZGEMU
REAL(KIND=JPRD),ALLOCATABLE :: RMU(:)
INTEGER(KIND=JPIM) :: NRGRI(JPMLAT)
INTEGER(KIND=JPIM) ,ALLOCATABLE :: NLOEN(:)
INTEGER(KIND=JPIM) ,ALLOCATABLE :: IBSETLEV(:)
INTEGER(KIND=JPIM) :: NPROC
INTEGER(KIND=JPIM) :: NLIN 
INTEGER(KIND=JPIM) :: NTYPE ! 0 -> full grid, 1 -> reduced grid
INTEGER(KIND=JPIM) :: DATE  ! dataDate !
INTEGER(KIND=JPIM) :: TIME  ! dataTime !
INTEGER(KIND=JPIM) :: IGRIB_EDITION  ! editionNumber of the grib: 1,2 !
CHARACTER*5        :: EXPVER     ! experimentVersionNumber !
INTEGER(KIND=JPIM) :: IN_ENS, NDGL, NDLON, NOUT, NERR, NQ
INTEGER(KIND=JPIM) :: IFILE, IFILE_OUT, IGRIB, IGRIB_OUT, IGRIB_SAMPLE, IRET
INTEGER(KIND=JPIM) :: IVAL, ITABLE, ILENGTH, ILEVEL, IPAR, IBL
INTEGER(KIND=JPIM) :: IER
CHARACTER (LEN = 120) ::  CLFILE, COUT_STAND_ATMOS
CHARACTER (LEN = 3) ::  AN_ENS
CHARACTER (LEN = 5) ::  ABALANCE
CHARACTER (LEN = 3) ::  AVAR, ANLIN, ANQ
CHARACTER(LEN=120) ::  AFILEIN, AFILEIN1, AFILEOUT, CRTABLE, CRTABLE_IN
LOGICAL :: LSCAL
LOGICAL :: LBALANCE
INTEGER(KIND=JPIM) :: IOFF_VOR, IOFF_DIV, IOFF_U, IOFF_V, IOFF_NS_T, &
                    & IOFF_EW_U, IOFF_EW_V, IOFF_EW_T
REAL(KIND=JPRB), ALLOCATABLE :: ZGP7(:,:,:)
TYPE(GEOMETRY), TARGET :: YRGEOMETRY
TYPE(TDIMF) :: YRDIMF

NAMELIST/NAMRGRI/ NRGRI

!     ------------------------------------------------------------------

#include "setup_trans0.h"
#include "setup_trans.h"
#include "trans_inq.h"
#include "dir_trans.h"
#include "inv_trans.h"

!!#include "intavg.h"
 
#include "balstat.intfb.h"
#include "balomegatl.intfb.h"
#include "balnonlintl.intfb.h"
#include "sujbbal.intfb.h"
#include "sudyncore.intfb.h"

#include "susta.intfb.h"

!     ------------------------------------------------------------------
CALL SET_ERR_TRAP

!     ------------------------------------------------------------------

LHOOK=.TRUE.
IF (LHOOK) CALL DR_HOOK('UNBAL_EDA',0,ZHOOK_HANDLE)

YRGEOMETRY%YRVAB => YRGEOMETRY%YRVERT_GEOM%YRVAB


ASSOCIATE(YRDIM=>YRGEOMETRY%YRDIM, YRDIMV=>YRGEOMETRY%YRDIMV, &
 & YRGEM=>YRGEOMETRY%YRGEM, YRMP=>YRGEOMETRY%YRMP, &
 & YRSTA=>YRGEOMETRY%YRSTA, YRVAB=>YRGEOMETRY%YRVAB, &
 & YRLAP=>YRGEOMETRY%YRLAP, YRGSGEOM_NB=>YRGEOMETRY%YRGSGEOM_NB)
ASSOCIATE(NPROMA=>YRDIM%NPROMA, NSMAX=>YRDIM%NSMAX, NSPEC2=>YRDIM%NSPEC2, &
 & NRESOL=>YRDIM%NRESOL, NUMP=>YRDIM%NUMP, &
 & NS2D=>YRDIMF%NS2D, NS3D=>YRDIMF%NS3D, &
 & NFLEVG=>YRDIMV%NFLEVG, NFLSUR=>YRDIMV%NFLSUR, NFLEVL=>YRDIMV%NFLEVL, &
 & NGPTOT=>YRGEM%NGPTOT, &
 & NPSP=>YRMP%NPSP, NSPEC2V=>YRMP%NSPEC2V, NSPEC2VF=>YRMP%NSPEC2VF)

!     ------------------------------------------------------------------
CALL OML_INIT
!     ------------------------------------------------------------------

NPROC=MPL_NPROC()
IF(NPROC == 1) THEN
  !-- serial binary ---
  LSCAL=.TRUE.
ENDIF
NERR    = 0
NOUT    = 6
NULOUT  = 6
!NULNAM  =  4
!NULTMP  =  77
MYPROC  = 1
NLIN    = 0
NDGL    = 0
NQ      = 0
NTYPE   = 1  ! Reduced grid
CRTABLE = '/home/rd/rdx/data/ifs'
CRTABLE_IN = ' '

!C THERMODYNAMIC and OTHER INITIAL. C!
CALL SUDYNCORE
CALL SETUP_CONSTANTS(NULOUT,0)
!C Initialize  yomct0 switches/variables C!
LNHDYN = .FALSE.
NPRTRV = 1
NPRTRN = 1

!C Initialize  yomdyna switches/variables C!
YRDYNA%LNHX = .FALSE.

!C Initialize  yommp switches/variables C!
ALLOCATE(NPRCIDS(NPROC)); NPRCIDS(1) = 1
ALLOCATE(YRMP%NPTRSV(NPRTRV+1));  YRMP%NPTRSV(:)=1
ALLOCATE(YRMP%NPTRSVF(NPRTRV+1)); YRMP%NPTRSVF(:)=1
ALLOCATE(YRMP%NPTRLL(NPRTRV+1));  YRMP%NPTRLL(:)=1
ALLOCATE(YRMP%NPSURF(NPRTRV));    YRMP%NPSURF(1) = 1
NPSP = 1
MYSETN=1; MYSETV=1; MYSETW=1;

!======================================!
!C get infile and prepare structures  C!
!======================================!

IF(IARGC().LT.5) THEN
  PRINT*,'Usage: UNBAL_EDA.ex filein(ensemble) fileout(stdev) Ensemble_Size Balance(UNBAL or TOTAL) output type(STD or VAR)&
 &  CRTABLE_path (optional)'
  CALL EXIT(2)
ENDIF

CALL GETARG(1, AFILEIN)
CALL GETARG(2, AFILEOUT)
CALL GETARG(3, AN_ENS)
CALL GETARG(4, ABALANCE)
CALL GETARG(5, AVAR)
CALL GETARG(6, CRTABLE_IN)
CALL GETARG(7, ANLIN)
CALL GETARG(8, ANQ)
AFILEIN1=TRIM(ADJUSTL(AFILEIN))//'_001' ! Use the first ensemble member to get grib geometry
PRINT*,'filein: ',AFILEIN
AFILEOUT=TRIM(ADJUSTL(AFILEOUT))
PRINT*,'fileout: ',AFILEOUT
READ (AN_ENS,'(I3)') IN_ENS
READ (ANLIN,'(I3)') NLIN
READ (ANQ,'(I3)') NQ
PRINT*,'Ensemble size: ',IN_ENS
IF(ABALANCE .EQ. 'UNBAL') THEN
  LBALANCE=.TRUE.
ELSE
  LBALANCE=.FALSE.
ENDIF
PRINT*,'ABALANCE= ',ABALANCE,' LBALANCE= ',LBALANCE
PRINT*,'Computing= ',AVAR
IF(CRTABLE_IN .NE. ' ') THEN
  CRTABLE=TRIM(ADJUSTL(CRTABLE_IN))
ENDIF
PRINT*,'USING CRTABLE path: ', CRTABLE

!    Determine the geometry of the input fields

CALL GRIB_OPEN_FILE(IFILE,AFILEIN1,'r',IRET)
IF(IRET .NE. GRIB_SUCCESS) THEN
    PRINT*,'Unable to open: ',AFILEIN1
    PRINT*,'exiting...'
    CALL EXIT(1)
ENDIF
CALL GRIB_NEW_FROM_FILE(IFILE,IGRIB, IRET)
CALL GRIB_GET(IGRIB,'numberOfVerticalCoordinateValues',IVAL)
NFLEVL=IVAL/2-1
NFLEVG=NFLEVL
NFLSUR=NFLEVL
PRINT*,'number of vertical levels: ',NFLEVL

! get pv, VBH, VAH , VP00, VC, VDELB
CALL GRIB_GET_SIZE(IGRIB,'pv',NB_PV)
PRINT*,'nb_pv=',NB_PV
ALLOCATE(PV(NB_PV))
CALL GRIB_GET(IGRIB,'pv',PV)
ALLOCATE(YRVAB%VAH(0:NFLEVL)); ALLOCATE(YRVAB%VBH(0:NFLEVL))
ALLOCATE(YRVAB%VC(1:NFLEVL)); ALLOCATE(YRVAB%VDELB(1:NFLEVL))
VP00 = 101325._JPRB
YRVAB%VAH(0:NFLEVL) =  PV(1:NFLEVL+1)
YRVAB%VBH(0:NFLEVL) =  PV(NFLEVL+2:2*(NFLEVL+1))
DO JLEV=1,NFLEVL
  YRVAB%VC(JLEV)=YRVAB%VAH(JLEV)*YRVAB%VBH(JLEV-1)-YRVAB%VAH(JLEV-1)*YRVAB%VBH(JLEV)
  YRVAB%VDELB(JLEV)=YRVAB%VBH(JLEV)-YRVAB%VBH(JLEV-1)
ENDDO

! get info from input grib
CALL GRIB_GET(IGRIB,'dataDate',DATE)
CALL GRIB_GET(IGRIB,'dataDate',TIME)
CALL GRIB_GET(IGRIB,'experimentVersionNumber',EXPVER)
CALL GRIB_GET(IGRIB,'editionNumber',IGRIB_EDITION)

!Call to SUSTA to compute Stand. Atm. Press. and Temp. 
LECMWF=.TRUE.
RT00_DYN=288.15_JPRB  ! T0
RPLRG=1._JPRB
TOPPRES=0.1_JPRB
WRITE(NULOUT,*) '---- Set up some structures used in susta -------'
CALL SUINTDYN
CALL SUSTA(YRGEOMETRY)
COUT_STAND_ATMOS='STANDARD_ATMOSPHERE.dat'
OPEN(7,FILE=COUT_STAND_ATMOS,ACTION='WRITE',STATUS='UNKNOWN',FORM='FORMATTED')
PRINT*,'Opening output file fro Stand. Atmos.: ',COUT_STAND_ATMOS
DO JN=1,NFLEVL
  WRITE(7,'(F10.2,2X,F10.2)') YRSTA%STPREH(JN),YRSTA%STTEM(JN)
ENDDO
CLOSE(7)


CALL GRIB_GET(IGRIB,'pentagonalResolutionParameterJ',NSMAX)
NSPEC2=(NSMAX+1)*(NSMAX+2)
PRINT*,'NSPEC2: ',NSPEC2
ALLOCATE(YRLAP%NASM0(0:NSMAX))
ALLOCATE(YRLAP%NVALUE (NSPEC2))
ALLOCATE(YRLAP%RLAPDI(-1:NSMAX+2))
ALLOCATE(YRLAP%RLAPIN(-1:NSMAX+2))

!Set up of 1 processor geometry
ALLOCATE (YRMP%NBSETLEV(NFLEVL))
YRMP%NBSETLEV(:)=1
NSPEC2V=NSPEC2
NSPEC2VF=NSPEC2

! Decide gridpoint resolution

IF (NDGL == 0) THEN
  CALL SETNDGL
ELSE
  CALL CHECK_NDGL
ENDIF

PRINT *, 'Number of meridional points: ',NDGL

NDLON=2*NDGL
ALLOCATE(NLOEN(NDGL))

IF(NTYPE == 0) THEN
  NLOEN(:) = 2*NDGL
ELSEIF(NQ == 1.AND.NTYPE == 1) THEN
! cubic grid
  ITABLE = INDEX(CRTABLE,' ')
  IF(NSMAX < 1000) THEN
    WRITE(CRTABLE(ITABLE:ITABLE+11),'(A,I3.3)') '/rtable_3',NSMAX
  ELSE
    WRITE(CRTABLE(ITABLE:ITABLE+12),'(A,I4.4)') '/rtable_3',NSMAX
  ENDIF
ELSEIF(NQ == 2.AND.NTYPE == 1) THEN
! cubic grid + Collignon
  ITABLE = INDEX(CRTABLE,' ')
  IF(NSMAX < 1000) THEN
    WRITE(CRTABLE(ITABLE:ITABLE+11),'(A,I3.3)') '/rtable_4',NSMAX
  ELSE
    WRITE(CRTABLE(ITABLE:ITABLE+12),'(A,I4.4)') '/rtable_4',NSMAX
  ENDIF
ELSEIF(NLIN == 0.AND.NTYPE == 1) THEN
! quadratic grid
  ITABLE = INDEX(CRTABLE,' ')
  IF(NSMAX < 1000) THEN
    WRITE(CRTABLE(ITABLE:ITABLE+11),'(A,I3.3)') '/rtable_2',NSMAX
  ELSE
    WRITE(CRTABLE(ITABLE:ITABLE+12),'(A,I4.4)') '/rtable_2',NSMAX
  ENDIF
ELSEIF(NLIN == 1.AND.NTYPE == 1) THEN
  ITABLE = INDEX(CRTABLE,' ')
  IF(NSMAX < 1000) THEN
    WRITE(CRTABLE(ITABLE:ITABLE+12),'(A,I3.3)') '/rtablel_2',NSMAX
  ELSE
    WRITE(CRTABLE(ITABLE:ITABLE+13),'(A,I4.4)') '/rtablel_2',NSMAX
  ENDIF
ENDIF
IF(NTYPE == 1) THEN
  IF(MYPROC == 1) THEN
    PRINT *,' TABLE USED FOR REDUCED GRID:'
    PRINT *,CRTABLE
  ENDIF
  OPEN(15,FILE=CRTABLE,FORM='FORMATTED',ACTION='READ')
  READ(15,NAMRGRI)
  NLOEN(:) = NRGRI(1:NDGL)
  CLOSE(15)
ENDIF

! Prepare for transforms, use FFTW to accommodate cubic octahedral grids
ALLOCATE(RMU(NDGL))
CALL SETUP_TRANS0(KOUT=NOUT,KERR=0,KPRINTLEV=0,KMAX_RESOL=1,&
&                 KPRGPNS=NPROC,KPRGPEW=1,KPRTRW=NPROC,LDMPOFF=LSCAL)
CALL SETUP_TRANS(KRESOL=NRESOL,KSMAX=NSMAX,KDGL=NDGL,KLOEN=NLOEN,LDSPLIT=.FALSE.,&
&                LDUSEFFTW=.TRUE.)
CALL TRANS_INQ(KRESOL=NRESOL,KSPEC2=NSPEC2,KSPEC2G=NSPEC2,KGPTOT=NGPTOT,KGPTOTG=NGPTOT,KNUMP=NUMP)
ALLOCATE(YRLAP%MYMS(NUMP))
CALL TRANS_INQ(PMU=RMU,KASM0=YRLAP%NASM0,KMYMS=YRLAP%MYMS)

!C DEFINE GEMU, GSQM2 and RCORI for later use in BALANCE OPERATORS C!
ALLOCATE(YRGEOMETRY%YRGSGEOM(NGPTOT))
ALLOCATE(YRGSGEOM_NB%GEMU (NGPTOT))
ALLOCATE(YRGSGEOM_NB%GSQM2(NGPTOT))
ALLOCATE(YRGSGEOM_NB%RCORI(NGPTOT))
DO JLAT = 1,NDGL   
  ZGEMU = RMU(JLAT)
  IF(JLAT .EQ. 1) ISTART = 0
  DO JLON = 1, NLOEN(JLAT)
    YRGSGEOM_NB%GEMU(ISTART + JLON) = ZGEMU 
    YRGSGEOM_NB%GSQM2(ISTART + JLON) = SQRT(1._JPRB - ZGEMU*ZGEMU)
    YRGSGEOM_NB%RCORI(ISTART + JLON) = 2.0_JPRB*ROMEGA*ZGEMU
  ENDDO
  ISTART = ISTART + NLOEN(JLAT)
ENDDO
DO IBL=1,NGPTOT
  YRGEOMETRY%YRGSGEOM(IBL)%GEMU   => YRGSGEOM_NB%GEMU     (IBL:IBL)
  YRGEOMETRY%YRGSGEOM(IBL)%GSQM2  => YRGSGEOM_NB%GSQM2    (IBL:IBL)
  YRGEOMETRY%YRGSGEOM(IBL)%RCORI  => YRGSGEOM_NB%RCORI    (IBL:IBL)
ENDDO

PRINT*,'NGPTOT: ',NGPTOT
PRINT*,'NUMP: ',NUMP
PRINT*,'MYMS: ',YRLAP%MYMS

PRINT*,'NGRBVO, NGRBD, NGRBT: ',NGRBVO, NGRBD, NGRBT

!Initialize arrays used in the Legendre transforms.
IC=1
DO JMLOC=1,NUMP
  IM=YRLAP%MYMS(JMLOC)
  DO JN=IM,NSMAX
    YRLAP%NVALUE(IC  )=JN
    YRLAP%NVALUE(IC+1)=JN
    IC=IC+2
  ENDDO
ENDDO

!Initialize Laplacian operator and its inverse.
DO JN=1,NSMAX+2
  YRLAP%RLAPDI(JN)=REAL(-REAL(JN*(JN+1),JPKD)/(REAL(RA,JPKD)*REAL(RA,JPKD)),JPKS)
  YRLAP%RLAPIN(JN)=REAL(-(REAL(RA,JPKD)*REAL(RA,JPKD))/REAL(JN*(JN+1),JPKD),JPKS)
ENDDO
YRLAP%RLAPDI(0)=0._JPRB; YRLAP%RLAPIN(0)=0._JPRB
YRLAP%RLAPDI(-1)=0.0_JPRB; YRLAP%RLAPIN(-1)=0.0_JPRB

!*    Initialize Jb balance relations
ALLOCATE(JB_STRUCT)
JB_STRUCT%CONFIG%N_SPJB_VARS = 5 
ALLOCATE (JB_STRUCT%SPJB_VARS_INFO(JB_STRUCT%CONFIG%N_SPJB_VARS))
ALLOCATE(JB_STRUCT%JB_DATA%SDIV(NFLEVG,NFLEVG,0:NSMAX))
ALLOCATE(JB_STRUCT%JB_DATA%STPS(NFLEVG+1,2*NFLEVG,0:NSMAX))
ALLOCATE(JB_STRUCT%JB_DATA%SO3(NFLEVG,NFLEVG,0:NSMAX))
ALLOCATE(JB_STRUCT%JB_DATA%BFACT1(NSPEC2))
ALLOCATE(JB_STRUCT%JB_DATA%BFACT2(NSPEC2))

PRINT*,'NSPEC2: ',NSPEC2
CALL SUJBBAL(YRGEOMETRY,'STABAL96  ',JB_STRUCT)


!* END of INITIALIZATIONS *!


!       Allocate memory to store the vectors

!!INFCDIFFS = N_BGMEMBERS-1
INFCDIFFS = IN_ENS
NS3D = 3 !  VO,D,T
NS2D = 1 !  LNSP   
PRINT*,'NS3D= ',NS3D,' NS2D= ',NS2D
IIGRIB3D(1:NS3D)=(/NGRBVO,NGRBD,NGRBT/)
IIGRIB2D(1:NS2D)=(/NGRBLNSP/)

NPROMA = 1

ALLOCATE(ZSPA3(NFLEVL,NSPEC2,NS3D))
ALLOCATE(ZSPA2(NSPEC2,NS2D))

ALLOCATE (ZSP3MEM_EPSILON(NFLEVL,NSPEC2,NS3D,INFCDIFFS))
ALLOCATE (ZSP2MEM_EPSILON(NSPEC2,NS2D,INFCDIFFS))

ALLOCATE (ZSP3MEAN(NFLEVL,NSPEC2,NS3D))
ALLOCATE (ZSP2MEAN(NSPEC2,NS2D))

IGPBLKS=(NGPTOT-1)/NPROMA+1

ALLOCATE(ZSP2MEMR_EPSILON(NS2D,NSPEC2))

ALLOCATE(ZGP3MEM_EPSILON(NPROMA,NFLEVL,NS3D,IGPBLKS))
ALLOCATE(ZGP2MEM_EPSILON(NPROMA,NS2D,IGPBLKS))

ALLOCATE(ZGP3VAR_EPSILON(NPROMA,NFLEVL,NS3D,IGPBLKS))
ALLOCATE(ZGP2VAR_EPSILON(NPROMA,NS2D,IGPBLKS))

ALLOCATE(ZSP3VAR_EPSILON(NFLEVL,NSPEC2,NS3D))
ALLOCATE(ZSP2VAR_EPSILON(NS2D,NSPEC2))

IPTJBVO = HUGE(IPTJBVO)
IPTJBT  = HUGE(IPTJBT)

PRINT*,'N_SPJB_VARS = ',JB_STRUCT%CONFIG%N_SPJB_VARS
DO JFIELD=1,JB_STRUCT%CONFIG%N_SPJB_VARS
  IF (JB_STRUCT%SPJB_VARS_INFO(JFIELD)%IGRIBCODE==NGRBVO) THEN
    IPTJBVO = JB_STRUCT%SPJB_VARS_INFO(JFIELD)%IPTJB
  ELSEIF (JB_STRUCT%SPJB_VARS_INFO(JFIELD)%IGRIBCODE==NGRBT) THEN
    IPTJBT  = JB_STRUCT%SPJB_VARS_INFO(JFIELD)%IPTJB
  ENDIF
ENDDO

!       Calculate the background perturbations

WRITE (NULOUT,*) 'Calculating background differences and the mean background difference'

ZSP3MEM_EPSILON(:,:,:,:) = 0.0_JPRB
ZSP2MEM_EPSILON(:,:,:) = 0.0_JPRB

!JB_STRUCT%JB_DATA%SPJB = 0.0_JPRB

ZSP3MEAN(:,:,:) = 0.0_JPRB
ZSP2MEAN(:,:) = 0.0_JPRB

JDATE=1

ALLOCATE(IBSETLEV(NFLEVL))
IBSETLEV(:)=1

CALL INI_IOSTREAM(KULOUT=NULOUT,KBSETLEV=IBSETLEV,KBSETSP=1,KFLEVG=NFLEVL,KSMAX=NSMAX)

DO JMEMBER=1,IN_ENS

        !   read a background state

  CLFILE = JB_STRUCT%WJBCONF%CINBGSTATES
  CLFILE = AFILEIN     
  ILENGTH = INDEX(CLFILE,' ') - 1 
  WRITE (*,*) CLFILE
  WRITE (CLFILE(ILENGTH+1:ILENGTH+4),'(''_'',I3.3)') JMEMBER
 
  WRITE (NULOUT,*) 'reading member ',JMEMBER,' from file ',CLFILE
  WRITE (*,*) 'reading member ',JMEMBER,' from file ',CLFILE
  
  CALL READ_ENS(CLFILE,ZSPA3,ZSPA2,NS3D,NS2D,IIGRIB3D,IIGRIB2D)
  
        !   save current background state
        !   calculate ensemble mean

  ZSP3MEM_EPSILON(:,:,:,JMEMBER) = ZSPA3(:,:,:)
  ZSP2MEM_EPSILON(:,:,JMEMBER) = ZSPA2(:,:)
  ZSP3MEAN(:,:,:) = ZSP3MEAN(:,:,:) + ZSP3MEM_EPSILON(:,:,:,JMEMBER)/REAL(IN_ENS)
  ZSP2MEAN(:,:) = ZSP2MEAN(:,:) + ZSP2MEM_EPSILON(:,:,JMEMBER)/REAL(IN_ENS)

ENDDO

IF (LBALANCE) THEN
 !   Apply the TL balance operator
   JB_STRUCT%CONFIG%LJB_UNIVARIATE=.FALSE.
   JB_STRUCT%CONFIG%LJB_OMEGA_BALANCE=.TRUE.
   JB_STRUCT%CONFIG%LJB_NONLINEAR_BALANCE=.TRUE.
ENDIF

ZSP2MEMR_EPSILON=0.0_JPRB
ZGP3MEM_EPSILON=0.0_JPRB
ZGP2MEM_EPSILON=0.0_JPRB
ZGP3VAR_EPSILON=0.0_JPRB
ZGP2VAR_EPSILON=0.0_JPRB

DO J=1,IN_ENS
  IFL = J
  ! Calculate differences to the mean
  ZSPA3(:,:,:) = ZSP3MEM_EPSILON(:,:,:,IFL) - ZSP3MEAN(:,:,:)
  ZSPA2(:,:)   = ZSP2MEM_EPSILON(:,:,IFL) - ZSP2MEAN(:,:)

  IF (.NOT.JB_STRUCT%CONFIG%LJB_UNIVARIATE) THEN

    IF (JB_STRUCT%CONFIG%LJB_OMEGA_BALANCE .OR. JB_STRUCT%CONFIG%LJB_NONLINEAR_BALANCE) THEN

      ALLOCATE (ZDIV(NFLEVL,NSPEC2))
      ALLOCATE(ZGP7(NPROMA, 9*NFLEVG, (NGPTOT+NPROMA-1)/NPROMA))
      ZDIV(:,:) = 0.0_JPRB
      CALL INV_TRANS (PSPVOR=ZSP3MEAN(:,:,1), PSPDIV=ZDIV, &
                    & PSPSCALAR=ZSP3MEAN(:,:,3), &
                    & LDUVDER=.TRUE., LDSCDERS=.TRUE., LDVORGP=.TRUE., LDDIVGP=.TRUE.,&
                    & KRESOL=NRESOL, KPROMA=NPROMA, KVSETUV=YRMP%NBSETLEV, KVSETSC=YRMP%NBSETLEV, PGP=ZGP7)
      IOFF_VOR  = 0
      IOFF_DIV  = NFLEVG
      IOFF_U    = 2*NFLEVG
      IOFF_V    = 3*NFLEVG

      IOFF_NS_T = 5*NFLEVG
      IOFF_EW_U = 6*NFLEVG
      IOFF_EW_V = 7*NFLEVG
      IOFF_EW_T = 8*NFLEVG
    ENDIF

    IF (JB_STRUCT%CONFIG%LJB_OMEGA_BALANCE) THEN
      PRINT*,'LJB_OMEGA_BALANCE'

      CALL BALOMEGATL(YRGEOMETRY,ZSPA3(:,:,1),ZSPA3(:,:,3),ZDIV,ZGP7, &
                    & IOFF_VOR, IOFF_DIV, IOFF_U, IOFF_V, IOFF_NS_T, &
                    & IOFF_EW_U, IOFF_EW_V, IOFF_EW_T)

      ZSPA3(:,:,2) = ZSPA3(:,:,2) - ZDIV(:,:)
    ENDIF

    ALLOCATE (ZZP(NFLEVG,NSPEC2))
    IF (JB_STRUCT%CONFIG%LJB_NONLINEAR_BALANCE) THEN
      PRINT*,'LJB_NONLINEAR_BALANCE'

      CALL BALNONLINTL(YRGEOMETRY,ZSPA3(:,:,1),ZZP,ZGP7, &
                     & IOFF_VOR, IOFF_DIV, IOFF_U, IOFF_V, IOFF_EW_U, IOFF_EW_V)
    ELSE
      ! First Compute Analytical linear VOR-P Covariances
      CALL ANALVORP(NSMAX,NSPEC2,YRLAP%NASM0,JB_STRUCT%JB_DATA%BFACT1,JB_STRUCT%JB_DATA%BFACT2)
      PRINT*,'BALSTAT '
      CALL BALSTAT (YRGEOMETRY,ZSPA3(:,:,1),ZSPA3(:,:,2), &
                   & ZZP,JB_STRUCT%JB_DATA%BFACT1,JB_STRUCT%JB_DATA%BFACT2)
    ENDIF

    PRINT*,'BALVERTI '
    CALL BALVERTI_LOC (YRGEOMETRY,YRDIMF,ZZP,ZSPA3,ZSPA2)
 
    DEALLOCATE (ZZP)
    IF (JB_STRUCT%CONFIG%LJB_NONLINEAR_BALANCE .OR. JB_STRUCT%CONFIG%LJB_OMEGA_BALANCE) THEN
      DEALLOCATE(ZDIV)
      DEALLOCATE(ZGP7)
    ENDIF
  ENDIF

  ! Transform bkg members from spectral to gridpoint space
  DO j1=1,NS2D
    DO j2=1,NSPEC2
      ZSP2MEMR_EPSILON(J1,J2)=ZSPA2(J2,J1)
    ENDDO
  ENDDO
  PRINT*,'Before inv_trans'
  CALL INV_TRANS(PSPSC3A=ZSPA3(:,:,:),PSPSC2=ZSP2MEMR_epsilon(:,:),&
      & KPROMA=NPROMA,PGP3A=ZGP3MEM_epsilon(:,:,:,:),&
      & PGP2=ZGP2MEM_epsilon(:,:,:))
  PRINT*,'Finished inv_trans',ifl
  ! Calculate gridpoint variances
  ZGP3VAR_EPSILON(:,:,:,:)= ZGP3VAR_EPSILON(:,:,:,:)&
                         & +ZGP3MEM_EPSILON(:,:,:,:)*ZGP3MEM_EPSILON(:,:,:,:)
  ZGP2VAR_EPSILON(:,:,:)= ZGP2VAR_EPSILON(:,:,:)&
                       & +ZGP2MEM_EPSILON(:,:,:)*ZGP2MEM_EPSILON(:,:,:)
 PRINT*,'DONE MEMBER: ',ifl
ENDDO

DEALLOCATE (ZSP3MEAN)
DEALLOCATE (ZSP2MEAN)
DEALLOCATE (ZSP3MEM_EPSILON)
DEALLOCATE (ZSP2MEM_EPSILON)
DEALLOCATE (ZSP2MEMR_EPSILON)
DEALLOCATE (ZGP3MEM_EPSILON)
DEALLOCATE (ZGP2MEM_EPSILON)

ZGP3VAR_EPSILON(:,:,:,:)=ZGP3VAR_EPSILON(:,:,:,:)/REAL(IN_ENS-1,JPRB)
ZGP2VAR_EPSILON(:,:,:)=ZGP2VAR_EPSILON(:,:,:)/REAL(IN_ENS-1,JPRB)

 PRINT*,'Finished var calc'

! Write out the VAriances/Standard Deviations in control space (VO-Du-Tu-LNSPu)

CALL GRIB_OPEN_FILE(IFILE,AFILEIN1,'R',IRET)
CALL GRIB_NEW_FROM_FILE(IFILE,IGRIB,IRET)
CALL GRIB_OPEN_FILE(IFILE_OUT,AFILEOUT,'W',IRET)
PRINT*,'Output Standard Deviations FILE: ', AFILEOUT

IF (IGRIB_EDITION .EQ. 2) THEN
  CALL GRIB_NEW_FROM_SAMPLES(IGRIB_SAMPLE, "reduced_gg_ml_grib2")
ELSE
  CALL GRIB_NEW_FROM_SAMPLES(IGRIB_SAMPLE, "reduced_gg_ml_grib1")
ENDIF
DO IPAR=1,NS3D
  PRINT*,'Grib coding of ipar: ',IPAR
  DO ILEVEL=1,NFLEVL
    CALL GRIB_UTIL_SECTIONS_COPY(IGRIB,IGRIB_SAMPLE,&
         & GRIB_SECTION_PRODUCT+GRIB_SECTION_LOCAL,IGRIB_OUT,IRET)
    IF(IRET /= GRIB_SUCCESS) THEN
        WRITE(NERR,*)' ERROR GRIB_UTIL_SECTIONS_COPY ',IRET
        CALL ABOR1('UNBAL_EDA:ERROR GRIB_UTIL_SECTIIONS_COPY')
    ENDIF
    CALL GRIB_SET(IGRIB_OUT,'Nj',NDGL)
    CALL GRIB_SET(IGRIB_OUT,'N', NDGL/2)
    CALL GRIB_SET(IGRIB_OUT,'pl',NLOEN(1:NDGL))
    WRITE (NULOUT,*) 'Nj= ', NDGL, ' SUM(NLOEN(1:NDGL)) = ', SUM(NLOEN(1:NDGL))
    CALL GRIB_SET(IGRIB_OUT,'latitudeOfFirstGridPointInDegrees', &
                    & INT(180._JPRB/RPI*1000._JPRB*ASIN(RMU(1)))/1000._JPRB)
    CALL GRIB_SET(IGRIB_OUT,'latitudeOfLastGridPointInDegrees', &
                    & INT(180._JPRB/RPI*1000._JPRB*ASIN(RMU(NDGL)))/1000._JPRB)
    CALL GRIB_SET(IGRIB_OUT,'longitudeOfLastGridPointInDegrees', &
                    & INT((360.0_JPRB*1000*(NDLON-1))/(NDLON))/1000._JPRB)
    CALL GRIB_SET(IGRIB_OUT,'longitudeOfFirstGridPointInDegrees', 0.0_JPRB)
    CALL GRIB_SET(IGRIB_OUT,'level',ILEVEL)
  ! Codify correct marsType for MARS Archiving !
    CALL GRIB_SET(IGRIB_OUT,"dataType",18)
    IF ( IPAR .EQ. 1) THEN
      CALL GRIB_SET(IGRIB_OUT,"param",138)
    ELSEIF ( IPAR .EQ. 2) THEN
      IF (LBALANCE) THEN
        CALL GRIB_SET(IGRIB_OUT,"param",23)
      ELSE
        CALL GRIB_SET(IGRIB_OUT,"param",155)
      ENDIF
    ELSEIF ( IPAR .EQ. 3) THEN
      IF (LBALANCE) THEN
        CALL GRIB_SET(IGRIB_OUT,"param",21)
      ELSE
        CALL GRIB_SET(IGRIB_OUT,"param",130)
      ENDIF
    ENDIF
    CALL GRIB_SET(IGRIB_OUT,"decimalScaleFactor", 0,  IRET)  !! as from grib_api 1.9.14
    IF(AVAR .EQ. 'VAR') THEN
      CALL GRIB_SET(IGRIB_OUT,'values',ZGP3VAR_EPSILON(1,ILEVEL,IPAR,:))
    ELSE ! StDev!
      WRITE (NULOUT,*) 'SIZE(ZGP3VAR_epsilon(1,ilevel,ipar,:))', SIZE(ZGP3VAR_EPSILON(1,ILEVEL,IPAR,:))
      WRITE (NULOUT,*) 'MAX/MIN ZGP3VAR_epsilon', MAXVAL(ZGP3VAR_EPSILON(1,ILEVEL,IPAR,:)),&
 &  MINVAL(ZGP3VAR_EPSILON(1,ILEVEL,IPAR,:))
      CALL GRIB_SET(IGRIB_OUT,'values',SQRT(ZGP3VAR_EPSILON(1,ILEVEL,IPAR,:)))
    ENDIF
    CALL GRIB_WRITE(IGRIB_OUT,IFILE_OUT)
    CALL GRIB_RELEASE(IGRIB_OUT)
  ENDDO ! model levels !
ENDDO ! 3D control variables !

DO IPAR=1,NS2D
  ILEVEL=1
  CALL GRIB_UTIL_SECTIONS_COPY(IGRIB,IGRIB_SAMPLE,&
       & GRIB_SECTION_PRODUCT+GRIB_SECTION_LOCAL,IGRIB_OUT,IRET)
  IF(IRET /= GRIB_SUCCESS) THEN
      WRITE(NERR,*)' ERROR GRIB_UTIL_SECTIONS_COPY ',IRET
      CALL ABOR1('UNBAL_EDA:ERROR GRIB_UTIL_SECTIIONS_COPY')
  ENDIF
  CALL GRIB_SET(IGRIB_OUT,'Nj',NDGL)
  CALL GRIB_SET(IGRIB_OUT,'N', NDGL/2)
  CALL GRIB_SET(IGRIB_OUT,'pl',NLOEN(1:NDGL))
  CALL GRIB_SET(IGRIB_OUT,'level',ILEVEL)
  CALL GRIB_SET(IGRIB_OUT,'latitudeOfFirstGridPointInDegrees', &
                  & INT(180._JPRB/RPI*1000._JPRB*ASIN(RMU(1)))/1000._JPRB)
  CALL GRIB_SET(IGRIB_OUT,'latitudeOfLastGridPointInDegrees', &
                  & INT(180._JPRB/RPI*1000._JPRB*ASIN(RMU(NDGL)))/1000._JPRB)
  CALL GRIB_SET(IGRIB_OUT,'longitudeOfLastGridPointInDegrees', &
                  & INT((360.0_JPRB*1000*(NDLON-1))/(NDLON))/1000._JPRB)
  CALL GRIB_SET(IGRIB_OUT,'longitudeOfFirstGridPointInDegrees', 0.0_JPRB)
  ! Codify correct marsType for MARS Archiving !
  CALL GRIB_SET(IGRIB_OUT,"dataType",18)
  IF ( IPAR .EQ. 1) THEN
    IF (LBALANCE) THEN
      CALL GRIB_SET(IGRIB_OUT,"param",22)
    ELSE
      CALL GRIB_SET(IGRIB_OUT,"param",152)
    ENDIF
  ENDIF
  !!CALL grib_set(igrib_out,"bitsPerValue",16)
  CALL GRIB_SET(IGRIB_OUT,"decimalPrecision",10)   !! WORKAROUND for grib_set(igrib_out,"bitsPerValue",16) problem
  IF(AVAR .EQ. 'VAR') THEN
    CALL GRIB_SET(IGRIB_OUT,'values',ZGP2VAR_EPSILON(1,IPAR,:))
  ELSE ! StDev!
    CALL GRIB_SET(IGRIB_OUT,'values',SQRT(ZGP2VAR_EPSILON(1,IPAR,:)))
  ENDIF
  CALL GRIB_WRITE(IGRIB_OUT,IFILE_OUT)
  CALL GRIB_RELEASE(IGRIB_OUT)
ENDDO ! 2D control variables !

CALL GRIB_CLOSE_FILE(IFILE)
CALL GRIB_CLOSE_FILE(IFILE_OUT)

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('UNBAL_EDA',1,ZHOOK_HANDLE)
CALL MPI_FINALIZE (IER)
IF (IER /= 0) CALL ABOR1 ('MPI_FINALIZE FAILED IN UNBAL_EDA')

STOP

!-------------------------------------------------------------------!

CONTAINS


!     ------------------------------------------------------------------

SUBROUTINE SETNDGL

! Decide number of Gaussian latitudes given spectral truncation
! Only certain combinations of truncation/linear grid
! or quadratic grid are supported

ASSOCIATE(NSMAX=>YRGEOMETRY%YRDIM%NSMAX)
IF(NLIN == 0 .AND. (NQ == 1.OR.NQ == 2)) THEN
  IF(NSMAX == 79) THEN
    NDGL = 160
  ELSEIF(NSMAX == 95) THEN
    NDGL = 192
  ELSEIF(NSMAX == 127) THEN
    NDGL = 256
  ELSEIF(NSMAX == 159) THEN
    NDGL = 320
  ELSEIF(NSMAX == 199) THEN
    NDGL = 400
  ELSEIF(NSMAX == 255) THEN
    NDGL = 512
  ELSEIF(NSMAX == 319) THEN
    NDGL = 640
  ELSEIF(NSMAX == 399) THEN
    NDGL = 800
  ELSEIF(NSMAX == 511) THEN
    NDGL = 1024
  ELSEIF(NSMAX == 639) THEN
    NDGL = 1280
  ELSEIF(NSMAX == 799) THEN
    NDGL = 1600
  ELSEIF(NSMAX == 1023) THEN
    NDGL = 2048
  ELSEIF(NSMAX == 1279) THEN
    NDGL = 2560
  ELSEIF(NSMAX == 1599) THEN
    NDGL = 3200
  ELSEIF(NSMAX == 1999) THEN
    NDGL = 4000
  ELSEIF(NSMAX == 3999) THEN
    NDGL = 8000
  ELSEIF(NSMAX == 7999) THEN
    NDGL = 16000
  ELSE
    WRITE(NERR,*)' WRONG SPECTRAL RESOLUTION ',NSMAX,' CUBIC GRID'
    CALL ABOR1('SPTOGP:UNSUPPORTED SPECTRAL RESOLUTION - CUBIC GRID ')
  ENDIF
ELSEIF (NLIN == 0) THEN
  IF(NSMAX == 21) THEN
    NDGL = 32
  ELSEIF(NSMAX == 42) THEN
    NDGL = 64
  ELSEIF(NSMAX == 63) THEN
    NDGL = 96
  ELSEIF(NSMAX == 106) THEN
    NDGL = 160
  ELSEIF(NSMAX == 213) THEN
    NDGL = 320
  ELSEIF(NSMAX == 341) THEN
    NDGL = 512
  ELSEIF(NSMAX == 426) THEN
    NDGL = 640
  ELSEIF(NSMAX == 533) THEN
    NDGL = 800
  ELSEIF(NSMAX == 682) THEN
    NDGL = 1024
  ELSEIF(NSMAX == 853) THEN
    NDGL = 1280
  ELSEIF(NSMAX == 1364) THEN
    NDGL = 2048
  ELSEIF(NSMAX == 1706) THEN
    NDGL = 2560
  ELSE
    WRITE(NERR,*)' WRONG SPECTRAL RESOLUTION ',NSMAX,' QUAD. GRID'
    CALL ABOR1('SPTOGP:UNSUPPORTED SPECTRAL RESOLUTION - QUAD. GRID ')
  ENDIF
ELSEIF(NLIN == 1) THEN
  IF(NSMAX == 63) THEN
    NDGL = 64
  ELSEIF(NSMAX == 95) THEN
    NDGL = 96
  ELSEIF(NSMAX == 127) THEN
    NDGL = 128
  ELSEIF(NSMAX == 159) THEN
    NDGL = 160
  ELSEIF(NSMAX == 191) THEN
    NDGL = 192
  ELSEIF(NSMAX == 199) THEN
    NDGL = 200
  ELSEIF(NSMAX == 255) THEN
    NDGL = 256
  ELSEIF(NSMAX == 319) THEN
    NDGL = 320
  ELSEIF(NSMAX == 399) THEN
    NDGL = 400
  ELSEIF(NSMAX == 511) THEN
    NDGL = 512
  ELSEIF(NSMAX == 639) THEN
    NDGL = 640
  ELSEIF(NSMAX == 799) THEN
    NDGL = 800
  ELSEIF(NSMAX == 1023) THEN
    NDGL = 1024
  ELSEIF(NSMAX == 1279) THEN
    NDGL = 1280
  ELSEIF(NSMAX == 1599) THEN
    NDGL = 1600
  ELSEIF(NSMAX == 2047) THEN
    NDGL = 2048
  ELSEIF(NSMAX == 2559) THEN
    NDGL = 2560
  ELSEIF(NSMAX == 3999) THEN
    NDGL = 4000
  ELSEIF(NSMAX == 7999) THEN
    NDGL = 8000
  ELSE
    WRITE(NERR,*)' WRONG SPECTRAL RESOLUTION ',NSMAX,' LIN. GRID'
    CALL ABOR1('SPTOGP:UNSUPPORTED SPECTRAL RESOLUTION - LIN. GRID')
  ENDIF
ELSE
  WRITE(NERR,*)' WRONG NLIN=',NLIN
  CALL ABOR1('SPTOGP:WRONG NLIN')
ENDIF
END ASSOCIATE

END SUBROUTINE SETNDGL


!     ------------------------------------------------------------------

SUBROUTINE CHECK_NDGL

! Decide number of Gaussian latitudes given spectral truncation
! Only certain combinations of truncation/linear grid
! or quadratic grid are supported

ASSOCIATE(NSMAX=>YRGEOMETRY%YRDIM%NSMAX)
IF(NLIN == 0) THEN
  IF(NDGL .NE.  32 .AND. NDGL .NE.  64 .AND. NDGL .NE.  96 .AND.&
     &NDGL .NE. 160 .AND. NDGL .NE. 320 .AND. NDGL .NE. 512 .AND.&
     &NDGL .NE. 640 .AND. NDGL .NE. 800 .AND. NDGL .NE. 1024 .AND. NDGL .NE. 1280 ) THEN
    WRITE(NERR,*)' WRONG SPECTRAL RESOLUTION ',NSMAX,' QUAD. GRID'
!    CALL ABOR1('SPTOGP:UNSUPPORTED SPECTRAL RESOLUTION - QUAD. GRID ')
  ENDIF
ELSEIF(NLIN == 1) THEN
  IF(NDGL .NE. 32 .AND. NDGL .NE.  64 .AND. NDGL .NE.  96 .AND. NDGL .NE. 128 .AND.&
     &NDGL .NE. 160.AND. NDGL .NE. 256 .AND. NDGL .NE. 320 .AND. NDGL .NE. 400 .AND.&
     &NDGL .NE. 512.AND. NDGL .NE. 640 .AND. NDGL .NE. 800 .AND. NDGL .NE. 1024) THEN
    WRITE(NERR,*)' WRONG SPECTRAL RESOLUTION ',NSMAX,' LIN. GRID'
!    CALL ABOR1('SPTOGP:UNSUPPORTED SPECTRAL RESOLUTION - LIN. GRID')
  ENDIF
ELSE
  WRITE(NERR,*)' WRONG NLIN=',NLIN
!  CALL ABOR1('SPTOGP:WRONG NLIN')
ENDIF
END ASSOCIATE

END SUBROUTINE CHECK_NDGL

!     ------------------------------------------------------------------

SUBROUTINE READ_ENS(CDFILE,ZSPA3,ZSPA2,NS3D,NS2D,IIGRIB3D,IIGRIB2D)

!*** *READ_ENS*

!   Purpose.
!   --------
!      To read a GRIB-format vector into SPA3 and SPA2

!   Interface.
!   ----------

!      CALL READ_ENS (CDFILE,ZSPA3,ZSPA2,NS3D,NS2D,IIGRIB3D,IIGRIB2D)

!   Explicit Inputs:
!                     cdfile  -- name of file containing the vector

!   Externals.
!   ----------

!   Reference.
!   ----------

!   Author.
!   -------
!       *ECMWF*

!   Modifications.
!   --------------

!-----------------------------------------------------------------------

USE PARKIND1 , ONLY : JPIM, JPRB
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK
USE YOM_GRIB_CODES  , ONLY : NGRBVO, NGRBD, NGRBT, NGRBQ, NGRBO3, NGRBLNSP, NGRBBLH  
USE IOSTREAM_MIX , ONLY : INI_IOSTREAM, SETUP_IOSTREAM, SETUP_IOREQUEST, IO_GET, IO_INQUIRE,&
 & CLOSE_IOSTREAM, TYPE_IOSTREAM , TYPE_IOREQUEST, CLOSE_IOREQUEST

IMPLICIT NONE

CHARACTER(LEN=*)           ,INTENT(IN)    :: CDFILE
INTEGER(KIND=JPIM)         ,INTENT(IN)    :: NS2D,NS3D
INTEGER(KIND=JPIM)         ,INTENT(IN)    :: IIGRIB3D(100), IIGRIB2D(100)
REAL(KIND=JPRB)            ,INTENT(INOUT) :: ZSPA3(YRGEOMETRY%YRDIMV%NFLEVL,YRGEOMETRY%YRDIM%NSPEC2,&
 & YRDIMF%NS3D),&
 & ZSPA2(YRGEOMETRY%YRDIM%NSPEC2,YRDIMF%NS2D)

TYPE(TYPE_IOSTREAM)  :: YL_IOSTREAM
TYPE(TYPE_IOREQUEST) :: YL_IOREQUEST
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('READ_ENS',0,ZHOOK_HANDLE)
ASSOCIATE(YRDIM=>YRGEOMETRY%YRDIM,YRDIMV=>YRGEOMETRY%YRDIMV,YRGEM=>YRGEOMETRY%YRGEM, YRMP=>YRGEOMETRY%YRMP)
ASSOCIATE(NPROMA=>YRDIM%NPROMA, NSMAX=>YRDIM%NSMAX, NSPEC2=>YRDIM%NSPEC2, &
 & NFLEVL=>YRDIMV%NFLEVL, &
 & NGPTOT=>YRGEM%NGPTOT)

PRINT*,'NGRBLNSP = ',NGRBLNSP
PRINT*,'NGRBVO,NGRBD,NGRBT = ',NGRBVO,NGRBD,NGRBT
PRINT*,'NFLEVL,NSPEC2,NSMAX = ',NFLEVL,NSPEC2,NSMAX
PRINT*,'NGPTOT = ',NGPTOT
PRINT*,'NS3D,NS2D = ',NS3D,NS2D

PRINT*,IIGRIB3D(1:NS3D), IIGRIB2D(1:NS2D)

!--- processor 1 does the IO
CALL SETUP_IOSTREAM(YL_IOSTREAM,'CIO',TRIM(CDFILE),CDMODE='r',KIOMASTER=1)
CALL SETUP_IOREQUEST(YL_IOREQUEST,'SPECTRAL_FIELDS',LDGRIB=.TRUE.,&
 & KGRIB3D=IIGRIB3D(1:NS3D),KGRIB2D=IIGRIB2D(1:NS2D),CDLEVTYPE='ML',KCHUNKSIZE=1,KPROMA=NPROMA)

CALL IO_GET(YL_IOSTREAM,YL_IOREQUEST,PR2=ZSPA2,PR3=ZSPA3)

CALL CLOSE_IOREQUEST(YL_IOREQUEST)
CALL CLOSE_IOSTREAM(YL_IOSTREAM)

!!IF (LLJB) THEN
!!  SPJB%SP3D=ZSPA3
!!  IF (NPSP==1) SPJB%SP2D=ZSPA2(:,1:I2D)
!!ENDIF

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('READ_ENS',1,ZHOOK_HANDLE)
END SUBROUTINE READ_ENS

!     ------------------------------------------------------------------

!=======================================================================
      SUBROUTINE ANALVORP(KSMAX,KSPEC2,NASM0,FACT1,FACT2)
!
!        Calculate analytic horizontal balance coefficients(fact1,fact2)
!        corresponding to linear balance :
!
!       Author : M. Fisher ECMWF Jan 2000 (based on regvorp and diavorp)
!
!    Output :
!      fact1,fact2  - horizontal balance coeffients (f1,f2)
!     ------------------------------------------------------------------
USE YOMCST, ONLY : RA, ROMEGA
!     ------------------------------------------------------------------
      INTEGER (KIND=JPIM) ,INTENT(IN) :: KSMAX, KSPEC2
      INTEGER (KIND=JPIM) ,INTENT(IN) :: NASM0(0:KSMAX)
      REAL(KIND=JPRB), INTENT(OUT) :: FACT1(KSPEC2),FACT2(KSPEC2)
!     ------------------------------------------------------------------
!     Local Variables
      INTEGER (KIND=JPIM) :: JM,JN,IRI,INM
      REAL(KIND=JPRB) :: ZCC
!
!            1. Compute (Vor,Vor) and (P,P) covariances
!
      PRINT*,' analvorp: computing (vor,vor) and (P,P) linear analytical covariances'
!
      FACT1(:)=0.
      FACT2(:)=0.
      ZCC=-2.*ROMEGA*RA**2

      MLOOP : DO JM=0,KSMAX

!       coefficient of vor(m,n-1)

        DO IRI=0,MIN(1,JM)
          DO JN=JM+1,KSMAX
            INM=NASM0(JM)+(JN-JM)*2+IRI
            FACT2(INM)=SQRT(FLOAT((JN+JM)*(JN-JM))&
     &        /FLOAT((2*JN+1)*(2*JN-1)))*(1.+1./FLOAT(JN))&
     &         *ZCC/FLOAT(JN*(JN+1))
          ENDDO

!       coefficient of vor(m,n+1)

          DO JN=MAX(JM,1),KSMAX-1
            INM=NASM0(JM)+(JN-JM)*2+IRI
            FACT1(INM)=SQRT(FLOAT((JN+1+JM)*(JN+1-JM))&
     &        /FLOAT((2*JN+3)*(2*JN+1)))*(1.-1./(FLOAT(JN)+1.))&
     &        *ZCC/FLOAT(JN*(JN+1))
          ENDDO
        ENDDO
      ENDDO MLOOP
!
      RETURN
      END  SUBROUTINE ANALVORP

!     ------------------------------------------------------------------
END PROGRAM UNBAL_EDA     

!!SUBROUTINE BALVERTI_LOC(PSPZZP,YDSPEC)
SUBROUTINE BALVERTI_LOC(YDGEOMETRY,YDDIMF,PSPZZP,ZSPA3,ZSPA2)

!      BALVERTI - Recombine balanced and unbalanced fields, inverse

!     Purpose. transform from full fields to unbal div, unbal (T,ps) and
!              unbal O3
!     --------

!     Arguments.
!     ----------
!        Input : PSPZZP(NFLEVG,NSPEC2) - balanced P values from BALSTAT

!     Externals. TRMTOS MXMAOP TRSTOM
!     ----------

!     Method. (The inversion relies on block matrix algebra)
!     -------
!       Solve statistical balance equation in spectral space
!       to convert vorticity into geopotential(P) and divergence.
!            (total = balanced + unbalanced )
!         The balance leads from correlation space :
!            (total Vor, unbal Div, unbal T/ps, unbal O3)
!         To model space :
!            (total Vor, total Div, total T/ps, total O3)
!         In 2 steps :

!       (1)     [P]tot = [A].[Vor]tot  (A=tridiag matrix for each m)
!                                      (Pt=total mass)

!       (2)  [T,ps]tot = [T,ps]unbal + [B].[P]tot + [C].[Div]unbal
!            [Div]tot  = [Div]unbal  + [D].[P]tot
!            [O3]tot   = [O3]unbal   + [E].[P]tot

!               (B,C,D,E=full vertical matrices for each n)

!        This routine solves step 2. Step 1 is solved in BALSTAT.

!     Author. Francois Bouttier *ECMWF*
!     -------

!     Modifications.
!     --------------
!        F. Bouttier   96-12-13 write original
!        E. Holm       97-10-01 include ozone balance
!        M.Hamrud      03-08-01 GFL introduction
!        M.Hamrud      01-Oct-2003 CY28 Cleaning
!        M.Hamrud      10-Jan-2004 CY28R1 Cleaning
!        M.Fisher      08-Jun-2005 Generalize Jb for GEMS
!     ------------------------------------------------------------------

USE GEOMETRY_MOD, ONLY : GEOMETRY
USE YOMDIMF     , ONLY : TDIMF 
USE PARKIND1    , ONLY : JPIM, JPRB
USE YOMHOOK     , ONLY : LHOOK, DR_HOOK
USE YOMJG       , ONLY : TYPE_JB_STRUCT
USE YOMMP0      , ONLY : MYSETN
USE YOM_GRIB_CODES     , ONLY : NGRBO3
USE YOMCVA      , ONLY : CVA_DATA
USE YOMJG       , ONLY : JB_STRUCT
USE SPECTRAL_FIELDS_MOD

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)        , INTENT(INOUT) :: YDGEOMETRY
TYPE(TDIMF)           , INTENT(IN)    :: YDDIMF
REAL(KIND=JPRB)       , INTENT(IN)    :: PSPZZP(YDGEOMETRY%YRDIMV%NFLSUR,YDGEOMETRY%YRDIM%NSPEC2) 
!!TYPE(SPECTRAL_FIELD), INTENT(INOUT) :: YDSPEC
REAL(KIND=JPRB), INTENT(INOUT) :: ZSPA3(YDGEOMETRY%YRDIMV%NFLEVL,YDGEOMETRY%YRDIM%NSPEC2,YDDIMF%NS3D)
REAL(KIND=JPRB), INTENT(INOUT) :: ZSPA2(YDGEOMETRY%YRDIM%NSPEC2,YDDIMF%NS2D)

!     ------------------------------------------------------------------

INTEGER(KIND=JPIM) :: IN, JSP

REAL(KIND=JPRB) :: ZIN(2*YDGEOMETRY%YRDIMV%NFLEVG),ZBUF(YDGEOMETRY%YRDIMV%NFLEVG)
REAL(KIND=JPRB) :: ZTPS(YDGEOMETRY%YRDIMV%NFLEVG+1),ZDIV(YDGEOMETRY%YRDIMV%NFLEVG),ZO3(YDGEOMETRY%YRDIMV%NFLEVG)
!REAL(KIND=JPRB) :: ZSZPG(YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRMP%NSPEC2V), ZSDIVG(YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRMP%NSPEC2V)
!REAL(KIND=JPRB) :: ZSPTG(YDGEOMETRY%YRDIMV%NFLEVG,YDGEOMETRY%YRMP%NSPEC2V)
!REAL(KIND=JPRB), ALLOCATABLE :: ZSO3G(:,:,:)
!REAL(KIND=JPRB) :: ZSP(YDGEOMETRY%YRDIM%NSPEC2)
!REAL(KIND=JPRB) :: ZSPSPG(YDGEOMETRY%YRMP%NSPEC2V)
!LOGICAL         :: LLSELECT3D(CVA_DATA%NVA3D)
INTEGER(KIND=JPIM) :: JFIELD

REAL(KIND=JPRB) :: ZHOOK_HANDLE

!     ------------------------------------------------------------------

!!INTERFACE
!!#include "mxmaop.h"
!!END INTERFACE

!!#include "trmtos.intfb.h"
!!#include "trstom.intfb.h"

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('BALVERTI_LOC',0,ZHOOK_HANDLE)
ASSOCIATE(YDLAP=>YDGEOMETRY%YRLAP,YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV,YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP)
ASSOCIATE(NFLEVG=>YDDIMV%NFLEVG, &
 & NSPEC2V=>YDMP%NSPEC2V)

!     ------------------------------------------------------------------

!     1.    Transpose data to vertical columns
!           ----------------------------------


!!LLSELECT3D(:)=.FALSE.
!!DO JFIELD=1,N_SPJB_VARS
!!  IF (SPJB_VARS_INFO(JFIELD)%IGRIBCODE==NGRBO3) THEN
!!    LLSELECT3D(SPJB_VARS_INFO(JFIELD)%IPTJB)=.TRUE.
!!  ENDIF
!!ENDDO

!!ALLOCATE(ZSO3G(NFLEVG,NSPEC2V,COUNT(LLSELECT3D)))
!!IF (NPSP==1) ZSP=YDSPEC%SP

!!CALL TRMTOS (PSPVOR=PSPZZP,PSPDIV=YDSPEC%DIV,PSPT=YDSPEC%T, &
!!           & PSPSEL3D=YDSPEC%SP3D,PSPSP=ZSP,&
!!           & PSPVORG=ZSZPG,PSPDIVG=ZSDIVG,PSPTG=ZSPTG,PSPSEL3DG=ZSO3G, &
!!           & PSPSPG=ZSPSPG, LDSELECT3D=LLSELECT3D)

!     2.    Convert from full fields to P and unbalanced fields
!           ---------------------------------------------------

DO JSP=1,NSPEC2V
  !!IN=NVALUE(JSP+NPTRSV(MYSETN)-1)
  IN=YDLAP%NVALUE(JSP)

!           2.1 Divergence

  !!ZBUF(1:NFLEVG)=ZSZPG(1:NFLEVG,JSP)
  ZBUF(1:NFLEVG)=PSPZZP(1:NFLEVG,JSP)
  CALL MXMAOP(JB_STRUCT%JB_DATA%SDIV(1,1,IN),1,NFLEVG,&
   & ZBUF,1,NFLEVG,ZDIV,1,NFLEVG,&
   & NFLEVG,NFLEVG,1)  
  !!ZSDIVG(1:NFLEVG,JSP) = ZSDIVG(1:NFLEVG,JSP)-ZDIV(1:NFLEVG)
  ZSPA3(1:NFLEVG,JSP,2) = ZSPA3(1:NFLEVG,JSP,2)-ZDIV(1:NFLEVG)

!           2.2 (T,ps)

  !!ZIN(1:NFLEVG)          = ZSZPG(1:NFLEVG,JSP)
  !!ZIN(NFLEVG+1:2*NFLEVG) = ZSDIVG(1:NFLEVG,JSP)
  ZIN(1:NFLEVG)          = PSPZZP(1:NFLEVG,JSP)
  ZIN(NFLEVG+1:2*NFLEVG) = ZSPA3(1:NFLEVG,JSP,2)
  CALL MXMAOP(JB_STRUCT%JB_DATA%STPS(1,1,IN),1,NFLEVG+1,&
   & ZIN,1,2*NFLEVG,ZTPS,1,NFLEVG+1,&
   & NFLEVG+1,2*NFLEVG,1)  
  !!ZSPTG(1:NFLEVG,JSP) = ZSPTG(1:NFLEVG,JSP)-ZTPS(1:NFLEVG)
  ZSPA3(1:NFLEVG,JSP,3) = ZSPA3(1:NFLEVG,JSP,3)-ZTPS(1:NFLEVG)
  !!ZSPSPG(JSP)         = ZSPSPG(JSP)-ZTPS(NFLEVG+1)
  ZSPA2(JSP,1) = ZSPA2(JSP,1)-ZTPS(NFLEVG+1)

ENDDO

!           2.3 Ozone

!!IF (ANY(SPJB_VARS_INFO(:)%IGRIBCODE==NGRBO3)) THEN
!!  DO JSP=1,NSPEC2V
!!    IN=NVALUE(JSP+NPTRSV(MYSETN)-1)
!!    ZBUF(1:NFLEVG)=ZSZPG(1:NFLEVG,JSP)
!!    CALL MXMAOP(SO3(1,1,IN),1,NFLEVG,&
!!     & ZBUF,1,NFLEVG,ZO3,1,NFLEVG,&
!!     & NFLEVG,NFLEVG,1)  
!!    ZSO3G(1:NFLEVG,JSP,1) = ZSO3G(1:NFLEVG,JSP,1)-ZO3(1:NFLEVG)
!!  ENDDO
!!ENDIF

!     3.    Transpose data from vertical columns back to level structure
!           ------------------------------------------------------------

!!CALL TRSTOM (PSPDIVG=ZSDIVG,PSPTG=ZSPTG,PSPSEL3DG=ZSO3G,PSPSPG=ZSPSPG,&
!!           & PSPDIV=YDSPEC%DIV,PSPT=YDSPEC%T,PSPSEL3D=YDSPEC%SP3D, &
!!           & PSPSP=ZSP, LDSELECT3D=LLSELECT3D)

!     ------------------------------------------------------------------

!!IF (NPSP==1) YDSPEC%SP=ZSP
!!DEALLOCATE(ZSO3G)

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('BALVERTI_LOC',1,ZHOOK_HANDLE)
END SUBROUTINE BALVERTI_LOC

