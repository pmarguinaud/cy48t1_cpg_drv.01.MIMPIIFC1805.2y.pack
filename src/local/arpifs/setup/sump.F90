SUBROUTINE SUMP(YDGEOMETRY)

!**** *SUMP * - Routine to initialize parallel environment

!     Purpose.
!     --------
!           Initialize yommp common block variables

!**   Interface.
!     ----------
!        *CALL* *SUMP *

!        Explicit arguments :
!        --------------------

!        Implicit arguments :
!        --------------------

!     Method.
!     -------
!        See documentation

!     Externals.   NONE.
!     ----------

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!      MPP Group *ECMWF*
!      Original   : 95-10-01

!     Modifications.
!     --------------
!      K. Yessad 07-03-2007: Remove useless (gw)_surf interpol. in NH+LGWADV.
!      N. Wedi and K. Yessad (Jan 2008): different dev for NH model and PC scheme
!      K. Yessad (Jan 2011): remove NPROMT.
!      B. Bochenek (Apr 2012): call for SUOPTPROMA, cleaning
!      K. Yessad (July 2013): minor modifications in printings 
!                             (printing and setup in the same routine).
!      T. Wilhelmsson and K. Yessad (Oct 2013) Geometry and setup refactoring.
!      K. Yessad (July 2014): Move some variables.
!      K. Yessad (Dec 2016): Prune obsolete options.
!      R. El Khatib 16-May-2019 optimize memory access in NGPSET2PE
!     End Modifications
!     ------------------------------------------------------------------

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE PARKIND1 , ONLY : JPIM, JPRB
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK
USE YOMMP0   , ONLY : LOUTPUT, NPRTRW, MYSETW, NPRTRNS, NPRTRV, MYSETV,&
 & MY_REGION_NS, MY_REGION_EW, NGPSET2PE, N_REGIONS_NS, N_REGIONS, NPRINTLEV
USE YOMLUN   , ONLY : NULOUT
USE YOMCT0   , ONLY : LNHDYN
USE YOMDYNA  , ONLY : YRDYNA
USE OML_MOD, ONLY : OML_MAX_THREADS
USE IOSTREAM_MIX , ONLY : INI_IOSTREAM

!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY), INTENT(INOUT) :: YDGEOMETRY
INTEGER(KIND=JPIM) :: IAVE, IBSET,&
 & IENDL, IGL, I, III, IITER, ILBEG, ILEND, ILEV, IM,&
 & IND, INM, INSEF, IPRUSED, IRESTF,&
 & ISPEC2REM, ISTAL, JA, JB,&
 & JGL, JJ, JL, JLEV, JLT, JMLOC, IPROC,&
 & ILEVPP, IREST, JROCB, IPROMA, IGPBLKS, IGLG, JLON, ILONG
LOGICAL :: LLBAL
INTEGER(KIND=JPIM) :: IGLOBAL(YDGEOMETRY%YRDIM%NDLON,YDGEOMETRY%YRDIM%NDGLG)
INTEGER(KIND=JPIM) :: IMYMS(YDGEOMETRY%YRDIM%NCMAX+1)
INTEGER(KIND=JPIM) :: INUMCPP(NPRTRW)
INTEGER(KIND=JPIM) :: INUMSVF(NPRTRV+1)
INTEGER(KIND=JPIM) :: IULTPP(NPRTRNS)
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!----POINTERS FOR ASSOCIATION --------------------------
INTEGER(KIND=JPIM),POINTER :: NLONGPP(:,:)
INTEGER(KIND=JPIM),POINTER :: NLATGPP(:,:)
!     ------------------------------------------------------------------

#include "ini_spec_dist.h"
#include "trans_inq.h"

#include "abor1.intfb.h"
#include "sualmp1.intfb.h"
#include "sualmp2.intfb.h"
#include "suoptproma.intfb.h"

!     ------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('SUMP',0,ZHOOK_HANDLE)

!     ------------------------------------------------------------------

!*       0.    Preliminary calculations and allocations
!              (identical to content of SUEMP).

! * Allocate  arrays used in this routine

CALL SUALMP1(YDGEOMETRY)

ASSOCIATE(NCMAX=>YDGEOMETRY%YRDIM%NCMAX, NDGENL=>YDGEOMETRY%YRDIM%NDGENL, NDGLG=>YDGEOMETRY%YRDIM%NDGLG, &
 & NDGLL=>YDGEOMETRY%YRDIM%NDGLL, NDGSAL=>YDGEOMETRY%YRDIM%NDGSAL, NDGUNL=>YDGEOMETRY%YRDIM%NDGUNL, &
 & NDGUXG=>YDGEOMETRY%YRDIM%NDGUXG, NDGUXL=>YDGEOMETRY%YRDIM%NDGUXL, NDLON=>YDGEOMETRY%YRDIM%NDLON, &
 & NGPBLKS=>YDGEOMETRY%YRDIM%NGPBLKS, NMSMAX=>YDGEOMETRY%YRDIM%NMSMAX, NPROMA=>YDGEOMETRY%YRDIM%NPROMA, &
 & NRESOL=>YDGEOMETRY%YRDIM%NRESOL, NSMAX=>YDGEOMETRY%YRDIM%NSMAX, NSPEC=>YDGEOMETRY%YRDIM%NSPEC, &
 & NSPEC2=>YDGEOMETRY%YRDIM%NSPEC2, NSPEC2MX=>YDGEOMETRY%YRDIM%NSPEC2MX, NUMCP=>YDGEOMETRY%YRDIM%NUMCP, &
 & NUMP=>YDGEOMETRY%YRDIM%NUMP, &
 & NFLEVG=>YDGEOMETRY%YRDIMV%NFLEVG, NFLEVL=>YDGEOMETRY%YRDIMV%NFLEVL, NFLEVLMX=>YDGEOMETRY%YRDIMV%NFLEVLMX, &
 & NFLSUR=>YDGEOMETRY%YRDIMV%NFLSUR, &
 & NGPTOT=>YDGEOMETRY%YRGEM%NGPTOT, NGPTOTG=>YDGEOMETRY%YRGEM%NGPTOTG, NGPTOTL=>YDGEOMETRY%YRGEM%NGPTOTL, &
 & NGPTOTMX=>YDGEOMETRY%YRGEM%NGPTOTMX, NGPTOT_CAP=>YDGEOMETRY%YRGEM%NGPTOT_CAP, NLOENG=>YDGEOMETRY%YRGEM%NLOENG, &
 & LSPLITLAT=>YDGEOMETRY%YRMP%LSPLITLAT, MYFRSTACTLAT=>YDGEOMETRY%YRMP%MYFRSTACTLAT, &
 & MYLSTACTLAT=>YDGEOMETRY%YRMP%MYLSTACTLAT, &
 & NALLMS=>YDGEOMETRY%YRMP%NALLMS, NBSETLEV=>YDGEOMETRY%YRMP%NBSETLEV, NBSETSP=>YDGEOMETRY%YRMP%NBSETSP, &
 & NDIM0G=>YDGEOMETRY%YRMP%NDIM0G, NFRSTLAT=>YDGEOMETRY%YRMP%NFRSTLAT, NFRSTLOFF=>YDGEOMETRY%YRMP%NFRSTLOFF, &
 & NLSTLAT=>YDGEOMETRY%YRMP%NLSTLAT, NONL=>YDGEOMETRY%YRMP%NONL, NPOSSP=>YDGEOMETRY%YRMP%NPOSSP, &
 & NPROCM=>YDGEOMETRY%YRMP%NPROCM, NPSP=>YDGEOMETRY%YRMP%NPSP, NPSURF=>YDGEOMETRY%YRMP%NPSURF, &
 & NPTRFLOFF=>YDGEOMETRY%YRMP%NPTRFLOFF, NPTRFRSTLAT=>YDGEOMETRY%YRMP%NPTRFRSTLAT, &
 & NPTRLAT=>YDGEOMETRY%YRMP%NPTRLAT, NPTRLL=>YDGEOMETRY%YRMP%NPTRLL, NPTRLS=>YDGEOMETRY%YRMP%NPTRLS, &
 & NPTRLSTLAT=>YDGEOMETRY%YRMP%NPTRLSTLAT, NPTRMF=>YDGEOMETRY%YRMP%NPTRMF, NPTRMS=>YDGEOMETRY%YRMP%NPTRMS, &
 & NPTRSV=>YDGEOMETRY%YRMP%NPTRSV, NPTRSVF=>YDGEOMETRY%YRMP%NPTRSVF, NSPEC2V=>YDGEOMETRY%YRMP%NSPEC2V, &
 & NSPEC2VF=>YDGEOMETRY%YRMP%NSPEC2VF, NSPEC2V_NH=>YDGEOMETRY%YRMP%NSPEC2V_NH, &
 & NSPEC2V_NHX=>YDGEOMETRY%YRMP%NSPEC2V_NHX, NSPSTAF=>YDGEOMETRY%YRMP%NSPSTAF, NSTA=>YDGEOMETRY%YRMP%NSTA, &
 & NUMLL=>YDGEOMETRY%YRMP%NUMLL, NUMPP=>YDGEOMETRY%YRMP%NUMPP)

! * Determine number of local levels for Fourier and Legendre calculations
!   This is based on the supplied NFLEVG and NPRTRV

IPRUSED=MIN(NFLEVG+1,NPRTRV)
ILEVPP=NFLEVG/NPRTRV
IREST=NFLEVG-ILEVPP*NPRTRV

DO JROCB=1,NPRTRV
  IF(JROCB <= IREST) THEN
    NUMLL(JROCB)=ILEVPP+1
  ELSE
    NUMLL(JROCB)=ILEVPP
  ENDIF
ENDDO
NUMLL(IPRUSED+1:NPRTRV+1)=0

!     Define local definitions for this processor set

NFLEVL=NUMLL(MYSETV)
NFLEVLMX=NUMLL(1)

DO JROCB=1,IPRUSED
  NPSURF(JROCB)=0
ENDDO
NPSURF(IPRUSED)=1
NPSP=NPSURF(MYSETV)

NFLSUR=NFLEVL

!     Some printings

WRITE(NULOUT,'('' NUMBER OF LEVELS '')')
WRITE(UNIT=NULOUT,FMT='('' NFLEVL ='',I6,'' NPSP='',I6,'' NFLSUR ='',I6)')&
 & NFLEVL,NPSP,NFLSUR
WRITE(NULOUT,'('' NPSURF '')')
WRITE(UNIT=NULOUT,FMT='(20(1X,I4))')(NPSURF(JJ),JJ=1,NPRTRV)

! ------------------------------------------------------------------

!*       1.    Initialize partitioning of wave numbers to PEs
!              ----------------------------------------------

CALL TRANS_INQ(KRESOL=NRESOL,KUMPP=NUMPP,KPOSSP=NPOSSP,KPTRMS=NPTRMS,&
 & KALLMS=NALLMS,KDIM0G=NDIM0G,&
 & KSPEC=NSPEC,KSPEC2=NSPEC2,KSPEC2MX=NSPEC2MX,KNUMP=NUMP)  

CALL INI_SPEC_DIST(NCMAX,NCMAX,&
 & NPRTRW,MYSETW,KPROCM=NPROCM,KUMPP=INUMCPP,&
 & KMYMS=IMYMS)  

NUMCP = INUMCPP(MYSETW)

! Retrieve distribution of latitude related data structures (grid-point space)

CALL TRANS_INQ(KRESOL=NRESOL,KFRSTLAT=NFRSTLAT,KLSTLAT=NLSTLAT,KFRSTLOFF=NFRSTLOFF,&
 & KPTRLAT=NPTRLAT,KPTRFRSTLAT=NPTRFRSTLAT,KPTRLSTLAT=NPTRLSTLAT,&
 & KPTRFLOFF=NPTRFLOFF,KONL=NONL(1:,:),KSTA=NSTA(1:,:),LDSPLITLAT=LSPLITLAT,&
 & KGPTOT=NGPTOT,KGPTOTG=NGPTOTG,KGPTOTMX=NGPTOTMX,KGPTOTL=NGPTOTL)  

! Fourier space (this should not really have to be known within the IFS)

CALL TRANS_INQ(KRESOL=NRESOL,KULTPP=IULTPP,KPTRLS=NPTRLS)

IF (LOUTPUT) THEN
  WRITE(NULOUT,'(/'' OUTPUT FROM ROUTINE SUMP - PART 1:''/)')
  WRITE(NULOUT,'('' NUMP NUMCP'')')
  WRITE(NULOUT,'(4(1X,I4))') NUMP, NUMCP
  WRITE(NULOUT,'('' NUMPP '')')
  WRITE(NULOUT,'(20(1X,I4))')(NUMPP(JJ),JJ=1,NPRTRW)
  WRITE(NULOUT,*) "NUMBER OF THREADS",OML_MAX_THREADS()
  IF (NPRINTLEV >= 1) THEN
    WRITE(NULOUT,'('' NPROCM '')')
    WRITE(NULOUT,'(20(1X,I4))')(NPROCM(JJ),JJ=0,NSMAX)
  ENDIF
ENDIF

IF (LOUTPUT.AND.NPRINTLEV >= 1) THEN
  WRITE(UNIT=NULOUT,FMT='('' NFRSTLAT '')')
  WRITE(UNIT=NULOUT,FMT='(20(1X,I4))') NFRSTLAT(1:N_REGIONS_NS)
  WRITE(UNIT=NULOUT,FMT='('' NLSTLAT '')')
  WRITE(UNIT=NULOUT,FMT='(20(1X,I4))') NLSTLAT(1:N_REGIONS_NS)
  WRITE(UNIT=NULOUT,FMT='('' NFRSTLOFF  NPTRFLOFF '')')
  WRITE(UNIT=NULOUT,FMT='(2(1X,I6))') NFRSTLOFF, NPTRFLOFF
  WRITE(UNIT=NULOUT,FMT='('' NPTRLAT '')')
  WRITE(UNIT=NULOUT,FMT='(20(1X,I4))') NPTRLAT(1:NDGLG)
  WRITE(UNIT=NULOUT,FMT='('' LSPLITLAT '')')
  WRITE(UNIT=NULOUT,FMT='(50(1X,L1))') LSPLITLAT(1:NDGLG)
  WRITE(UNIT=NULOUT,FMT='('' NPTRFRSTLAT '')')
  WRITE(UNIT=NULOUT,FMT='(20(1X,I4))') NPTRFRSTLAT(1:N_REGIONS_NS)
  WRITE(UNIT=NULOUT,FMT='('' NPTRLSTLAT '')')
  WRITE(UNIT=NULOUT,FMT='(20(1X,I4))') NPTRLSTLAT(1:N_REGIONS_NS)
  WRITE(UNIT=NULOUT,FMT='(/)')
ENDIF

! Number of latitudes owned by each A-set member in Fourier space
NDGLL  = IULTPP(MYSETW)
NDGSAL = 1
NDGENL = NLSTLAT(MY_REGION_NS)-NFRSTLOFF

IF (NFRSTLAT(MY_REGION_NS)+IULTPP(MYSETW) <= NDGUXG) THEN
  NDGUXL=IULTPP(MYSETW)
  NDGUNL  = 1
ELSE
  NDGUXL=NDGUXG-NFRSTLAT(MY_REGION_NS)+1
  NDGUNL  = 1
ENDIF

! Compute first and last actual latitudes of local processor (grid-point)

MYFRSTACTLAT = NFRSTLAT(MY_REGION_NS)
MYLSTACTLAT  = NLSTLAT (MY_REGION_NS)
ILBEG=NFRSTLAT(MY_REGION_NS)-NFRSTLOFF
ILEND=NLSTLAT (MY_REGION_NS)-NFRSTLOFF

DO JGL=ILBEG,ILEND
  IF (NONL(NPTRFLOFF+JGL,MY_REGION_EW) == 0) THEN
    MYFRSTACTLAT = MYFRSTACTLAT+1
  ELSE
    EXIT
  ENDIF
ENDDO

DO JGL=ILEND,ILBEG,-1
  IF (NONL(NPTRFLOFF+JGL,MY_REGION_EW) == 0) THEN
    MYLSTACTLAT = MYLSTACTLAT-1
  ELSE
    EXIT
  ENDIF
ENDDO

! Code that handles control of 3D-transposition

!  Partitioning of spectral coefficients in semi-implicit calculations
!  Be careful : NSPEC2 varies between A-processor sets, so NPTRSV()
!  differs on different A-processor sets.

INSEF=NSPEC2/NPRTRV
IRESTF=NSPEC2-INSEF*NPRTRV
NPTRSV(1)=1
DO JB=2,NPRTRV+1
  IF(JB-1 <= IRESTF) THEN
    NPTRSV(JB)=NPTRSV(JB-1)+INSEF+1
  ELSE
    NPTRSV(JB)=NPTRSV(JB-1)+INSEF
  ENDIF
ENDDO


!  Partitioning of spectral coefficients in semi-implicit calculations
!  for the case where complete m-columns are required.

IITER=0
DO
  IBSET=MIN(NPRTRV,NUMP)
  LLBAL=IITER /= 0
  ! At the first iteration NPTRMF is not yet initialized => the test is irrelevent
  IF (LLBAL) THEN
    DO JB=MIN(NPRTRV,2),IBSET
      IF( NPTRMF(JB) == -999 ) LLBAL=.FALSE.
    ENDDO
  ENDIF
  IF( LLBAL ) EXIT
  IITER=IITER+1
  NPTRMF(:)=-999
  INUMSVF(:)=0
  NPTRMF(1)=1
  NPTRMF(IBSET+1:NPRTRV+1)=NUMP+1
  IF(NUMP>0)THEN
    ISPEC2REM=NSPEC2
    IAVE=(ISPEC2REM-1)/IBSET+1-IITER
    DO JMLOC=NUMP,1,-1
      IM=IMYMS(JMLOC)
      INM=2*(NSMAX-IM+1)
      IF (INUMSVF(IBSET) < IAVE) THEN
        INUMSVF(IBSET)=INUMSVF(IBSET)+INM
      ELSE
        NPTRMF(IBSET)=JMLOC+1
        ISPEC2REM=ISPEC2REM-INUMSVF(IBSET)
        IBSET=IBSET-1
        IF (IBSET == 0) THEN
          CALL ABOR1('SUMP : PROBLEM PARTITIONING SPECTRAL SPACE')
        ENDIF
        IAVE=(ISPEC2REM-1)/IBSET+1-IITER
        INUMSVF(IBSET)=INUMSVF(IBSET)+INM
      ENDIF
    ENDDO
  ENDIF
ENDDO

NPTRSVF(1)=1
DO JB=2,NPRTRV+1
  NPTRSVF(JB)=NPTRSVF(JB-1)+INUMSVF(JB-1)
ENDDO

NSPSTAF(:)=-999
III=1
DO JMLOC=NPTRMF(MYSETV),NPTRMF(MYSETV+1)-1
  NSPSTAF(IMYMS(JMLOC))=III
  III=III+2*(NSMAX-IMYMS(JMLOC)+1)
ENDDO

IPRUSED=MIN(NFLEVG+1,NPRTRV)
NPTRLL(1)=1
DO JB=2,IPRUSED+1
  NPTRLL(JB)=NPTRLL(JB-1)+NUMLL(JB-1)
ENDDO

NBSETSP = IPRUSED

ILEV = 0
DO JB=1,NPRTRV
  DO JLEV=1,NUMLL(JB)
    ILEV = ILEV + 1
    NBSETLEV(ILEV) = JB
  ENDDO
ENDDO

CALL INI_IOSTREAM(KBSETSP=NBSETSP,KBSETLEV=NBSETLEV,KFLEVG=NFLEVG,KSMAX=NSMAX,KDGLG=NDGLG,&
 & KLOENG=NLOENG(1:NDGLG))

! Define local definitions for this processor set

NSPEC2V=NPTRSV(MYSETV+1)-NPTRSV(MYSETV)
NSPEC2VF=NPTRSVF(MYSETV+1)-NPTRSVF(MYSETV)
IF (LNHDYN) THEN
  NSPEC2V_NH=MAX(NSPEC2V,NSPEC2VF)
ELSE
  NSPEC2V_NH=0
ENDIF
IF (YRDYNA%LNHX) THEN
  NSPEC2V_NHX=MAX(NSPEC2V,NSPEC2VF)
ELSE
  NSPEC2V_NHX=0
ENDIF

!     Set up NPROM* variables, moved from SUDIM2 
!     NPROMA optimization
WRITE(NULOUT,*) '------ Set up NPROM* --------'
CALL SUOPTPROMA(YDGEOMETRY)

!  Calculate number of NPROMA-blocks of grid point data

NGPBLKS=(NGPTOT-1)/NPROMA+1

! Allocation NLONGPP, NLATGPP
ALLOCATE(YDGEOMETRY%YRMP%NLONGPP(NPROMA,NGPBLKS))
ALLOCATE(YDGEOMETRY%YRMP%NLATGPP(NPROMA,NGPBLKS))

!  There are no capping points in the global model gridpoint domain

NGPTOT_CAP=NGPTOT

!  Allocate more pointer arrays that depend on distributed dimensions

CALL SUALMP2(YDGEOMETRY)

DO JLEV=1,NFLEVL
  YDGEOMETRY%YRMP%MYLEVS(JLEV) = NPTRLL(MYSETV)+JLEV-1
ENDDO

! Mapping between physical latitude number and local latitude number

ISTAL=NDGSAL
IENDL=NDGENL
DO JLT=ISTAL,IENDL
  YDGEOMETRY%YRMP%MYLATS(JLT) = NFRSTLAT(MY_REGION_NS)+JLT-NDGSAL
ENDDO

! Mapping of local grid points to global grid points for debugging

I=0
IGLOBAL(:,:)=0
DO JGL=1,NDGLG
  DO JL=1,NLOENG(JGL)
    I=I+1
    IGLOBAL(JL,JGL) = I
  ENDDO
ENDDO
I=0
DO JGL=NFRSTLAT(MY_REGION_NS),NLSTLAT(MY_REGION_NS)
  IGL = NPTRFRSTLAT(MY_REGION_NS)+JGL-NFRSTLAT(MY_REGION_NS)
  DO JL=NSTA(IGL,MY_REGION_EW),NSTA(IGL,MY_REGION_EW)+NONL(IGL,MY_REGION_EW)-1
    I=I+1
    IF( IGLOBAL(JL,JGL) == 0 )THEN
      CALL ABOR1('SUMP: INTERNAL ERROR, INVALID GLOBAL INDEX')
    ENDIF
    YDGEOMETRY%YRMP%NGLOBALINDEX(I)=IGLOBAL(JL,JGL)
    YDGEOMETRY%YRMP%NGLOBALAT(I)=JGL
  ENDDO
ENDDO

! Initialise NGLOBALPROC, NLOCALINDEX

YDGEOMETRY%YRMP%NGLOBALPROC(:)=0
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JA,JB,IPROC,I,JGL,IGL,JL,IND)
DO JA=1,N_REGIONS_NS
  DO JB=1,N_REGIONS(JA)
    IPROC=NGPSET2PE(JB,JA)
    I=0
    DO JGL=NFRSTLAT(JA),NLSTLAT(JA)
      IGL = NPTRFRSTLAT(JA)+JGL-NFRSTLAT(JA)
      DO JL=NSTA(IGL,JB),NSTA(IGL,JB)+NONL(IGL,JB)-1
        IND=IGLOBAL(JL,JGL)
        YDGEOMETRY%YRMP%NGLOBALPROC(IND)=IPROC
        I=I+1
        YDGEOMETRY%YRMP%NLOCALINDEX(IND)=I
      ENDDO
    ENDDO
  ENDDO
ENDDO
!$OMP END PARALLEL DO

! Computation NLONGPP, NLATGPP

YDGEOMETRY%YRMP%NLATGPP(:,:)=-99999
YDGEOMETRY%YRMP%NLONGPP(:,:)=-99999
IPROMA=0
IGPBLKS=1
DO JGL=NDGSAL,NDGENL
  IGLG=YDGEOMETRY%YRMP%MYLATS(JGL)
  DO JLON=1,NONL(NPTRFLOFF+JGL,MY_REGION_EW)
    ILONG=NSTA(NPTRFLOFF+JGL,MY_REGION_EW)+JLON-1
    IPROMA=IPROMA+1
    IF (IPROMA > NPROMA) THEN
      IPROMA=1
      IGPBLKS=IGPBLKS+1
    ENDIF
    YDGEOMETRY%YRMP%NLATGPP(IPROMA,IGPBLKS)=IGLG
    YDGEOMETRY%YRMP%NLONGPP(IPROMA,IGPBLKS)=ILONG
  ENDDO
ENDDO

IF (IGPBLKS /= NGPBLKS) CALL ABOR1("SUMP: CONFLICT IN NGPBLKS")

IF (LOUTPUT) THEN
  WRITE(NULOUT,'(/'' OUTPUT FROM ROUTINE SUMP - PART 2:''/)')
  WRITE(NULOUT,'('' NGPBLKS ='',I8)') NGPBLKS
  WRITE(UNIT=NULOUT,FMT='(''     NGPTOT   NGPTOTMX    NGPTOTG NGPTOT_CAP '')')
  WRITE(UNIT=NULOUT,FMT='(4(1X,I10))') NGPTOT, NGPTOTMX, NGPTOTG, NGPTOT_CAP
ENDIF
IF (LOUTPUT.AND.NPRINTLEV >= 1) THEN
  WRITE(NULOUT,'(/'' OUTPUT FROM ROUTINE SUMP - PART 2:''/)')
  WRITE(NULOUT,'('' NALLMS '')')
  WRITE(NULOUT,'(30(1X,I3))')(NALLMS(JJ),JJ=1,NSMAX+1)
  WRITE(NULOUT,'('' NPTRMS '')')
  WRITE(NULOUT,'(20(1X,I4))')(NPTRMS(JJ),JJ=1,NPRTRW)
  WRITE(NULOUT,'('' NPOSSP '')')
  WRITE(NULOUT,'(20(1X,I8))')(NPOSSP(JJ),JJ=1,NPRTRW)
  WRITE(NULOUT,'('' NDIM0G '')')
  WRITE(NULOUT,'(16(1X,I6))')(NDIM0G(JJ),JJ=0,NSMAX)
  WRITE(NULOUT,'('' NSPEC, NSPEC2, NSPEC2MX, NSPEC2V, NSPEC2VF'')')
  WRITE(NULOUT,'(5(1X,I6))')NSPEC, NSPEC2, NSPEC2MX, NSPEC2V,NSPEC2VF
  WRITE(NULOUT,*) ' NSPEC2V_NH = ',NSPEC2V_NH
  WRITE(NULOUT,*) ' NSPEC2V_NHX = ',NSPEC2V_NHX
  WRITE(NULOUT,'('' NDGLL,NDGSAL,NDGENL '')')
  WRITE(NULOUT,'(1X,3I6)') NDGLL, NDGSAL, NDGENL
  WRITE(NULOUT,'('' MYFRSTACTLAT, MYLSTACTLAT '')')
  WRITE(NULOUT,'(1X,2I6)') MYFRSTACTLAT, MYLSTACTLAT
  WRITE(NULOUT,'('' NPTRLS '')')
  WRITE(NULOUT,'(20(1X,I4))')(NPTRLS(JJ),JJ=1,NPRTRW)

  WRITE(NULOUT,'('' NPTRSV '')')
  WRITE(NULOUT,'(16(1X,I6))')(NPTRSV(JJ),JJ=1,NPRTRV+1)
  WRITE(NULOUT,'('' NPTRSVF '')')
  WRITE(NULOUT,'(16(1X,I6))')(NPTRSVF(JJ),JJ=1,NPRTRV+1)
  WRITE(NULOUT,'('' NPTRMF '')')
  WRITE(NULOUT,'(16(1X,I6))')(NPTRMF(JJ),JJ=1,NPRTRV+1)
  WRITE(NULOUT,'('' MYLEVS '')')
  WRITE(NULOUT,'(20(1X,I4))') (YDGEOMETRY%YRMP%MYLEVS(JJ),JJ=1,NFLEVL)
  WRITE(NULOUT,'('' NUMLL '')')
  WRITE(NULOUT,'(20(1X,I10))')(NUMLL(JJ),JJ=1,NPRTRV+1)
  WRITE(NULOUT,'('' NPTRLL '')')
  WRITE(NULOUT,'(20(1X,I4))')(NPTRLL(JJ),JJ=1,NPRTRV+1)
  WRITE(NULOUT,'('' NBSETLEV '')')
  WRITE(NULOUT,'(20(1X,I4))')(NBSETLEV(JJ),JJ=1,NFLEVG)
  WRITE(NULOUT,'('' MYLATS '')')
  WRITE(NULOUT,'(20(1X,I4))') (YDGEOMETRY%YRMP%MYLATS(JJ),JJ=ISTAL,IENDL)

  WRITE(NULOUT,'('' NSPSTAF-VALUES FOR THE M-WAVES USED '')')
  WRITE(NULOUT,'(6(1X,''('',I4,I6,'')''))') (IMYMS(JMLOC),&
   & NSPSTAF(IMYMS(JMLOC)),JMLOC=NPTRMF(MYSETV),NPTRMF(MYSETV+1)-1)  
ENDIF

9990 FORMAT(1X,'ARRAY ',A10,' ALLOCATED ',8I8)

!     -----------------------------------------------------------

END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('SUMP',1,ZHOOK_HANDLE)
END SUBROUTINE SUMP
