SUBROUTINE TRANSINV_MDL(YDGEOMETRY,YDGMV,YDMDDH,YDML_GCONF, &
 & PSPVOR,PSPDIV,PSPSP,PSPHV,PSPGFL,&
 & PGMV,PGMVS,PGFL,LDUV,LDERR,LDVOR,LDFSCOMP,&
 & PSPTNDSI_VOR,PSPTNDSI_DIV,PSPTNDSI_T,&
 & PSPTNDSI_SPD,PSPTNDSI_SVD,&
 & PSPTNDHD_VOR,PSPTNDHD_DIV,PSPTNDHD_T,&
 & PSPTNDHD_SPD,PSPTNDHD_SVD,PSPTNDHD_SNHX,PSPTNDHD_GFL,&
 & PGMVTNDSI,PGMVTNDHD,PGFLTNDHD,&
 & LDDHDYN,LDSIDDH,LDHDDDH,PSPVOR_FLT,PSPDIV_FLT,PKRF)

!**** *TRANSINV_MDL * - Inverse transforms for model

!     Purpose.  Perform inverse transform (spectral to gridpoint)
!     --------

!**   Interface.  CALL TRANSINV_MDL(...)
!     ---------- 

!     Explicit arguments : 
!     --------------------
!        PSPVOR - spectral vorticity
!        PSPDIV - spectral divergence
!        PSPSP  - spectral surface pressure
!        PSPHV  - spectral thermodynamic variables
!        PSPGFL - spectral GFL variables
!        PGMV   - GMV gridpoint
!        PGMVS  - GMV single level gridpoint
!        PGFL   - GFL gridpoint
!        LDUV - TRUE if u and v zonal derivates required
!        LDERR  - TRUE if derivatives required
!        LDFSCOMP - true if "scientific" computations in fourier space req.
!        LDVOR  - TRUE if vorticity needed
!        PVOR_FLT,PSPDIV_FLT - optional filtered gradients if LGRADSP
!        PKRF   - Rayleigh friction coefficient, stored in the model

!        Called by TRANSINVH

!     Externals.
!     ----------
!     INV_TRANS - inverse transform (TRANS library)

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!        Mats Hamrud *ECMWF*

!     Modifications.
!     --------------
!        Original : 00-10-25
!        R. El Khatib 02-09-05 : Fix for passive scalars.
!        Modified : 03-08-01 M.Hamrud - GFL introduction
!        M.Hamrud      01-Oct-2003 CY28 Cleaning
!        C.Temperton 04-01-29: Fix for SWE (is there a cleaner way?)
!        R. El Khatib 18-Apr-2005 NPROMATR
!        N Wedi (Nov 2011): change logic for LVOR, add LGRADSP
!        M.Fisher 15-Feb-2013 CVA_DATA
!        O.Jaron (Sept 2018) Introduce LDUV
!     ------------------------------------------------------------------

USE MODEL_GENERAL_CONF_MOD , ONLY : MODEL_GENERAL_CONF_TYPE
USE GEOMETRY_MOD           , ONLY : GEOMETRY
USE YOMGMV                 , ONLY : TGMV
USE PARKIND1               , ONLY : JPIM, JPRB
USE YOMHOOK                , ONLY : LHOOK, DR_HOOK
USE YOMMP0                 , ONLY : MYSETV
USE YOMTRANS               , ONLY : NPROMATR
USE YOMCT3                 , ONLY : NSTEP
USE YOMMDDH                , ONLY : TMDDH
USE YOMCT0                 , ONLY : LNHDYN
USE YOMDYNA                , ONLY : YRDYNA
USE FSPGL_MOD              , ONLY : FSPGL_FILL


!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY) ,INTENT(IN)    :: YDGEOMETRY
TYPE(TGMV)     ,INTENT(INOUT) :: YDGMV
TYPE(TMDDH)    ,INTENT(IN)    :: YDMDDH
TYPE(MODEL_GENERAL_CONF_TYPE),INTENT(IN)   :: YDML_GCONF
LOGICAL        ,INTENT(IN)    :: LDUV
LOGICAL        ,INTENT(IN)    :: LDERR
LOGICAL        ,INTENT(IN)    :: LDVOR
LOGICAL        ,INTENT(IN)    :: LDFSCOMP
REAL(KIND=JPRB),INTENT(IN)    :: PSPSP(:)
REAL(KIND=JPRB),INTENT(IN)    :: PSPVOR(:,:)
REAL(KIND=JPRB),INTENT(IN)    :: PSPDIV(:,:)
REAL(KIND=JPRB),INTENT(IN)    :: PSPHV(:,:,:)
REAL(KIND=JPRB),INTENT(IN)    :: PSPGFL(:,:,:)
REAL(KIND=JPRB),INTENT(OUT)   :: PGMVS(:,:,:)
REAL(KIND=JPRB),INTENT(OUT)   :: PGMV(:,:,:,:)
REAL(KIND=JPRB),INTENT(OUT)   :: PGFL(:,:,:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDSI_VOR(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDSI_DIV(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDSI_T(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDSI_SPD(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDSI_SVD(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDHD_VOR(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDHD_DIV(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDHD_T(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDHD_SPD(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDHD_SVD(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDHD_SNHX(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPTNDHD_GFL(:,:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(OUT) :: PGMVTNDSI(:,:,:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(OUT) :: PGMVTNDHD(:,:,:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(OUT) :: PGFLTNDHD(:,:,:,:)
LOGICAL        , OPTIONAL, INTENT(IN)  :: LDDHDYN
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPVOR_FLT(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PSPDIV_FLT(:,:)
LOGICAL        , OPTIONAL, INTENT(IN)  :: LDSIDDH
LOGICAL        , OPTIONAL, INTENT(IN)  :: LDHDDDH
REAL(KIND=JPRB), OPTIONAL, INTENT(IN)  :: PKRF(:) 
!     ------------------------------------------------------------------
EXTERNAL FSPGLH
REAL(KIND=JPRB) :: ZSP(1,YDGEOMETRY%YRDIM%NSPEC2)
REAL(KIND=JPRB), ALLOCATABLE :: ZGRAD(:,:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZGP(:,:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPEC(:,:)
REAL(KIND=JPRB), ALLOCATABLE :: ZSPTND_HV(:,:,:)
INTEGER(KIND=JPIM) :: IST,IOFF,IDIM3,ISTGMV,IENGMV,IDIMGMVS,ISTUV,IENUV
INTEGER(KIND=JPIM) :: IBL, IFLD, IMAXGP, ISPF, IST1, IEND1, ICHUNKS, IMAXLEV
INTEGER(KIND=JPIM) :: IENDLEV, JROF, JFLD, JSP, JKGLO, JSTLEV, IMAXSP, ILEVS, IFLDHV, ICEND
INTEGER(KIND=JPIM) :: JLEV
INTEGER(KIND=JPIM) :: IVSETSC(1)
INTEGER(KIND=JPIM), ALLOCATABLE :: IVSET(:)
LOGICAL :: LLUVDER,LLSCDERS,LLDIVGP,LLSIDDH,LLHDDDH,LLGRADSP

REAL(KIND=JPRB) :: ZHOOK_HANDLE

!     ------------------------------------------------------------------


#include "inv_trans.h"
!
#include "abor1.intfb.h"
!     ------------------------------------------------------------------
IF (LHOOK) CALL DR_HOOK('TRANSINV_MDL',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV, &
  & YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP, YGFL=>YDML_GCONF%YGFL,YDDIMF=>YDML_GCONF%YRDIMF)
ASSOCIATE(NUMFLDS=>YGFL%NUMFLDS, NUMSPFLDS=>YGFL%NUMSPFLDS, &
 & NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, NRESOL=>YDDIM%NRESOL, &
 & NSPEC2=>YDDIM%NSPEC2, NFTHER=>YDDIMF%NFTHER, &
 & NFLEVG=>YDDIMV%NFLEVG, NFLEVL=>YDDIMV%NFLEVL, &
 & NGPTOT=>YDGEM%NGPTOT, &
 & YT0=>YDGMV%YT0, YT9=>YDGMV%YT9, &
 & MHDDDH_Q=>YDMDDH%MHDDDH_Q, MHDDDH_U=>YDMDDH%MHDDDH_U, &
 & MHDDDH_V=>YDMDDH%MHDDDH_V, MSIDDH_U1=>YDMDDH%MSIDDH_U1, &
 & MSIDDH_V1=>YDMDDH%MSIDDH_V1, NDIMSIGMV=>YDMDDH%NDIMSIGMV, &
 & NBSETLEV=>YDMP%NBSETLEV, NBSETSP=>YDMP%NBSETSP)
!     ------------------------------------------------------------------

LLUVDER  = LDUV .AND. LDERR
LLSCDERS = LDERR
LLDIVGP  = LDERR

IVSETSC(1) = NBSETSP

IF ( PRESENT(PSPVOR_FLT)) THEN
  LLGRADSP = .TRUE.
ELSE
  LLGRADSP = .FALSE.
ENDIF

IF (PRESENT(LDSIDDH)) THEN
  LLSIDDH = LDSIDDH
ELSE
  LLSIDDH = .FALSE.
ENDIF

IF (PRESENT(LDHDDDH)) THEN
  LLHDDDH = LDHDDDH
ELSE
  LLHDDDH = .FALSE.
ENDIF

CALL GSTATS(1894,0)
IF(NBSETSP == MYSETV) THEN
  IST = 1
  ZSP(IST,:) = PSPSP(:)
ELSE
  IST = 0
ENDIF
CALL GSTATS(1894,1)

ISTGMV = YT0%NDIMUV+1
IENGMV = YT0%NDIM
IDIMGMVS = YT0%NDIMS
IF( LDVOR ) THEN
  ISTUV = 1
ELSE
  ISTUV = 2
ENDIF
IENUV = YT0%NDIMUV
IF( YRDYNA%LGRADSP ) IENGMV = IENGMV-2

IF( LLGRADSP ) THEN

  IF( NSTEP > 0 ) THEN
    ALLOCATE(ZGRAD(NPROMA,NFLEVG,2,NGPBLKS))
    CALL INV_TRANS(PSPVOR=PSPVOR_FLT,PSPDIV=PSPDIV_FLT,KVSETUV=NBSETLEV,&
     & KRESOL=NRESOL,KPROMA=NPROMA,PGPUV=ZGRAD)
    !$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) &
    !$OMP& PRIVATE (JKGLO,IBL,ICEND) &
    !$OMP& PRIVATE (JROF,JLEV)
    DO JKGLO=1,NGPTOT,NPROMA
      IBL=(JKGLO-1)/NPROMA+1
      ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)
      DO JLEV=1,NFLEVG
        DO JROF=1,ICEND
          ! store the filtered rhs
          PGMV(JROF,JLEV,YT0%MSGRTL,IBL) = ZGRAD(JROF,JLEV,1,IBL)
          PGMV(JROF,JLEV,YT0%MSGRTM,IBL) = ZGRAD(JROF,JLEV,2,IBL)
        ENDDO
      ENDDO
    ENDDO
    !$OMP END PARALLEL DO
    DEALLOCATE(ZGRAD)
  ELSE
    ! step 0, set to zero
    
    !$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) &
    !$OMP& PRIVATE (JKGLO,IBL,ICEND) &
    !$OMP& PRIVATE (JROF,JLEV)
    DO JKGLO=1,NGPTOT,NPROMA
      IBL=(JKGLO-1)/NPROMA+1
      ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)
      
      DO JLEV=1,NFLEVG
        DO JROF=1,ICEND
          ! initialize unfiltered and filtered rhs
          PGMV(JROF,JLEV,YT9%MSGRTL,IBL) = 0.0_JPRB
          PGMV(JROF,JLEV,YT9%MSGRTM,IBL) = 0.0_JPRB

          PGMV(JROF,JLEV,YT0%MSGRTL,IBL) = 0.0_JPRB
          PGMV(JROF,JLEV,YT0%MSGRTM,IBL) = 0.0_JPRB
        ENDDO
      ENDDO
    ENDDO
    !$OMP END PARALLEL DO 
  ENDIF
ENDIF

IF(.NOT. LLSCDERS) THEN
  IENGMV = MAX(ISTGMV,ISTGMV-1+(IENGMV-ISTGMV+1)/3)
  IDIMGMVS = MAX(1,IDIMGMVS/3)
  ISTUV = YT0%MU
  IENUV = YT0%MV
ENDIF

IF(NUMSPFLDS>0 .AND. NPROMATR<=0) THEN
  IOFF = NUMFLDS-NUMSPFLDS
  IDIM3 = NUMSPFLDS
  IF (LLSCDERS) IDIM3 = IDIM3*3
  IF (LDFSCOMP) THEN
    IF (.NOT. PRESENT(PKRF)) CALL ABOR1(& 
      & "Trying to run with LRFRIC but not providing Rayleigh coeff values to TRANSINV_MDL : wont work.")
    !! update the information needed by the 'real' call to FSPGLH from the trans library
    CALL FSPGL_FILL(YDGEOMETRY%YRMP%MYLEVS, PKRF, YDML_GCONF%YRRIP%TSTEP)
    CALL INV_TRANS(&
     & PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:IST,:),PSPSC3A=PSPHV,&
     & PSPSC3B=PSPGFL,&
     & LDSCDERS=LLSCDERS,LDVORGP=LDVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & KVSETSC3A=NBSETLEV,KVSETSC3B=NBSETLEV,&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
     & PGP3A=PGMV(:,:,ISTGMV:IENGMV,:),&
     & PGP3B=PGFL(:,:,IOFF+1:IOFF+IDIM3,:),&
     & FSPGL_PROC=FSPGLH)  
  ELSE
    CALL INV_TRANS(&
     & PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:IST,:),PSPSC3A=PSPHV,&
     & PSPSC3B=PSPGFL,&
     & LDSCDERS=LLSCDERS,LDVORGP=LDVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & KVSETSC3A=NBSETLEV,KVSETSC3B=NBSETLEV,&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
     & PGP3A=PGMV(:,:,ISTGMV:IENGMV,:),&
     & PGP3B=PGFL(:,:,IOFF+1:IOFF+IDIM3,:))  
  ENDIF
ELSEIF (ISTGMV>IENGMV .AND. NPROMATR<=0) THEN
  IF (LDFSCOMP) THEN
    IF (.NOT. PRESENT(PKRF)) CALL ABOR1( &
      & "Trying to run with LRFRIC but not providing Rayleigh coeff values to TRANSINV_MDL : wont work.")
    !! update the information needed by the 'real' call to FSPGLH from the trans library
    CALL FSPGL_FILL(YDGEOMETRY%YRMP%MYLEVS, PKRF, YDML_GCONF%YRRIP%TSTEP)
    CALL INV_TRANS(PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:1,:),&
     & LDSCDERS=LLSCDERS,LDVORGP=LDVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
     & FSPGL_PROC=FSPGLH)  
  ELSE
    CALL INV_TRANS(PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:1,:),&
     & LDSCDERS=LLSCDERS,LDVORGP=LDVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:)) 
  ENDIF
ELSEIF(NPROMATR<=0) THEN
  IF (LDFSCOMP) THEN
    IF (.NOT. PRESENT(PKRF)) CALL ABOR1( &
      & "Trying to run with LRFRIC but not providing Rayleigh coeff values to TRANSINV_MDL : wont work.")
    !! update the information needed by the 'real' call to FSPGLH from the trans library
    CALL FSPGL_FILL(YDGEOMETRY%YRMP%MYLEVS, PKRF, YDML_GCONF%YRRIP%TSTEP)
    CALL INV_TRANS(PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:1,:),&
     & PSPSC3A=PSPHV,&
     & LDSCDERS=LLSCDERS,LDVORGP=LDVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & KVSETSC3A=NBSETLEV,&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
     & PGP3A=PGMV(:,:,ISTGMV:IENGMV,:),&
     & FSPGL_PROC=FSPGLH)
  ELSE
    CALL INV_TRANS(PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:1,:),&
     & PSPSC3A=PSPHV,&
     & LDSCDERS=LLSCDERS,LDVORGP=LDVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & KVSETSC3A=NBSETLEV,&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
     & PGP3A=PGMV(:,:,ISTGMV:IENGMV,:))
  ENDIF

ELSE
! Slower but less memory-consuming transforms
  IST1=1
! 1/vector fields:
! Number of level chunks : deriving from NPROMATR, but at least 1 whole level :
  IF (NFLEVG==NFLEVL) THEN
    ICHUNKS=MIN((((IENUV-ISTUV+1)*NFLEVG-1)/NPROMATR+1),NFLEVG)
  ELSE
!   Vertical level distribution not coded
!   Mixture of NFLEVG and NFLEVL => bounds violations. REK
    CALL ABOR1('TRANSINV_MDL : NPROMATR /= 0 WITH NPRTRV /= 1 NOT CODED')
    ICHUNKS=1
  ENDIF
  IMAXLEV=(NFLEVG-1)/ICHUNKS+1
  DO JSTLEV=1,NFLEVG,IMAXLEV
    IENDLEV=JSTLEV-1+MIN(IMAXLEV,NFLEVG-JSTLEV+1)
    ILEVS=IENDLEV-JSTLEV+1
    IMAXGP=(IENUV-ISTUV+1)*ILEVS
    ALLOCATE(ZGP(NPROMA,IMAXGP,NGPBLKS))
    IF (LDFSCOMP) THEN
      IF (.NOT. PRESENT(PKRF)) CALL ABOR1( &
        & "Trying to run with LRFRIC but not providing Rayleigh coeff values to TRANSINV_MDL : wont work.")
      !! update the information needed by the 'real' call to FSPGLH from the trans library
      CALL FSPGL_FILL(YDGEOMETRY%YRMP%MYLEVS, PKRF, YDML_GCONF%YRRIP%TSTEP)
      CALL INV_TRANS(PSPVOR=PSPVOR(JSTLEV:IENDLEV,:),&
       & PSPDIV=PSPDIV(JSTLEV:IENDLEV,:),LDVORGP=LDVOR,LDDIVGP=LLDIVGP,&
       & LDUVDER=LLUVDER,KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV(JSTLEV:IENDLEV),&
       & PGP=ZGP(:,:,:),FSPGL_PROC=FSPGLH)
    ELSE
      CALL INV_TRANS(PSPVOR=PSPVOR(JSTLEV:IENDLEV,:),&
       & PSPDIV=PSPDIV(JSTLEV:IENDLEV,:),LDVORGP=LDVOR,LDDIVGP=LLDIVGP,&
       & LDUVDER=LLUVDER,KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV(JSTLEV:IENDLEV),&
       & PGP=ZGP(:,:,:))
    ENDIF
!$OMP PARALLEL PRIVATE(JKGLO,IBL,IEND1,JFLD,JLEV,IFLD,JROF)
!$OMP DO
    DO JKGLO=1,NGPTOT,NPROMA
      IBL=(JKGLO-1)/NPROMA+1
      IEND1=MIN(NPROMA,NGPTOT-JKGLO+1)
      DO JFLD=ISTUV,IENUV
        DO JLEV=JSTLEV,IENDLEV
          IFLD=JLEV-JSTLEV+1+(JFLD-ISTUV)*ILEVS
          DO JROF=IST1,IEND1
            PGMV(JROF,JLEV,JFLD,IBL)=ZGP(JROF,IFLD,IBL)
          ENDDO
        ENDDO
      ENDDO
    ENDDO
!$OMP END DO
!$OMP END PARALLEL
    DEALLOCATE(ZGP)
  ENDDO
! 2/scalar fields - gmvs
  IF (LDFSCOMP) THEN
    IF (.NOT. PRESENT(PKRF)) CALL ABOR1( &
      & "Trying to run with LRFRIC but not providing Rayleigh coeff values to TRANSINV_MDL : wont work.")
    !! update the information needed by the 'real' call to FSPGLH from the trans library
    CALL FSPGL_FILL(YDGEOMETRY%YRMP%MYLEVS, PKRF, YDML_GCONF%YRRIP%TSTEP)
    CALL INV_TRANS(PSPSCALAR=ZSP(:,:),LDSCDERS=LLSCDERS,KRESOL=NRESOL,KPROMA=NPROMA,&
     & KVSETSC=IVSETSC(:),PGP=PGMVS(:,1:IDIMGMVS,:),FSPGL_PROC=FSPGLH)
  ELSE
    CALL INV_TRANS(PSPSCALAR=ZSP(:,:),LDSCDERS=LLSCDERS,KRESOL=NRESOL,KPROMA=NPROMA,&
     & KVSETSC=IVSETSC(:),PGP=PGMVS(:,1:IDIMGMVS,:))
  ENDIF
! 3/scalar fields - gmv
  IF (NFLEVG==NFLEVL) THEN
    ICHUNKS=MIN((((IENGMV-ISTGMV+1)*NFLEVG-1)/NPROMATR+1),NFLEVG)
  ELSE
!   Vertical level distribution not coded
!   Mixture of NFLEVG and NFLEVL => bounds violations. REK
    CALL ABOR1('TRANSINV_MDL : NPROMATR /= 0 WITH NPRTRV /= 1 NOT CODED')
    ICHUNKS=1
  ENDIF
  ISPF=SIZE(PSPHV,DIM=3)
  IMAXLEV=(NFLEVG-1)/ICHUNKS+1
  DO JSTLEV=1,NFLEVG,IMAXLEV
    IENDLEV=JSTLEV-1+MIN(IMAXLEV,NFLEVG-JSTLEV+1)
    ILEVS=IENDLEV-JSTLEV+1
    IMAXGP=(IENGMV-ISTGMV+1)*ILEVS
    IMAXSP=ISPF*ILEVS
    ALLOCATE(IVSET(IMAXSP))
    ALLOCATE(ZSPEC(IMAXSP,NSPEC2))
    DO JFLD=1,ISPF
      DO JLEV=JSTLEV,IENDLEV
        IFLD=JLEV-JSTLEV+1+(JFLD-1)*ILEVS
        IVSET(IFLD)=NBSETLEV(JLEV)
        DO JSP=1,NSPEC2
          ZSPEC(IFLD,JSP)=PSPHV(JLEV,JSP,JFLD)
        ENDDO
      ENDDO
    ENDDO
    ALLOCATE(ZGP(NPROMA,IMAXGP,NGPBLKS))
    IF (LDFSCOMP) THEN
      IF (.NOT. PRESENT(PKRF)) CALL ABOR1( &
        & "Trying to run with LRFRIC but not providing Rayleigh coeff values to TRANSINV_MDL : wont work.")
      !! update the information needed by the 'real' call to FSPGLH from the trans library
      CALL FSPGL_FILL(YDGEOMETRY%YRMP%MYLEVS, PKRF, YDML_GCONF%YRRIP%TSTEP)
      CALL INV_TRANS(PSPSCALAR=ZSPEC(:,:),LDSCDERS=LLSCDERS,KRESOL=NRESOL,KPROMA=NPROMA,&
       & KVSETSC=IVSET(:),PGP=ZGP(:,:,:),FSPGL_PROC=FSPGLH)
    ELSE
      CALL INV_TRANS(PSPSCALAR=ZSPEC(:,:),LDSCDERS=LLSCDERS,KRESOL=NRESOL,KPROMA=NPROMA,&
       & KVSETSC=IVSET(:),PGP=ZGP(:,:,:))
    ENDIF
    DEALLOCATE(ZSPEC)
    DEALLOCATE(IVSET)
!$OMP PARALLEL PRIVATE(JKGLO,IBL,IEND1,JFLD,JLEV,IFLD,JROF)
!$OMP DO
    DO JKGLO=1,NGPTOT,NPROMA
      IBL=(JKGLO-1)/NPROMA+1
      IEND1=MIN(NPROMA,NGPTOT-JKGLO+1)
      DO JFLD=ISTGMV,IENGMV
        DO JLEV=JSTLEV,IENDLEV
          IFLD=JLEV-JSTLEV+1+(JFLD-ISTGMV)*ILEVS
          DO JROF=IST1,IEND1
            PGMV(JROF,JLEV,JFLD,IBL)=ZGP(JROF,IFLD,IBL)
          ENDDO
        ENDDO
      ENDDO
    ENDDO
!$OMP END DO
!$OMP END PARALLEL
    DEALLOCATE(ZGP)
  ENDDO
! 4/scalar fields - gfl
  IDIM3 = NUMSPFLDS
  IF (LLSCDERS) IDIM3 = IDIM3*3
  IF (NFLEVG==NFLEVL) THEN
    ICHUNKS=MIN(((IDIM3*NFLEVG-1)/NPROMATR+1),NFLEVG)
  ELSE
!   Vertical level distribution not coded
!   Mixture of NFLEVG and NFLEVL => bounds violations. REK
    CALL ABOR1('TRANSINV_MDL : NPROMATR /= 0 WITH NPRTRV /= 1 NOT CODED')
    ICHUNKS=1
  ENDIF
  ISPF=SIZE(PSPGFL,DIM=3)
  IMAXLEV=(NFLEVG-1)/ICHUNKS+1
  DO JSTLEV=1,NFLEVG,IMAXLEV
    IENDLEV=JSTLEV-1+MIN(IMAXLEV,NFLEVG-JSTLEV+1)
    ILEVS=IENDLEV-JSTLEV+1
    IMAXGP=IDIM3*ILEVS
    IMAXSP=ISPF*ILEVS
    ALLOCATE(IVSET(IMAXSP))
    ALLOCATE(ZSPEC(IMAXSP,NSPEC2))
    DO JFLD=1,ISPF
      DO JLEV=JSTLEV,IENDLEV
        IFLD=JLEV-JSTLEV+1+(JFLD-1)*ILEVS
        IVSET(IFLD)=NBSETLEV(JLEV)
        DO JSP=1,NSPEC2
          ZSPEC(IFLD,JSP)=PSPGFL(JLEV,JSP,JFLD)
        ENDDO
      ENDDO
    ENDDO
    ALLOCATE(ZGP(NPROMA,IMAXGP,NGPBLKS))
    IF (LDFSCOMP) THEN
      IF (.NOT. PRESENT(PKRF)) CALL ABOR1( &
        & "Trying to run with LRFRIC but not providing Rayleigh coeff values to TRANSINV_MDL : wont work.")
      !! update the information needed by the 'real' call to FSPGLH from the trans library
      CALL FSPGL_FILL(YDGEOMETRY%YRMP%MYLEVS, PKRF, YDML_GCONF%YRRIP%TSTEP)
      CALL INV_TRANS(PSPSCALAR=ZSPEC(:,:),LDSCDERS=LLSCDERS,KRESOL=NRESOL,KPROMA=NPROMA,&
       & KVSETSC=IVSET(:),PGP=ZGP(:,:,:),FSPGL_PROC=FSPGLH)
    ELSE
      CALL INV_TRANS(PSPSCALAR=ZSPEC(:,:),LDSCDERS=LLSCDERS,KRESOL=NRESOL,KPROMA=NPROMA,&
       & KVSETSC=IVSET(:),PGP=ZGP(:,:,:))
    ENDIF
    DEALLOCATE(ZSPEC)
    DEALLOCATE(IVSET)
    IF(NUMSPFLDS>0) THEN
      IOFF = NUMFLDS-NUMSPFLDS
    ELSE
      IOFF = 0
    ENDIF
!$OMP PARALLEL PRIVATE(JKGLO,IBL,IEND1,JFLD,JLEV,IFLD,JROF)
!$OMP DO
    DO JKGLO=1,NGPTOT,NPROMA
      IBL=(JKGLO-1)/NPROMA+1
      IEND1=MIN(NPROMA,NGPTOT-JKGLO+1)
      DO JFLD=1,IDIM3
        DO JLEV=JSTLEV,IENDLEV
          IFLD=JLEV-JSTLEV+1+(JFLD-1)*ILEVS
          DO JROF=IST1,IEND1
            PGFL(JROF,JLEV,JFLD+IOFF,IBL)=ZGP(JROF,IFLD,IBL)
          ENDDO
        ENDDO
      ENDDO
    ENDDO
!$OMP END DO
!$OMP END PARALLEL
    DEALLOCATE(ZGP)
  ENDDO
ENDIF

!     ------------------------------------------------------------------
!     .INVERSE TRANSFORM OF SPECTRAL DDH TENDENCIES
!     ------------------------------------------------------------------

IF (LLSIDDH) THEN
  ISTGMV = MSIDDH_V1+1
  IENGMV = MAX(2,NDIMSIGMV/3)
  ! Inverse transform spectral SI tendencies
  IF (ISTGMV > IENGMV) THEN
    CALL INV_TRANS(&
     & PSPVOR=PSPTNDSI_VOR,PSPDIV=PSPTNDSI_DIV,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,&
     & PGPUV=PGMVTNDSI(:,:,MSIDDH_U1:MSIDDH_V1,:))
  ELSE
    IFLDHV=MIN(3,NFTHER)
    ALLOCATE(ZSPTND_HV(NFLEVG,NSPEC2,IFLDHV))
    IF (IFLDHV < 3) THEN
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,1)= PSPTNDSI_T(1:NFLEVG,1:NSPEC2)
    ELSE
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,1)= PSPTNDSI_T(1:NFLEVG,1:NSPEC2)
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,2)= PSPTNDSI_SPD(1:NFLEVG,1:NSPEC2)
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,3)= PSPTNDSI_SVD(1:NFLEVG,1:NSPEC2)
    ENDIF
    CALL INV_TRANS(&
     & PSPVOR=PSPTNDSI_VOR,PSPDIV=PSPTNDSI_DIV,PSPSC3A=ZSPTND_HV,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC3A=NBSETLEV,&
     & PGPUV=PGMVTNDSI(:,:,MSIDDH_U1:MSIDDH_V1,:),&
     & PGP3A=PGMVTNDSI(:,:,ISTGMV:IENGMV,:))
    DEALLOCATE(ZSPTND_HV)
  ENDIF
ENDIF

IF (LLHDDDH) THEN
  ! Inverse transform spectral HD tendencies
  IF (NFTHER > 0) THEN
    ALLOCATE(ZSPTND_HV(NFLEVG,NSPEC2,NFTHER))
    ZSPTND_HV(1:NFLEVG,1:NSPEC2,1)= PSPTNDHD_T(1:NFLEVG,1:NSPEC2)
    IF (LNHDYN) THEN
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,2)= PSPTNDHD_SPD(1:NFLEVG,1:NSPEC2)
      ZSPTND_HV(1:NFLEVG,1:NSPEC2,3)= PSPTNDHD_SVD(1:NFLEVG,1:NSPEC2)
    ENDIF
    IF (YRDYNA%LNHX) ZSPTND_HV(1:NFLEVG,1:NSPEC2,4)= PSPTNDHD_SNHX(1:NFLEVG,1:NSPEC2)
    IF (NUMSPFLDS>0) THEN
      CALL INV_TRANS(&
       & PSPVOR=PSPTNDHD_VOR,PSPDIV=PSPTNDHD_DIV,&
       & PSPSC3A=ZSPTND_HV,PSPSC3B=PSPTNDHD_GFL,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,&
       & KVSETSC3A=NBSETLEV,KVSETSC3B=NBSETLEV,&
       & PGPUV=PGMVTNDHD(:,:,MHDDDH_U:MHDDDH_V,:),&
       & PGP3A=PGMVTNDHD(:,:,MHDDDH_V+1:MHDDDH_V+NFTHER,:),&
       & PGP3B=PGFLTNDHD(:,:,1:MHDDDH_Q,:))
    ELSE
      CALL INV_TRANS(&
       & PSPVOR=PSPTNDHD_VOR,PSPDIV=PSPTNDHD_DIV,PSPSC3A=ZSPTND_HV,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC3A=NBSETLEV,&
       & PGPUV=PGMVTNDHD(:,:,MHDDDH_U:MHDDDH_V,:),&
       & PGP3A=PGMVTNDHD(:,:,MHDDDH_V+1:MHDDDH_V+NFTHER,:))
    ENDIF
    DEALLOCATE(ZSPTND_HV)
  ELSE
    IF (NUMSPFLDS>0) THEN
      CALL INV_TRANS(&
       & PSPVOR=PSPTNDHD_VOR,PSPDIV=PSPTNDHD_DIV,&
       & PSPSC3B=PSPTNDHD_GFL,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,&
       & KVSETSC3B=NBSETLEV,&
       & PGPUV=PGMVTNDHD(:,:,MHDDDH_U:MHDDDH_V,:),&
       & PGP3B=PGFLTNDHD(:,:,1:MHDDDH_Q,:))
    ELSE
      CALL INV_TRANS(&
       & PSPVOR=PSPTNDHD_VOR,PSPDIV=PSPTNDHD_DIV,&
       & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,&
       & PGPUV=PGMVTNDHD(:,:,MHDDDH_U:MHDDDH_V,:))
    ENDIF
  ENDIF
ENDIF

!     ------------------------------------------------------------------

END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('TRANSINV_MDL',1,ZHOOK_HANDLE)

!     ------------------------------------------------------------------

END SUBROUTINE TRANSINV_MDL


