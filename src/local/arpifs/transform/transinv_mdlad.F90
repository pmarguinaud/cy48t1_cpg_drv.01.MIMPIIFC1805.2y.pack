SUBROUTINE TRANSINV_MDLAD(YDGEOMETRY,YDGMV,YDML_GCONF,PSPVOR,PSPDIV,PSPSP,PSPHV,PSPGFL,&
 & PGMV,PGMVS,PGFL,LDERR,LDVOR,LDFSCOMP,PSPVOR_FLT,PSPDIV_FLT)

!**** *TRANSINV_MDLAD * - Inverse transforms for model (adjoint)

!     Purpose.  Perform inverse transform (spectral to gridpoint)
!     --------

!**   Interface.  CALL TRANSINV_MDLAD(...)
!     ---------- 

!     Explicit arguments : 
!     --------------------
!        PSPVOR - spectral vorticity
!        PSPDIV - spectral divergence
!        PSPSP  - spectral surface pressure
!        PSPHV  - spectral thermodynamic variables
!        PSPGFL - spectral GFL variables
!        PGMV   - GMV gridpoint
!        PGMVS  - GMV single level gridpoint
!        PGFL   - GFL gridpoint
!        LDERR  - TRUE if derivatives required
!        LDVOR  - TRUE if vorticity required
!        LDFSCOMP - true if "scientific" computations in fourier space req.

!        Called by TRANSINVHAD

!     Externals.
!     ----------
!     INV_TRANSAD - inverse transform (TRANS library)

!     Reference.
!     ----------
!        ECMWF Research Department documentation of the IFS

!     Author.
!     -------
!        Mats Hamrud *ECMWF*

!     Modifications.
!     --------------
!        Original : 00-10-25
!        Modified : 03-08-01 M.Hamrud - GFL introduction
!        M.Hamrud      01-Oct-2003 CY28 Cleaning

!     ------------------------------------------------------------------

USE MODEL_GENERAL_CONF_MOD , ONLY : MODEL_GENERAL_CONF_TYPE
USE GEOMETRY_MOD , ONLY : GEOMETRY
USE YOMGMV   , ONLY : TGMV
USE PARKIND1 , ONLY : JPIM, JPRB
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK
USE YOMMP0   , ONLY : MYSETV
USE YOMCT3   , ONLY : NSTEP
USE YOMDYNA   ,ONLY : YRDYNA
!     ------------------------------------------------------------------

IMPLICIT NONE

TYPE(GEOMETRY)    ,INTENT(IN)    :: YDGEOMETRY
TYPE(TGMV)        ,INTENT(INOUT) :: YDGMV
TYPE(MODEL_GENERAL_CONF_TYPE),INTENT(INOUT):: YDML_GCONF
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PSPVOR(:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PSPDIV(:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSPSP(:) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PSPHV(:,:,:)
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PSPGFL(:,:,:)
REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGMV(:,:,:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGMVS(:,:,:)
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGFL(:,:,:,:)
LOGICAL           ,INTENT(IN)    :: LDERR 
LOGICAL           ,INTENT(IN)    :: LDVOR
LOGICAL           ,INTENT(IN)    :: LDFSCOMP 
REAL(KIND=JPRB), OPTIONAL, INTENT(OUT)  :: PSPVOR_FLT(:,:)
REAL(KIND=JPRB), OPTIONAL, INTENT(OUT)  :: PSPDIV_FLT(:,:)
!     ------------------------------------------------------------------
EXTERNAL FSPGLH
REAL(KIND=JPRB), ALLOCATABLE :: ZGRAD(:,:,:,:)
REAL(KIND=JPRB) :: ZSP(1,YDGEOMETRY%YRDIM%NSPEC2)
INTEGER(KIND=JPIM) :: IST,IOFF,IDIM3,ISTGMV,IENGMV,IDIMGMVS,ISTUV,IENUV, ICEND
INTEGER(KIND=JPIM) :: JKGLO, JLEV, IBL, JROF
INTEGER(KIND=JPIM) :: IVSETSC(1)
LOGICAL :: LLUVDER,LLSCDERS,LLDIVGP,LLGRADSP
REAL(KIND=JPRB) :: ZHOOK_HANDLE


!     ------------------------------------------------------------------

#include "inv_transad.h"

!     ------------------------------------------------------------------
IF (LHOOK) CALL DR_HOOK('TRANSINV_MDLAD',0,ZHOOK_HANDLE)
ASSOCIATE(YDDIM=>YDGEOMETRY%YRDIM,YDDIMV=>YDGEOMETRY%YRDIMV, &
  & YDGEM=>YDGEOMETRY%YRGEM, YDMP=>YDGEOMETRY%YRMP, YGFL=>YDML_GCONF%YGFL,YDDIMF=>YDML_GCONF%YRDIMF)
ASSOCIATE(NUMFLDS=>YGFL%NUMFLDS, NUMSPFLDS=>YGFL%NUMSPFLDS, &
 & NGPBLKS=>YDDIM%NGPBLKS, NPROMA=>YDDIM%NPROMA, NRESOL=>YDDIM%NRESOL, &
 & NSPEC2=>YDDIM%NSPEC2, &
 & LUVDER=>YDDIMF%LUVDER, &
 & NFLEVG=>YDDIMV%NFLEVG, &
 & NGPTOT=>YDGEM%NGPTOT, &
 & YT0=>YDGMV%YT0, YT9=>YDGMV%YT9, &
 & NBSETLEV=>YDMP%NBSETLEV, NBSETSP=>YDMP%NBSETSP)
!     ------------------------------------------------------------------

LLUVDER  = LUVDER .AND. LDERR
LLSCDERS = LDERR
LLDIVGP  = LDERR

IVSETSC(1) = NBSETSP

LLGRADSP = .FALSE.
IF ( PRESENT(PSPVOR_FLT)) THEN
  LLGRADSP = .TRUE.
ENDIF

CALL GSTATS(1827,0)
IF(NBSETSP == MYSETV) THEN
  IST = 1
  ZSP(IST,:) = PSPSP(:)
ELSE
  IST = 0
ENDIF
CALL GSTATS(1827,1)

ISTGMV=YT0%NDIMUV+1
IENGMV=YT0%NDIM
IF( YRDYNA%LGRADSP ) THEN
  IENGMV=IENGMV-2
ENDIF
IDIMGMVS=YT0%NDIMS
ISTUV=1
IENUV=YT0%NDIMUV
IF(.NOT.LLSCDERS) THEN
  IENGMV=ISTGMV-1+(IENGMV-ISTGMV+1)/3
  IDIMGMVS=IDIMGMVS/3
  ISTUV=YT0%MU
  IENUV=YT0%MV
ENDIF

IF(NUMSPFLDS>0) THEN
  IOFF=NUMFLDS-NUMSPFLDS
  IDIM3=NUMSPFLDS
  IF(LLSCDERS) IDIM3=IDIM3*3
  IF (LDFSCOMP) THEN
    CALL INV_TRANSAD(&
     & PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:IST,:),PSPSC3A=PSPHV,&
     & PSPSC3B=PSPGFL,&
     & LDSCDERS=LLSCDERS,LDVORGP=LDVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & KVSETSC3A=NBSETLEV,KVSETSC3B=NBSETLEV,&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
     & PGP3A=PGMV(:,:,ISTGMV:IENGMV,:),&
     & PGP3B=PGFL(:,:,IOFF+1:IOFF+IDIM3,:),&
     & FSPGL_PROC=FSPGLH)  
  ELSE
    CALL INV_TRANSAD(&
     & PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:IST,:),PSPSC3A=PSPHV,&
     & PSPSC3B=PSPGFL,&
     & LDSCDERS=LLSCDERS,LDVORGP=LDVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & KVSETSC3A=NBSETLEV,KVSETSC3B=NBSETLEV,&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
     & PGP3A=PGMV(:,:,ISTGMV:IENGMV,:),&
     & PGP3B=PGFL(:,:,IOFF+1:IOFF+IDIM3,:))  
  ENDIF
ELSE
  IF (LDFSCOMP) THEN
    CALL INV_TRANSAD(PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:1,:),PSPSC3A=PSPHV,&
     & LDSCDERS=LLSCDERS,LDVORGP=LDVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & KVSETSC3A=NBSETLEV,&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
     & PGP3A=PGMV(:,:,ISTGMV:IENGMV,:),&
     & FSPGL_PROC=FSPGLH)  
  ELSE
    CALL INV_TRANSAD(PSPVOR=PSPVOR,PSPDIV=PSPDIV,PSPSC2=ZSP(1:1,:),PSPSC3A=PSPHV,&
     & LDSCDERS=LLSCDERS,LDVORGP=LDVOR,LDDIVGP=LLDIVGP,LDUVDER=LLUVDER,&
     & KRESOL=NRESOL,KPROMA=NPROMA,KVSETUV=NBSETLEV,KVSETSC2=IVSETSC(1:1),&
     & KVSETSC3A=NBSETLEV,&
     & PGPUV=PGMV(:,:,ISTUV:IENUV,:),PGP2=PGMVS(:,1:IDIMGMVS,:),&
     & PGP3A=PGMV(:,:,ISTGMV:IENGMV,:))  
  ENDIF
ENDIF

IF( LLGRADSP ) THEN

  IF( NSTEP > 0 ) THEN
    ALLOCATE(ZGRAD(NPROMA,NFLEVG,2,NGPBLKS))
    !$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) &
    !$OMP& PRIVATE (JKGLO,IBL,ICEND) &
    !$OMP& PRIVATE (JROF,JLEV)
    DO JKGLO=1,NGPTOT,NPROMA
      IBL=(JKGLO-1)/NPROMA+1
      ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)
      
      DO JLEV=1,NFLEVG
        DO JROF=1,ICEND
          ! store the filtered rhs
          ZGRAD(JROF,JLEV,1,IBL) = PGMV(JROF,JLEV,YT0%MSGRTL,IBL)
          PGMV(JROF,JLEV,YT0%MSGRTL,IBL) = 0.0_JPRB
          ZGRAD(JROF,JLEV,2,IBL) = PGMV(JROF,JLEV,YT0%MSGRTM,IBL)
          PGMV(JROF,JLEV,YT0%MSGRTM,IBL) = 0.0_JPRB
        ENDDO
      ENDDO
    ENDDO
    !$OMP END PARALLEL DO

    PSPVOR_FLT(:,:)=0.0_JPRB
    PSPDIV_FLT(:,:)=0.0_JPRB
    CALL INV_TRANSAD(PSPVOR=PSPVOR_FLT,PSPDIV=PSPDIV_FLT,KVSETUV=NBSETLEV,&
     & KRESOL=NRESOL,KPROMA=NPROMA,PGPUV=ZGRAD)
    DEALLOCATE(ZGRAD)
  ELSE
    PSPVOR_FLT(:,:)=0.0_JPRB
    PSPDIV_FLT(:,:)=0.0_JPRB
    ! step 0, set to zero
    
    !$OMP PARALLEL DO SCHEDULE(DYNAMIC,1) &
    !$OMP& PRIVATE (JKGLO,IBL,ICEND) &
    !$OMP& PRIVATE (JROF,JLEV)
    DO JKGLO=1,NGPTOT,NPROMA
      IBL=(JKGLO-1)/NPROMA+1
      ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)
      
      DO JLEV=1,NFLEVG
        DO JROF=1,ICEND
          ! initialize unfiltered and filtered rhs
          PGMV(JROF,JLEV,YT9%MSGRTL,IBL) = 0.0_JPRB
          PGMV(JROF,JLEV,YT9%MSGRTM,IBL) = 0.0_JPRB

          PGMV(JROF,JLEV,YT0%MSGRTL,IBL) = 0.0_JPRB
          PGMV(JROF,JLEV,YT0%MSGRTM,IBL) = 0.0_JPRB
        ENDDO
      ENDDO
    ENDDO
    !$OMP END PARALLEL DO 
  ENDIF
ENDIF

CALL GSTATS(1828,0)
IF(NBSETSP == MYSETV) THEN
  PSPSP(:) = ZSP(IST,:)
ENDIF
CALL GSTATS(1828,1)

!     ------------------------------------------------------------------
END ASSOCIATE
END ASSOCIATE
IF (LHOOK) CALL DR_HOOK('TRANSINV_MDLAD',1,ZHOOK_HANDLE)
END SUBROUTINE TRANSINV_MDLAD
