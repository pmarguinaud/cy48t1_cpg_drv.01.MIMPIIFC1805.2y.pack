MODULE STACK_MOD

USE PARKIND1, ONLY : JPIM, JPRB, JPIB
USE ISO_C_BINDING

IMPLICIT NONE

TYPE STACK

  CHARACTER, POINTER :: CLDATA (:) => NULL ()
  INTEGER (KIND=JPIB) :: IPTR = 1

CONTAINS
  PROCEDURE, PRIVATE :: ALLOCR1, ALLOCR2, ALLOCR3, ALLOCR4
  GENERIC :: ALLOC => ALLOCR1, ALLOCR2, ALLOCR3, ALLOCR4
  PROCEDURE :: INIT
END TYPE

#include "abor1.intfb.h"


INTERFACE MALIGN
  MODULE PROCEDURE :: MALIGN4, MALIGN8
END INTERFACE

PRIVATE 
PUBLIC :: STACK, MALIGN

CONTAINS

FUNCTION MALIGN4 (KSIZE) RESULT (ISIZE)

INTEGER (KIND=JPIM), INTENT (IN) :: KSIZE
INTEGER (KIND=JPIB) :: ISIZE

ISIZE = 128 * ((KSIZE + 127) / 128)

END FUNCTION MALIGN4

FUNCTION MALIGN8 (KSIZE) RESULT (ISIZE)

INTEGER (KIND=JPIB), INTENT (IN) :: KSIZE
INTEGER (KIND=JPIB) :: ISIZE

ISIZE = 128 * ((KSIZE + 127) / 128)

END FUNCTION MALIGN8

SUBROUTINE INIT (SELF, CDDATA)

CLASS (STACK) :: SELF
CHARACTER, TARGET :: CDDATA (:)

SELF%CLDATA => CDDATA

END SUBROUTINE

SUBROUTINE ALLOCR1 (SELF, P1, KUBDS, KLBDS)

CLASS (STACK) :: SELF
REAL (KIND=JPRB), POINTER, CONTIGUOUS :: P1 (:)
INTEGER (KIND=JPIM) :: KUBDS (1)
INTEGER (KIND=JPIM), OPTIONAL :: KLBDS (1)
INTEGER (KIND=JPIM) :: ILBDS (1)

TYPE(C_PTR) :: CPTR
INTEGER (KIND=JPIB) :: ISIZE

ILBDS = 1
IF (PRESENT (KLBDS)) ILBDS = KLBDS

ISIZE = KIND (P1) * PRODUCT (KUBDS - ILBDS + 1)

IF (SELF%IPTR + ISIZE > SIZE (SELF%CLDATA) + 1) THEN
  WRITE (0, *) ISIZE, SELF%IPTR + ISIZE, SIZE (SELF%CLDATA)
  CALL ABOR1 ('STACK OF')
ENDIF

CPTR = C_LOC (SELF%CLDATA (SELF%IPTR))

CALL C_F_POINTER (CPTR, P1, KUBDS-ILBDS+1)

IF (PRESENT (KLBDS)) THEN
  P1 (KLBDS (1):) => P1
ENDIF

SELF%IPTR = SELF%IPTR + MALIGN (ISIZE)

END SUBROUTINE

SUBROUTINE ALLOCR2 (SELF, P2, KUBDS, KLBDS)

CLASS (STACK) :: SELF
REAL (KIND=JPRB), POINTER, CONTIGUOUS :: P2 (:,:)
INTEGER (KIND=JPIM) :: KUBDS (2)
INTEGER (KIND=JPIM), OPTIONAL :: KLBDS (2)
INTEGER (KIND=JPIM) :: ILBDS (2)

TYPE(C_PTR) :: CPTR
INTEGER (KIND=JPIB) :: ISIZE

ILBDS = 1
IF (PRESENT (KLBDS)) ILBDS = KLBDS

ISIZE = KIND (P2) * PRODUCT (KUBDS - ILBDS + 1)

IF (SELF%IPTR + ISIZE > SIZE (SELF%CLDATA) + 1) THEN
  WRITE (0, *) ISIZE, SELF%IPTR + ISIZE, SIZE (SELF%CLDATA)
  CALL ABOR1 ('STACK OF')
ENDIF

CPTR = C_LOC (SELF%CLDATA (SELF%IPTR))

CALL C_F_POINTER (CPTR, P2, KUBDS-ILBDS+1)

IF (PRESENT (KLBDS)) THEN
  P2 (KLBDS (1):, KLBDS (2):) => P2
ENDIF

SELF%IPTR = SELF%IPTR + MALIGN (ISIZE)

END SUBROUTINE

SUBROUTINE ALLOCR3 (SELF, P3, KUBDS, KLBDS)

CLASS (STACK) :: SELF
REAL (KIND=JPRB), POINTER, CONTIGUOUS :: P3 (:,:,:)
INTEGER (KIND=JPIM) :: KUBDS (3)
INTEGER (KIND=JPIM), OPTIONAL :: KLBDS (3)
INTEGER (KIND=JPIM) :: ILBDS (3)

TYPE(C_PTR) :: CPTR
INTEGER (KIND=JPIB) :: ISIZE

ILBDS = 1
IF (PRESENT (KLBDS)) ILBDS = KLBDS

ISIZE = KIND (P3) * PRODUCT (KUBDS - ILBDS + 1)

IF (SELF%IPTR + ISIZE > SIZE (SELF%CLDATA) + 1) THEN
  WRITE (0, *) ISIZE, SELF%IPTR + ISIZE, SIZE (SELF%CLDATA)
  CALL ABOR1 ('STACK OF')
ENDIF

CPTR = C_LOC (SELF%CLDATA (SELF%IPTR))

CALL C_F_POINTER (CPTR, P3, KUBDS-ILBDS+1)

IF (PRESENT (KLBDS)) THEN
  P3 (KLBDS (1):, KLBDS (2):, KLBDS (3):) => P3
ENDIF

SELF%IPTR = SELF%IPTR + MALIGN (ISIZE)

END SUBROUTINE

SUBROUTINE ALLOCR4 (SELF, P4, KUBDS, KLBDS)

CLASS (STACK) :: SELF
REAL (KIND=JPRB), POINTER, CONTIGUOUS :: P4 (:,:,:,:)
INTEGER (KIND=JPIM) :: KUBDS (4)
INTEGER (KIND=JPIM), OPTIONAL :: KLBDS (4)
INTEGER (KIND=JPIM) :: ILBDS (4)

TYPE(C_PTR) :: CPTR
INTEGER (KIND=JPIB) :: ISIZE

ILBDS = 1
IF (PRESENT (KLBDS)) ILBDS = KLBDS

ISIZE = KIND (P4) * PRODUCT (KUBDS - ILBDS + 1)

IF (SELF%IPTR + ISIZE > SIZE (SELF%CLDATA) + 1) THEN
  WRITE (0, *) ISIZE, SELF%IPTR + ISIZE, SIZE (SELF%CLDATA)
  CALL ABOR1 ('STACK OF')
ENDIF

CPTR = C_LOC (SELF%CLDATA (SELF%IPTR))

CALL C_F_POINTER (CPTR, P4, KUBDS-ILBDS+1)

IF (PRESENT (KLBDS)) THEN
  P4 (KLBDS (1):, KLBDS (2):, KLBDS (3):, KLBDS (4):) => P4
ENDIF

SELF%IPTR = SELF%IPTR + MALIGN (ISIZE)

END SUBROUTINE

END MODULE
